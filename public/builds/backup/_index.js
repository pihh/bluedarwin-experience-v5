!(function (t, n) {
  'object' == typeof exports && 'object' == typeof module
    ? (module.exports = n())
    : 'function' == typeof define && define.amd
    ? define('CognusChatbot', [], n)
    : 'object' == typeof exports
    ? (exports.CognusChatbot = n())
    : (t.CognusChatbot = n());
})(window, function () {
  return (function (t) {
    var n = {};
    function e(r) {
      if (n[r]) return n[r].exports;
      var o = (n[r] = { i: r, l: !1, exports: {} });
      return t[r].call(o.exports, o, o.exports, e), (o.l = !0), o.exports;
    }
    return (
      (e.m = t),
      (e.c = n),
      (e.d = function (t, n, r) {
        e.o(t, n) || Object.defineProperty(t, n, { enumerable: !0, get: r });
      }),
      (e.r = function (t) {
        'undefined' != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
          Object.defineProperty(t, '__esModule', { value: !0 });
      }),
      (e.t = function (t, n) {
        if ((1 & n && (t = e(t)), 8 & n)) return t;
        if (4 & n && 'object' == typeof t && t && t.__esModule) return t;
        var r = Object.create(null);
        if (
          (e.r(r),
          Object.defineProperty(r, 'default', { enumerable: !0, value: t }),
          2 & n && 'string' != typeof t)
        )
          for (var o in t)
            e.d(
              r,
              o,
              function (n) {
                return t[n];
              }.bind(null, o)
            );
        return r;
      }),
      (e.n = function (t) {
        var n =
          t && t.__esModule
            ? function () {
                return t.default;
              }
            : function () {
                return t;
              };
        return e.d(n, 'a', n), n;
      }),
      (e.o = function (t, n) {
        return Object.prototype.hasOwnProperty.call(t, n);
      }),
      (e.p = ''),
      e((e.s = 107))
    );
  })([
    function (t, n) {
      var e = (t.exports =
        'undefined' != typeof window && window.Math == Math
          ? window
          : 'undefined' != typeof self && self.Math == Math
          ? self
          : Function('return this')());
      'number' == typeof __g && (__g = e);
    },
    function (t, n, e) {
      var r = e(27)('wks'),
        o = e(22),
        a = e(0).Symbol,
        i = 'function' == typeof a;
      (t.exports = function (t) {
        return r[t] || (r[t] = (i && a[t]) || (i ? a : o)('Symbol.' + t));
      }).store = r;
    },
    function (t, n) {
      t.exports = function (t) {
        return 'object' == typeof t ? null !== t : 'function' == typeof t;
      };
    },
    function (t, n, e) {
      var r = e(2);
      t.exports = function (t) {
        if (!r(t)) throw TypeError(t + ' is not an object!');
        return t;
      };
    },
    function (t, n, e) {
      'use strict';
      var r = e(47),
        o = {};
      (o[e(1)('toStringTag')] = 'z'),
        o + '' != '[object z]' &&
          e(11)(
            Object.prototype,
            'toString',
            function () {
              return '[object ' + r(this) + ']';
            },
            !0
          );
    },
    function (t, n, e) {
      t.exports = !e(8)(function () {
        return (
          7 !=
          Object.defineProperty({}, 'a', {
            get: function () {
              return 7;
            },
          }).a
        );
      });
    },
    function (t, n, e) {
      'use strict';
      var r,
        o,
        a,
        i,
        s = e(21),
        c = e(0),
        u = e(16),
        f = e(47),
        d = e(10),
        l = e(2),
        h = e(17),
        p = e(48),
        y = e(49),
        v = e(86),
        x = e(65).set,
        m = e(87)(),
        _ = e(66),
        b = e(88),
        g = e(89),
        S = e(90),
        w = c.TypeError,
        C = c.process,
        k = C && C.versions,
        A = (k && k.v8) || '',
        E = c.Promise,
        T = 'process' == f(C),
        O = function () {},
        j = (o = _.f),
        B = !!(function () {
          try {
            var t = E.resolve(1),
              n = ((t.constructor = {})[e(1)('species')] = function (t) {
                t(O, O);
              });
            return (
              (T || 'function' == typeof PromiseRejectionEvent) &&
              t.then(O) instanceof n &&
              0 !== A.indexOf('6.6') &&
              -1 === g.indexOf('Chrome/66')
            );
          } catch (t) {}
        })(),
        R = function (t) {
          var n;
          return !(!l(t) || 'function' != typeof (n = t.then)) && n;
        },
        I = function (t, n) {
          if (!t._n) {
            t._n = !0;
            var e = t._c;
            m(function () {
              for (
                var r = t._v,
                  o = 1 == t._s,
                  a = 0,
                  i = function (n) {
                    var e,
                      a,
                      i,
                      s = o ? n.ok : n.fail,
                      c = n.resolve,
                      u = n.reject,
                      f = n.domain;
                    try {
                      s
                        ? (o || (2 == t._h && P(t), (t._h = 1)),
                          !0 === s
                            ? (e = r)
                            : (f && f.enter(),
                              (e = s(r)),
                              f && (f.exit(), (i = !0))),
                          e === n.promise
                            ? u(w('Promise-chain cycle'))
                            : (a = R(e))
                            ? a.call(e, c, u)
                            : c(e))
                        : u(r);
                    } catch (t) {
                      f && !i && f.exit(), u(t);
                    }
                  };
                e.length > a;

              )
                i(e[a++]);
              (t._c = []), (t._n = !1), n && !t._h && W(t);
            });
          }
        },
        W = function (t) {
          x.call(c, function () {
            var n,
              e,
              r,
              o = t._v,
              a = M(t);
            if (
              (a &&
                ((n = b(function () {
                  T
                    ? C.emit('unhandledRejection', o, t)
                    : (e = c.onunhandledrejection)
                    ? e({ promise: t, reason: o })
                    : (r = c.console) &&
                      r.error &&
                      r.error('Unhandled promise rejection', o);
                })),
                (t._h = T || M(t) ? 2 : 1)),
              (t._a = void 0),
              a && n.e)
            )
              throw n.v;
          });
        },
        M = function (t) {
          return 1 !== t._h && 0 === (t._a || t._c).length;
        },
        P = function (t) {
          x.call(c, function () {
            var n;
            T
              ? C.emit('rejectionHandled', t)
              : (n = c.onrejectionhandled) && n({ promise: t, reason: t._v });
          });
        },
        H = function (t) {
          var n = this;
          n._d ||
            ((n._d = !0),
            ((n = n._w || n)._v = t),
            (n._s = 2),
            n._a || (n._a = n._c.slice()),
            I(n, !0));
        },
        L = function (t) {
          var n,
            e = this;
          if (!e._d) {
            (e._d = !0), (e = e._w || e);
            try {
              if (e === t) throw w("Promise can't be resolved itself");
              (n = R(t))
                ? m(function () {
                    var r = { _w: e, _d: !1 };
                    try {
                      n.call(t, u(L, r, 1), u(H, r, 1));
                    } catch (t) {
                      H.call(r, t);
                    }
                  })
                : ((e._v = t), (e._s = 1), I(e, !1));
            } catch (t) {
              H.call({ _w: e, _d: !1 }, t);
            }
          }
        };
      B ||
        ((E = function (t) {
          p(this, E, 'Promise', '_h'), h(t), r.call(this);
          try {
            t(u(L, this, 1), u(H, this, 1));
          } catch (t) {
            H.call(this, t);
          }
        }),
        ((r = function (t) {
          (this._c = []),
            (this._a = void 0),
            (this._s = 0),
            (this._d = !1),
            (this._v = void 0),
            (this._h = 0),
            (this._n = !1);
        }).prototype = e(50)(E.prototype, {
          then: function (t, n) {
            var e = j(v(this, E));
            return (
              (e.ok = 'function' != typeof t || t),
              (e.fail = 'function' == typeof n && n),
              (e.domain = T ? C.domain : void 0),
              this._c.push(e),
              this._a && this._a.push(e),
              this._s && I(this, !1),
              e.promise
            );
          },
          catch: function (t) {
            return this.then(void 0, t);
          },
        })),
        (a = function () {
          var t = new r();
          (this.promise = t),
            (this.resolve = u(L, t, 1)),
            (this.reject = u(H, t, 1));
        }),
        (_.f = j =
          function (t) {
            return t === E || t === i ? new a(t) : o(t);
          })),
        d(d.G + d.W + d.F * !B, { Promise: E }),
        e(23)(E, 'Promise'),
        e(67)('Promise'),
        (i = e(13).Promise),
        d(d.S + d.F * !B, 'Promise', {
          reject: function (t) {
            var n = j(this);
            return (0, n.reject)(t), n.promise;
          },
        }),
        d(d.S + d.F * (s || !B), 'Promise', {
          resolve: function (t) {
            return S(s && this === i ? E : this, t);
          },
        }),
        d(
          d.S +
            d.F *
              !(
                B &&
                e(68)(function (t) {
                  E.all(t).catch(O);
                })
              ),
          'Promise',
          {
            all: function (t) {
              var n = this,
                e = j(n),
                r = e.resolve,
                o = e.reject,
                a = b(function () {
                  var e = [],
                    a = 0,
                    i = 1;
                  y(t, !1, function (t) {
                    var s = a++,
                      c = !1;
                    e.push(void 0),
                      i++,
                      n.resolve(t).then(function (t) {
                        c || ((c = !0), (e[s] = t), --i || r(e));
                      }, o);
                  }),
                    --i || r(e);
                });
              return a.e && o(a.v), e.promise;
            },
            race: function (t) {
              var n = this,
                e = j(n),
                r = e.reject,
                o = b(function () {
                  y(t, !1, function (t) {
                    n.resolve(t).then(e.resolve, r);
                  });
                });
              return o.e && r(o.v), e.promise;
            },
          }
        );
    },
    function (t, n, e) {
      var r = e(3),
        o = e(55),
        a = e(36),
        i = Object.defineProperty;
      n.f = e(5)
        ? Object.defineProperty
        : function (t, n, e) {
            if ((r(t), (n = a(n, !0)), r(e), o))
              try {
                return i(t, n, e);
              } catch (t) {}
            if ('get' in e || 'set' in e)
              throw TypeError('Accessors not supported!');
            return 'value' in e && (t[n] = e.value), t;
          };
    },
    function (t, n) {
      t.exports = function (t) {
        try {
          return !!t();
        } catch (t) {
          return !0;
        }
      };
    },
    function (t, n) {
      !(function (n) {
        'use strict';
        var e,
          r = Object.prototype,
          o = r.hasOwnProperty,
          a = 'function' == typeof Symbol ? Symbol : {},
          i = a.iterator || '@@iterator',
          s = a.asyncIterator || '@@asyncIterator',
          c = a.toStringTag || '@@toStringTag',
          u = 'object' == typeof t,
          f = n.regeneratorRuntime;
        if (f) u && (t.exports = f);
        else {
          (f = n.regeneratorRuntime = u ? t.exports : {}).wrap = b;
          var d = 'suspendedStart',
            l = 'suspendedYield',
            h = 'executing',
            p = 'completed',
            y = {},
            v = {};
          v[i] = function () {
            return this;
          };
          var x = Object.getPrototypeOf,
            m = x && x(x(B([])));
          m && m !== r && o.call(m, i) && (v = m);
          var _ = (C.prototype = S.prototype = Object.create(v));
          (w.prototype = _.constructor = C),
            (C.constructor = w),
            (C[c] = w.displayName = 'GeneratorFunction'),
            (f.isGeneratorFunction = function (t) {
              var n = 'function' == typeof t && t.constructor;
              return (
                !!n &&
                (n === w || 'GeneratorFunction' === (n.displayName || n.name))
              );
            }),
            (f.mark = function (t) {
              return (
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(t, C)
                  : ((t.__proto__ = C), c in t || (t[c] = 'GeneratorFunction')),
                (t.prototype = Object.create(_)),
                t
              );
            }),
            (f.awrap = function (t) {
              return { __await: t };
            }),
            k(A.prototype),
            (A.prototype[s] = function () {
              return this;
            }),
            (f.AsyncIterator = A),
            (f.async = function (t, n, e, r) {
              var o = new A(b(t, n, e, r));
              return f.isGeneratorFunction(n)
                ? o
                : o.next().then(function (t) {
                    return t.done ? t.value : o.next();
                  });
            }),
            k(_),
            (_[c] = 'Generator'),
            (_[i] = function () {
              return this;
            }),
            (_.toString = function () {
              return '[object Generator]';
            }),
            (f.keys = function (t) {
              var n = [];
              for (var e in t) n.push(e);
              return (
                n.reverse(),
                function e() {
                  for (; n.length; ) {
                    var r = n.pop();
                    if (r in t) return (e.value = r), (e.done = !1), e;
                  }
                  return (e.done = !0), e;
                }
              );
            }),
            (f.values = B),
            (j.prototype = {
              constructor: j,
              reset: function (t) {
                if (
                  ((this.prev = 0),
                  (this.next = 0),
                  (this.sent = this._sent = e),
                  (this.done = !1),
                  (this.delegate = null),
                  (this.method = 'next'),
                  (this.arg = e),
                  this.tryEntries.forEach(O),
                  !t)
                )
                  for (var n in this)
                    't' === n.charAt(0) &&
                      o.call(this, n) &&
                      !isNaN(+n.slice(1)) &&
                      (this[n] = e);
              },
              stop: function () {
                this.done = !0;
                var t = this.tryEntries[0].completion;
                if ('throw' === t.type) throw t.arg;
                return this.rval;
              },
              dispatchException: function (t) {
                if (this.done) throw t;
                var n = this;
                function r(r, o) {
                  return (
                    (s.type = 'throw'),
                    (s.arg = t),
                    (n.next = r),
                    o && ((n.method = 'next'), (n.arg = e)),
                    !!o
                  );
                }
                for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                  var i = this.tryEntries[a],
                    s = i.completion;
                  if ('root' === i.tryLoc) return r('end');
                  if (i.tryLoc <= this.prev) {
                    var c = o.call(i, 'catchLoc'),
                      u = o.call(i, 'finallyLoc');
                    if (c && u) {
                      if (this.prev < i.catchLoc) return r(i.catchLoc, !0);
                      if (this.prev < i.finallyLoc) return r(i.finallyLoc);
                    } else if (c) {
                      if (this.prev < i.catchLoc) return r(i.catchLoc, !0);
                    } else {
                      if (!u)
                        throw new Error(
                          'try statement without catch or finally'
                        );
                      if (this.prev < i.finallyLoc) return r(i.finallyLoc);
                    }
                  }
                }
              },
              abrupt: function (t, n) {
                for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                  var r = this.tryEntries[e];
                  if (
                    r.tryLoc <= this.prev &&
                    o.call(r, 'finallyLoc') &&
                    this.prev < r.finallyLoc
                  ) {
                    var a = r;
                    break;
                  }
                }
                a &&
                  ('break' === t || 'continue' === t) &&
                  a.tryLoc <= n &&
                  n <= a.finallyLoc &&
                  (a = null);
                var i = a ? a.completion : {};
                return (
                  (i.type = t),
                  (i.arg = n),
                  a
                    ? ((this.method = 'next'), (this.next = a.finallyLoc), y)
                    : this.complete(i)
                );
              },
              complete: function (t, n) {
                if ('throw' === t.type) throw t.arg;
                return (
                  'break' === t.type || 'continue' === t.type
                    ? (this.next = t.arg)
                    : 'return' === t.type
                    ? ((this.rval = this.arg = t.arg),
                      (this.method = 'return'),
                      (this.next = 'end'))
                    : 'normal' === t.type && n && (this.next = n),
                  y
                );
              },
              finish: function (t) {
                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                  var e = this.tryEntries[n];
                  if (e.finallyLoc === t)
                    return this.complete(e.completion, e.afterLoc), O(e), y;
                }
              },
              catch: function (t) {
                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                  var e = this.tryEntries[n];
                  if (e.tryLoc === t) {
                    var r = e.completion;
                    if ('throw' === r.type) {
                      var o = r.arg;
                      O(e);
                    }
                    return o;
                  }
                }
                throw new Error('illegal catch attempt');
              },
              delegateYield: function (t, n, r) {
                return (
                  (this.delegate = {
                    iterator: B(t),
                    resultName: n,
                    nextLoc: r,
                  }),
                  'next' === this.method && (this.arg = e),
                  y
                );
              },
            });
        }
        function b(t, n, e, r) {
          var o = n && n.prototype instanceof S ? n : S,
            a = Object.create(o.prototype),
            i = new j(r || []);
          return (
            (a._invoke = (function (t, n, e) {
              var r = d;
              return function (o, a) {
                if (r === h) throw new Error('Generator is already running');
                if (r === p) {
                  if ('throw' === o) throw a;
                  return R();
                }
                for (e.method = o, e.arg = a; ; ) {
                  var i = e.delegate;
                  if (i) {
                    var s = E(i, e);
                    if (s) {
                      if (s === y) continue;
                      return s;
                    }
                  }
                  if ('next' === e.method) e.sent = e._sent = e.arg;
                  else if ('throw' === e.method) {
                    if (r === d) throw ((r = p), e.arg);
                    e.dispatchException(e.arg);
                  } else 'return' === e.method && e.abrupt('return', e.arg);
                  r = h;
                  var c = g(t, n, e);
                  if ('normal' === c.type) {
                    if (((r = e.done ? p : l), c.arg === y)) continue;
                    return { value: c.arg, done: e.done };
                  }
                  'throw' === c.type &&
                    ((r = p), (e.method = 'throw'), (e.arg = c.arg));
                }
              };
            })(t, e, i)),
            a
          );
        }
        function g(t, n, e) {
          try {
            return { type: 'normal', arg: t.call(n, e) };
          } catch (t) {
            return { type: 'throw', arg: t };
          }
        }
        function S() {}
        function w() {}
        function C() {}
        function k(t) {
          ['next', 'throw', 'return'].forEach(function (n) {
            t[n] = function (t) {
              return this._invoke(n, t);
            };
          });
        }
        function A(t) {
          var n;
          this._invoke = function (e, r) {
            function a() {
              return new Promise(function (n, a) {
                !(function n(e, r, a, i) {
                  var s = g(t[e], t, r);
                  if ('throw' !== s.type) {
                    var c = s.arg,
                      u = c.value;
                    return u && 'object' == typeof u && o.call(u, '__await')
                      ? Promise.resolve(u.__await).then(
                          function (t) {
                            n('next', t, a, i);
                          },
                          function (t) {
                            n('throw', t, a, i);
                          }
                        )
                      : Promise.resolve(u).then(function (t) {
                          (c.value = t), a(c);
                        }, i);
                  }
                  i(s.arg);
                })(e, r, n, a);
              });
            }
            return (n = n ? n.then(a, a) : a());
          };
        }
        function E(t, n) {
          var r = t.iterator[n.method];
          if (r === e) {
            if (((n.delegate = null), 'throw' === n.method)) {
              if (
                t.iterator.return &&
                ((n.method = 'return'),
                (n.arg = e),
                E(t, n),
                'throw' === n.method)
              )
                return y;
              (n.method = 'throw'),
                (n.arg = new TypeError(
                  "The iterator does not provide a 'throw' method"
                ));
            }
            return y;
          }
          var o = g(r, t.iterator, n.arg);
          if ('throw' === o.type)
            return (
              (n.method = 'throw'), (n.arg = o.arg), (n.delegate = null), y
            );
          var a = o.arg;
          return a
            ? a.done
              ? ((n[t.resultName] = a.value),
                (n.next = t.nextLoc),
                'return' !== n.method && ((n.method = 'next'), (n.arg = e)),
                (n.delegate = null),
                y)
              : a
            : ((n.method = 'throw'),
              (n.arg = new TypeError('iterator result is not an object')),
              (n.delegate = null),
              y);
        }
        function T(t) {
          var n = { tryLoc: t[0] };
          1 in t && (n.catchLoc = t[1]),
            2 in t && ((n.finallyLoc = t[2]), (n.afterLoc = t[3])),
            this.tryEntries.push(n);
        }
        function O(t) {
          var n = t.completion || {};
          (n.type = 'normal'), delete n.arg, (t.completion = n);
        }
        function j(t) {
          (this.tryEntries = [{ tryLoc: 'root' }]),
            t.forEach(T, this),
            this.reset(!0);
        }
        function B(t) {
          if (t) {
            var n = t[i];
            if (n) return n.call(t);
            if ('function' == typeof t.next) return t;
            if (!isNaN(t.length)) {
              var r = -1,
                a = function n() {
                  for (; ++r < t.length; )
                    if (o.call(t, r)) return (n.value = t[r]), (n.done = !1), n;
                  return (n.value = e), (n.done = !0), n;
                };
              return (a.next = a);
            }
          }
          return { next: R };
        }
        function R() {
          return { value: e, done: !0 };
        }
      })(
        (function () {
          return this;
        })() || Function('return this')()
      );
    },
    function (t, n, e) {
      var r = e(0),
        o = e(13),
        a = e(15),
        i = e(11),
        s = e(16),
        c = function (t, n, e) {
          var u,
            f,
            d,
            l,
            h = t & c.F,
            p = t & c.G,
            y = t & c.S,
            v = t & c.P,
            x = t & c.B,
            m = p ? r : y ? r[n] || (r[n] = {}) : (r[n] || {}).prototype,
            _ = p ? o : o[n] || (o[n] = {}),
            b = _.prototype || (_.prototype = {});
          for (u in (p && (e = n), e))
            (d = ((f = !h && m && void 0 !== m[u]) ? m : e)[u]),
              (l =
                x && f
                  ? s(d, r)
                  : v && 'function' == typeof d
                  ? s(Function.call, d)
                  : d),
              m && i(m, u, d, t & c.U),
              _[u] != d && a(_, u, l),
              v && b[u] != d && (b[u] = d);
        };
      (r.core = o),
        (c.F = 1),
        (c.G = 2),
        (c.S = 4),
        (c.P = 8),
        (c.B = 16),
        (c.W = 32),
        (c.U = 64),
        (c.R = 128),
        (t.exports = c);
    },
    function (t, n, e) {
      var r = e(0),
        o = e(15),
        a = e(14),
        i = e(22)('src'),
        s = e(74),
        c = ('' + s).split('toString');
      (e(13).inspectSource = function (t) {
        return s.call(t);
      }),
        (t.exports = function (t, n, e, s) {
          var u = 'function' == typeof e;
          u && (a(e, 'name') || o(e, 'name', n)),
            t[n] !== e &&
              (u && (a(e, i) || o(e, i, t[n] ? '' + t[n] : c.join(String(n)))),
              t === r
                ? (t[n] = e)
                : s
                ? t[n]
                  ? (t[n] = e)
                  : o(t, n, e)
                : (delete t[n], o(t, n, e)));
        })(Function.prototype, 'toString', function () {
          return ('function' == typeof this && this[i]) || s.call(this);
        });
    },
    function (t, n, e) {
      var r;
      t.exports = (function t(n, e, o) {
        function a(s, c) {
          if (!e[s]) {
            if (!n[s]) {
              if (!c && 'function' == typeof r && r) return r(s, !0);
              if (i) return i(s, !0);
              var u = new Error("Cannot find module '" + s + "'");
              throw ((u.code = 'MODULE_NOT_FOUND'), u);
            }
            var f = (e[s] = { exports: {} });
            n[s][0].call(
              f.exports,
              function (t) {
                var e = n[s][1][t];
                return a(e || t);
              },
              f,
              f.exports,
              t,
              n,
              e,
              o
            );
          }
          return e[s].exports;
        }
        for (var i = 'function' == typeof r && r, s = 0; s < o.length; s++)
          a(o[s]);
        return a;
      })(
        {
          1: [
            function (t, n, e) {
              (function (t) {
                'use strict';
                var e,
                  r,
                  o = t.MutationObserver || t.WebKitMutationObserver;
                if (o) {
                  var a = 0,
                    i = new o(f),
                    s = t.document.createTextNode('');
                  i.observe(s, { characterData: !0 }),
                    (e = function () {
                      s.data = a = ++a % 2;
                    });
                } else if (t.setImmediate || void 0 === t.MessageChannel)
                  e =
                    'document' in t &&
                    'onreadystatechange' in t.document.createElement('script')
                      ? function () {
                          var n = t.document.createElement('script');
                          (n.onreadystatechange = function () {
                            f(),
                              (n.onreadystatechange = null),
                              n.parentNode.removeChild(n),
                              (n = null);
                          }),
                            t.document.documentElement.appendChild(n);
                        }
                      : function () {
                          setTimeout(f, 0);
                        };
                else {
                  var c = new t.MessageChannel();
                  (c.port1.onmessage = f),
                    (e = function () {
                      c.port2.postMessage(0);
                    });
                }
                var u = [];
                function f() {
                  var t, n;
                  r = !0;
                  for (var e = u.length; e; ) {
                    for (n = u, u = [], t = -1; ++t < e; ) n[t]();
                    e = u.length;
                  }
                  r = !1;
                }
                n.exports = function (t) {
                  1 !== u.push(t) || r || e();
                };
              }).call(
                this,
                'undefined' != typeof global
                  ? global
                  : 'undefined' != typeof self
                  ? self
                  : 'undefined' != typeof window
                  ? window
                  : {}
              );
            },
            {},
          ],
          2: [
            function (t, n, e) {
              'use strict';
              var r = t(1);
              function o() {}
              var a = {},
                i = ['REJECTED'],
                s = ['FULFILLED'],
                c = ['PENDING'];
              function u(t) {
                if ('function' != typeof t)
                  throw new TypeError('resolver must be a function');
                (this.state = c),
                  (this.queue = []),
                  (this.outcome = void 0),
                  t !== o && h(this, t);
              }
              function f(t, n, e) {
                (this.promise = t),
                  'function' == typeof n &&
                    ((this.onFulfilled = n),
                    (this.callFulfilled = this.otherCallFulfilled)),
                  'function' == typeof e &&
                    ((this.onRejected = e),
                    (this.callRejected = this.otherCallRejected));
              }
              function d(t, n, e) {
                r(function () {
                  var r;
                  try {
                    r = n(e);
                  } catch (n) {
                    return a.reject(t, n);
                  }
                  r === t
                    ? a.reject(
                        t,
                        new TypeError('Cannot resolve promise with itself')
                      )
                    : a.resolve(t, r);
                });
              }
              function l(t) {
                var n = t && t.then;
                if (
                  t &&
                  ('object' == typeof t || 'function' == typeof t) &&
                  'function' == typeof n
                )
                  return function () {
                    n.apply(t, arguments);
                  };
              }
              function h(t, n) {
                var e = !1;
                function r(n) {
                  e || ((e = !0), a.reject(t, n));
                }
                function o(n) {
                  e || ((e = !0), a.resolve(t, n));
                }
                var i = p(function () {
                  n(o, r);
                });
                'error' === i.status && r(i.value);
              }
              function p(t, n) {
                var e = {};
                try {
                  (e.value = t(n)), (e.status = 'success');
                } catch (t) {
                  (e.status = 'error'), (e.value = t);
                }
                return e;
              }
              (n.exports = u),
                (u.prototype.catch = function (t) {
                  return this.then(null, t);
                }),
                (u.prototype.then = function (t, n) {
                  if (
                    ('function' != typeof t && this.state === s) ||
                    ('function' != typeof n && this.state === i)
                  )
                    return this;
                  var e = new this.constructor(o);
                  return (
                    this.state !== c
                      ? d(e, this.state === s ? t : n, this.outcome)
                      : this.queue.push(new f(e, t, n)),
                    e
                  );
                }),
                (f.prototype.callFulfilled = function (t) {
                  a.resolve(this.promise, t);
                }),
                (f.prototype.otherCallFulfilled = function (t) {
                  d(this.promise, this.onFulfilled, t);
                }),
                (f.prototype.callRejected = function (t) {
                  a.reject(this.promise, t);
                }),
                (f.prototype.otherCallRejected = function (t) {
                  d(this.promise, this.onRejected, t);
                }),
                (a.resolve = function (t, n) {
                  var e = p(l, n);
                  if ('error' === e.status) return a.reject(t, e.value);
                  var r = e.value;
                  if (r) h(t, r);
                  else {
                    (t.state = s), (t.outcome = n);
                    for (var o = -1, i = t.queue.length; ++o < i; )
                      t.queue[o].callFulfilled(n);
                  }
                  return t;
                }),
                (a.reject = function (t, n) {
                  (t.state = i), (t.outcome = n);
                  for (var e = -1, r = t.queue.length; ++e < r; )
                    t.queue[e].callRejected(n);
                  return t;
                }),
                (u.resolve = function (t) {
                  return t instanceof this ? t : a.resolve(new this(o), t);
                }),
                (u.reject = function (t) {
                  var n = new this(o);
                  return a.reject(n, t);
                }),
                (u.all = function (t) {
                  var n = this;
                  if ('[object Array]' !== Object.prototype.toString.call(t))
                    return this.reject(new TypeError('must be an array'));
                  var e = t.length,
                    r = !1;
                  if (!e) return this.resolve([]);
                  for (
                    var i = new Array(e), s = 0, c = -1, u = new this(o);
                    ++c < e;

                  )
                    f(t[c], c);
                  return u;
                  function f(t, o) {
                    n.resolve(t).then(
                      function (t) {
                        (i[o] = t),
                          ++s !== e || r || ((r = !0), a.resolve(u, i));
                      },
                      function (t) {
                        r || ((r = !0), a.reject(u, t));
                      }
                    );
                  }
                }),
                (u.race = function (t) {
                  var n = this;
                  if ('[object Array]' !== Object.prototype.toString.call(t))
                    return this.reject(new TypeError('must be an array'));
                  var e = t.length,
                    r = !1;
                  if (!e) return this.resolve([]);
                  for (var i, s = -1, c = new this(o); ++s < e; )
                    (i = t[s]),
                      n.resolve(i).then(
                        function (t) {
                          r || ((r = !0), a.resolve(c, t));
                        },
                        function (t) {
                          r || ((r = !0), a.reject(c, t));
                        }
                      );
                  return c;
                });
            },
            { 1: 1 },
          ],
          3: [
            function (t, n, e) {
              (function (n) {
                'use strict';
                'function' != typeof n.Promise && (n.Promise = t(2));
              }).call(
                this,
                'undefined' != typeof global
                  ? global
                  : 'undefined' != typeof self
                  ? self
                  : 'undefined' != typeof window
                  ? window
                  : {}
              );
            },
            { 2: 2 },
          ],
          4: [
            function (t, n, e) {
              'use strict';
              var r =
                  'function' == typeof Symbol &&
                  'symbol' == typeof Symbol.iterator
                    ? function (t) {
                        return typeof t;
                      }
                    : function (t) {
                        return t &&
                          'function' == typeof Symbol &&
                          t.constructor === Symbol &&
                          t !== Symbol.prototype
                          ? 'symbol'
                          : typeof t;
                      },
                o = (function () {
                  try {
                    if ('undefined' != typeof indexedDB) return indexedDB;
                    if ('undefined' != typeof webkitIndexedDB)
                      return webkitIndexedDB;
                    if ('undefined' != typeof mozIndexedDB) return mozIndexedDB;
                    if ('undefined' != typeof OIndexedDB) return OIndexedDB;
                    if ('undefined' != typeof msIndexedDB) return msIndexedDB;
                  } catch (t) {
                    return;
                  }
                })();
              function a(t, n) {
                (t = t || []), (n = n || {});
                try {
                  return new Blob(t, n);
                } catch (o) {
                  if ('TypeError' !== o.name) throw o;
                  for (
                    var e = new (
                        'undefined' != typeof BlobBuilder
                          ? BlobBuilder
                          : 'undefined' != typeof MSBlobBuilder
                          ? MSBlobBuilder
                          : 'undefined' != typeof MozBlobBuilder
                          ? MozBlobBuilder
                          : WebKitBlobBuilder
                      )(),
                      r = 0;
                    r < t.length;
                    r += 1
                  )
                    e.append(t[r]);
                  return e.getBlob(n.type);
                }
              }
              'undefined' == typeof Promise && t(3);
              var i = Promise;
              function s(t, n) {
                n &&
                  t.then(
                    function (t) {
                      n(null, t);
                    },
                    function (t) {
                      n(t);
                    }
                  );
              }
              function c(t, n, e) {
                'function' == typeof n && t.then(n),
                  'function' == typeof e && t.catch(e);
              }
              function u(t) {
                return (
                  'string' != typeof t &&
                    (console.warn(
                      t + ' used as a key, but it is not a string.'
                    ),
                    (t = String(t))),
                  t
                );
              }
              function f() {
                if (
                  arguments.length &&
                  'function' == typeof arguments[arguments.length - 1]
                )
                  return arguments[arguments.length - 1];
              }
              var d = 'local-forage-detect-blob-support',
                l = void 0,
                h = {},
                p = Object.prototype.toString,
                y = 'readonly',
                v = 'readwrite';
              function x(t) {
                return 'boolean' == typeof l
                  ? i.resolve(l)
                  : (function (t) {
                      return new i(function (n) {
                        var e = t.transaction(d, v),
                          r = a(['']);
                        e.objectStore(d).put(r, 'key'),
                          (e.onabort = function (t) {
                            t.preventDefault(), t.stopPropagation(), n(!1);
                          }),
                          (e.oncomplete = function () {
                            var t = navigator.userAgent.match(/Chrome\/(\d+)/),
                              e = navigator.userAgent.match(/Edge\//);
                            n(e || !t || parseInt(t[1], 10) >= 43);
                          });
                      }).catch(function () {
                        return !1;
                      });
                    })(t).then(function (t) {
                      return (l = t);
                    });
              }
              function m(t) {
                var n = h[t.name],
                  e = {};
                (e.promise = new i(function (t, n) {
                  (e.resolve = t), (e.reject = n);
                })),
                  n.deferredOperations.push(e),
                  n.dbReady
                    ? (n.dbReady = n.dbReady.then(function () {
                        return e.promise;
                      }))
                    : (n.dbReady = e.promise);
              }
              function _(t) {
                var n = h[t.name].deferredOperations.pop();
                if (n) return n.resolve(), n.promise;
              }
              function b(t, n) {
                var e = h[t.name].deferredOperations.pop();
                if (e) return e.reject(n), e.promise;
              }
              function g(t, n) {
                return new i(function (e, r) {
                  if (
                    ((h[t.name] = h[t.name] || {
                      forages: [],
                      db: null,
                      dbReady: null,
                      deferredOperations: [],
                    }),
                    t.db)
                  ) {
                    if (!n) return e(t.db);
                    m(t), t.db.close();
                  }
                  var a = [t.name];
                  n && a.push(t.version);
                  var i = o.open.apply(o, a);
                  n &&
                    (i.onupgradeneeded = function (n) {
                      var e = i.result;
                      try {
                        e.createObjectStore(t.storeName),
                          n.oldVersion <= 1 && e.createObjectStore(d);
                      } catch (e) {
                        if ('ConstraintError' !== e.name) throw e;
                        console.warn(
                          'The database "' +
                            t.name +
                            '" has been upgraded from version ' +
                            n.oldVersion +
                            ' to version ' +
                            n.newVersion +
                            ', but the storage "' +
                            t.storeName +
                            '" already exists.'
                        );
                      }
                    }),
                    (i.onerror = function (t) {
                      t.preventDefault(), r(i.error);
                    }),
                    (i.onsuccess = function () {
                      e(i.result), _(t);
                    });
                });
              }
              function S(t) {
                return g(t, !1);
              }
              function w(t) {
                return g(t, !0);
              }
              function C(t, n) {
                if (!t.db) return !0;
                var e = !t.db.objectStoreNames.contains(t.storeName),
                  r = t.version < t.db.version,
                  o = t.version > t.db.version;
                if (
                  (r &&
                    (t.version !== n &&
                      console.warn(
                        'The database "' +
                          t.name +
                          '" can\'t be downgraded from version ' +
                          t.db.version +
                          ' to version ' +
                          t.version +
                          '.'
                      ),
                    (t.version = t.db.version)),
                  o || e)
                ) {
                  if (e) {
                    var a = t.db.version + 1;
                    a > t.version && (t.version = a);
                  }
                  return !0;
                }
                return !1;
              }
              function k(t) {
                return a(
                  [
                    (function (t) {
                      for (
                        var n = t.length,
                          e = new ArrayBuffer(n),
                          r = new Uint8Array(e),
                          o = 0;
                        o < n;
                        o++
                      )
                        r[o] = t.charCodeAt(o);
                      return e;
                    })(atob(t.data)),
                  ],
                  { type: t.type }
                );
              }
              function A(t) {
                return t && t.__local_forage_encoded_blob;
              }
              function E(t) {
                var n = this,
                  e = n._initReady().then(function () {
                    var t = h[n._dbInfo.name];
                    if (t && t.dbReady) return t.dbReady;
                  });
                return c(e, t, t), e;
              }
              function T(t, n, e, r) {
                void 0 === r && (r = 1);
                try {
                  var o = t.db.transaction(t.storeName, n);
                  e(null, o);
                } catch (o) {
                  if (
                    r > 0 &&
                    (!t.db ||
                      'InvalidStateError' === o.name ||
                      'NotFoundError' === o.name)
                  )
                    return i
                      .resolve()
                      .then(function () {
                        if (
                          !t.db ||
                          ('NotFoundError' === o.name &&
                            !t.db.objectStoreNames.contains(t.storeName) &&
                            t.version <= t.db.version)
                        )
                          return t.db && (t.version = t.db.version + 1), w(t);
                      })
                      .then(function () {
                        return (function (t) {
                          m(t);
                          for (
                            var n = h[t.name], e = n.forages, r = 0;
                            r < e.length;
                            r++
                          ) {
                            var o = e[r];
                            o._dbInfo.db &&
                              (o._dbInfo.db.close(), (o._dbInfo.db = null));
                          }
                          return (
                            (t.db = null),
                            S(t)
                              .then(function (n) {
                                return (t.db = n), C(t) ? w(t) : n;
                              })
                              .then(function (r) {
                                t.db = n.db = r;
                                for (var o = 0; o < e.length; o++)
                                  e[o]._dbInfo.db = r;
                              })
                              .catch(function (n) {
                                throw (b(t, n), n);
                              })
                          );
                        })(t).then(function () {
                          T(t, n, e, r - 1);
                        });
                      })
                      .catch(e);
                  e(o);
                }
              }
              var O = {
                  _driver: 'asyncStorage',
                  _initStorage: function (t) {
                    var n = this,
                      e = { db: null };
                    if (t) for (var r in t) e[r] = t[r];
                    var o = h[e.name];
                    o ||
                      ((o = {
                        forages: [],
                        db: null,
                        dbReady: null,
                        deferredOperations: [],
                      }),
                      (h[e.name] = o)),
                      o.forages.push(n),
                      n._initReady || ((n._initReady = n.ready), (n.ready = E));
                    var a = [];
                    function s() {
                      return i.resolve();
                    }
                    for (var c = 0; c < o.forages.length; c++) {
                      var u = o.forages[c];
                      u !== n && a.push(u._initReady().catch(s));
                    }
                    var f = o.forages.slice(0);
                    return i
                      .all(a)
                      .then(function () {
                        return (e.db = o.db), S(e);
                      })
                      .then(function (t) {
                        return (
                          (e.db = t), C(e, n._defaultConfig.version) ? w(e) : t
                        );
                      })
                      .then(function (t) {
                        (e.db = o.db = t), (n._dbInfo = e);
                        for (var r = 0; r < f.length; r++) {
                          var a = f[r];
                          a !== n &&
                            ((a._dbInfo.db = e.db),
                            (a._dbInfo.version = e.version));
                        }
                      });
                  },
                  _support: (function () {
                    try {
                      if (!o) return !1;
                      var t =
                          'undefined' != typeof openDatabase &&
                          /(Safari|iPhone|iPad|iPod)/.test(
                            navigator.userAgent
                          ) &&
                          !/Chrome/.test(navigator.userAgent) &&
                          !/BlackBerry/.test(navigator.platform),
                        n =
                          'function' == typeof fetch &&
                          -1 !== fetch.toString().indexOf('[native code');
                      return (
                        (!t || n) &&
                        'undefined' != typeof indexedDB &&
                        'undefined' != typeof IDBKeyRange
                      );
                    } catch (t) {
                      return !1;
                    }
                  })(),
                  iterate: function (t, n) {
                    var e = this,
                      r = new i(function (n, r) {
                        e.ready()
                          .then(function () {
                            T(e._dbInfo, y, function (o, a) {
                              if (o) return r(o);
                              try {
                                var i = a
                                    .objectStore(e._dbInfo.storeName)
                                    .openCursor(),
                                  s = 1;
                                (i.onsuccess = function () {
                                  var e = i.result;
                                  if (e) {
                                    var r = e.value;
                                    A(r) && (r = k(r));
                                    var o = t(r, e.key, s++);
                                    void 0 !== o ? n(o) : e.continue();
                                  } else n();
                                }),
                                  (i.onerror = function () {
                                    r(i.error);
                                  });
                              } catch (t) {
                                r(t);
                              }
                            });
                          })
                          .catch(r);
                      });
                    return s(r, n), r;
                  },
                  getItem: function (t, n) {
                    var e = this;
                    t = u(t);
                    var r = new i(function (n, r) {
                      e.ready()
                        .then(function () {
                          T(e._dbInfo, y, function (o, a) {
                            if (o) return r(o);
                            try {
                              var i = a.objectStore(e._dbInfo.storeName).get(t);
                              (i.onsuccess = function () {
                                var t = i.result;
                                void 0 === t && (t = null),
                                  A(t) && (t = k(t)),
                                  n(t);
                              }),
                                (i.onerror = function () {
                                  r(i.error);
                                });
                            } catch (t) {
                              r(t);
                            }
                          });
                        })
                        .catch(r);
                    });
                    return s(r, n), r;
                  },
                  setItem: function (t, n, e) {
                    var r = this;
                    t = u(t);
                    var o = new i(function (e, o) {
                      var a;
                      r.ready()
                        .then(function () {
                          return (
                            (a = r._dbInfo),
                            '[object Blob]' === p.call(n)
                              ? x(a.db).then(function (t) {
                                  return t
                                    ? n
                                    : ((e = n),
                                      new i(function (t, n) {
                                        var r = new FileReader();
                                        (r.onerror = n),
                                          (r.onloadend = function (n) {
                                            var r = btoa(n.target.result || '');
                                            t({
                                              __local_forage_encoded_blob: !0,
                                              data: r,
                                              type: e.type,
                                            });
                                          }),
                                          r.readAsBinaryString(e);
                                      }));
                                  var e;
                                })
                              : n
                          );
                        })
                        .then(function (n) {
                          T(r._dbInfo, v, function (a, i) {
                            if (a) return o(a);
                            try {
                              var s = i.objectStore(r._dbInfo.storeName);
                              null === n && (n = void 0);
                              var c = s.put(n, t);
                              (i.oncomplete = function () {
                                void 0 === n && (n = null), e(n);
                              }),
                                (i.onabort = i.onerror =
                                  function () {
                                    var t = c.error
                                      ? c.error
                                      : c.transaction.error;
                                    o(t);
                                  });
                            } catch (t) {
                              o(t);
                            }
                          });
                        })
                        .catch(o);
                    });
                    return s(o, e), o;
                  },
                  removeItem: function (t, n) {
                    var e = this;
                    t = u(t);
                    var r = new i(function (n, r) {
                      e.ready()
                        .then(function () {
                          T(e._dbInfo, v, function (o, a) {
                            if (o) return r(o);
                            try {
                              var i = a
                                .objectStore(e._dbInfo.storeName)
                                .delete(t);
                              (a.oncomplete = function () {
                                n();
                              }),
                                (a.onerror = function () {
                                  r(i.error);
                                }),
                                (a.onabort = function () {
                                  var t = i.error
                                    ? i.error
                                    : i.transaction.error;
                                  r(t);
                                });
                            } catch (t) {
                              r(t);
                            }
                          });
                        })
                        .catch(r);
                    });
                    return s(r, n), r;
                  },
                  clear: function (t) {
                    var n = this,
                      e = new i(function (t, e) {
                        n.ready()
                          .then(function () {
                            T(n._dbInfo, v, function (r, o) {
                              if (r) return e(r);
                              try {
                                var a = o
                                  .objectStore(n._dbInfo.storeName)
                                  .clear();
                                (o.oncomplete = function () {
                                  t();
                                }),
                                  (o.onabort = o.onerror =
                                    function () {
                                      var t = a.error
                                        ? a.error
                                        : a.transaction.error;
                                      e(t);
                                    });
                              } catch (t) {
                                e(t);
                              }
                            });
                          })
                          .catch(e);
                      });
                    return s(e, t), e;
                  },
                  length: function (t) {
                    var n = this,
                      e = new i(function (t, e) {
                        n.ready()
                          .then(function () {
                            T(n._dbInfo, y, function (r, o) {
                              if (r) return e(r);
                              try {
                                var a = o
                                  .objectStore(n._dbInfo.storeName)
                                  .count();
                                (a.onsuccess = function () {
                                  t(a.result);
                                }),
                                  (a.onerror = function () {
                                    e(a.error);
                                  });
                              } catch (t) {
                                e(t);
                              }
                            });
                          })
                          .catch(e);
                      });
                    return s(e, t), e;
                  },
                  key: function (t, n) {
                    var e = this,
                      r = new i(function (n, r) {
                        t < 0
                          ? n(null)
                          : e
                              .ready()
                              .then(function () {
                                T(e._dbInfo, y, function (o, a) {
                                  if (o) return r(o);
                                  try {
                                    var i = a.objectStore(e._dbInfo.storeName),
                                      s = !1,
                                      c = i.openCursor();
                                    (c.onsuccess = function () {
                                      var e = c.result;
                                      e
                                        ? 0 === t
                                          ? n(e.key)
                                          : s
                                          ? n(e.key)
                                          : ((s = !0), e.advance(t))
                                        : n(null);
                                    }),
                                      (c.onerror = function () {
                                        r(c.error);
                                      });
                                  } catch (t) {
                                    r(t);
                                  }
                                });
                              })
                              .catch(r);
                      });
                    return s(r, n), r;
                  },
                  keys: function (t) {
                    var n = this,
                      e = new i(function (t, e) {
                        n.ready()
                          .then(function () {
                            T(n._dbInfo, y, function (r, o) {
                              if (r) return e(r);
                              try {
                                var a = o
                                    .objectStore(n._dbInfo.storeName)
                                    .openCursor(),
                                  i = [];
                                (a.onsuccess = function () {
                                  var n = a.result;
                                  n ? (i.push(n.key), n.continue()) : t(i);
                                }),
                                  (a.onerror = function () {
                                    e(a.error);
                                  });
                              } catch (t) {
                                e(t);
                              }
                            });
                          })
                          .catch(e);
                      });
                    return s(e, t), e;
                  },
                  dropInstance: function (t, n) {
                    n = f.apply(this, arguments);
                    var e,
                      r = this.config();
                    if (
                      ((t = ('function' != typeof t && t) || {}).name ||
                        ((t.name = t.name || r.name),
                        (t.storeName = t.storeName || r.storeName)),
                      t.name)
                    ) {
                      var a =
                        t.name === r.name && this._dbInfo.db
                          ? i.resolve(this._dbInfo.db)
                          : S(t).then(function (n) {
                              var e = h[t.name],
                                r = e.forages;
                              e.db = n;
                              for (var o = 0; o < r.length; o++)
                                r[o]._dbInfo.db = n;
                              return n;
                            });
                      e = t.storeName
                        ? a.then(function (n) {
                            if (n.objectStoreNames.contains(t.storeName)) {
                              var e = n.version + 1;
                              m(t);
                              var r = h[t.name],
                                a = r.forages;
                              n.close();
                              for (var s = 0; s < a.length; s++) {
                                var c = a[s];
                                (c._dbInfo.db = null), (c._dbInfo.version = e);
                              }
                              return new i(function (n, r) {
                                var a = o.open(t.name, e);
                                (a.onerror = function (t) {
                                  a.result.close(), r(t);
                                }),
                                  (a.onupgradeneeded = function () {
                                    a.result.deleteObjectStore(t.storeName);
                                  }),
                                  (a.onsuccess = function () {
                                    var t = a.result;
                                    t.close(), n(t);
                                  });
                              })
                                .then(function (t) {
                                  r.db = t;
                                  for (var n = 0; n < a.length; n++) {
                                    var e = a[n];
                                    (e._dbInfo.db = t), _(e._dbInfo);
                                  }
                                })
                                .catch(function (n) {
                                  throw (
                                    ((b(t, n) || i.resolve()).catch(
                                      function () {}
                                    ),
                                    n)
                                  );
                                });
                            }
                          })
                        : a.then(function (n) {
                            m(t);
                            var e = h[t.name],
                              r = e.forages;
                            n.close();
                            for (var a = 0; a < r.length; a++)
                              r[a]._dbInfo.db = null;
                            return new i(function (n, e) {
                              var r = o.deleteDatabase(t.name);
                              (r.onerror = r.onblocked =
                                function (t) {
                                  var n = r.result;
                                  n && n.close(), e(t);
                                }),
                                (r.onsuccess = function () {
                                  var t = r.result;
                                  t && t.close(), n(t);
                                });
                            })
                              .then(function (t) {
                                e.db = t;
                                for (var n = 0; n < r.length; n++)
                                  _(r[n]._dbInfo);
                              })
                              .catch(function (n) {
                                throw (
                                  ((b(t, n) || i.resolve()).catch(
                                    function () {}
                                  ),
                                  n)
                                );
                              });
                          });
                    } else e = i.reject('Invalid arguments');
                    return s(e, n), e;
                  },
                },
                j =
                  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
                B = '~~local_forage_type~',
                R = /^~~local_forage_type~([^~]+)~/,
                I = '__lfsc__:',
                W = I.length,
                M = 'arbf',
                P = 'blob',
                H = 'si08',
                L = 'ui08',
                N = 'uic8',
                D = 'si16',
                F = 'si32',
                X = 'ur16',
                J = 'ui32',
                z = 'fl32',
                U = 'fl64',
                K = W + M.length,
                G = Object.prototype.toString;
              function q(t) {
                var n,
                  e,
                  r,
                  o,
                  a,
                  i = 0.75 * t.length,
                  s = t.length,
                  c = 0;
                '=' === t[t.length - 1] &&
                  (i--, '=' === t[t.length - 2] && i--);
                var u = new ArrayBuffer(i),
                  f = new Uint8Array(u);
                for (n = 0; n < s; n += 4)
                  (e = j.indexOf(t[n])),
                    (r = j.indexOf(t[n + 1])),
                    (o = j.indexOf(t[n + 2])),
                    (a = j.indexOf(t[n + 3])),
                    (f[c++] = (e << 2) | (r >> 4)),
                    (f[c++] = ((15 & r) << 4) | (o >> 2)),
                    (f[c++] = ((3 & o) << 6) | (63 & a));
                return u;
              }
              function V(t) {
                var n,
                  e = new Uint8Array(t),
                  r = '';
                for (n = 0; n < e.length; n += 3)
                  (r += j[e[n] >> 2]),
                    (r += j[((3 & e[n]) << 4) | (e[n + 1] >> 4)]),
                    (r += j[((15 & e[n + 1]) << 2) | (e[n + 2] >> 6)]),
                    (r += j[63 & e[n + 2]]);
                return (
                  e.length % 3 == 2
                    ? (r = r.substring(0, r.length - 1) + '=')
                    : e.length % 3 == 1 &&
                      (r = r.substring(0, r.length - 2) + '=='),
                  r
                );
              }
              var Y = {
                serialize: function (t, n) {
                  var e = '';
                  if (
                    (t && (e = G.call(t)),
                    t &&
                      ('[object ArrayBuffer]' === e ||
                        (t.buffer &&
                          '[object ArrayBuffer]' === G.call(t.buffer))))
                  ) {
                    var r,
                      o = I;
                    t instanceof ArrayBuffer
                      ? ((r = t), (o += M))
                      : ((r = t.buffer),
                        '[object Int8Array]' === e
                          ? (o += H)
                          : '[object Uint8Array]' === e
                          ? (o += L)
                          : '[object Uint8ClampedArray]' === e
                          ? (o += N)
                          : '[object Int16Array]' === e
                          ? (o += D)
                          : '[object Uint16Array]' === e
                          ? (o += X)
                          : '[object Int32Array]' === e
                          ? (o += F)
                          : '[object Uint32Array]' === e
                          ? (o += J)
                          : '[object Float32Array]' === e
                          ? (o += z)
                          : '[object Float64Array]' === e
                          ? (o += U)
                          : n(new Error('Failed to get type for BinaryArray'))),
                      n(o + V(r));
                  } else if ('[object Blob]' === e) {
                    var a = new FileReader();
                    (a.onload = function () {
                      var e = B + t.type + '~' + V(this.result);
                      n(I + P + e);
                    }),
                      a.readAsArrayBuffer(t);
                  } else
                    try {
                      n(JSON.stringify(t));
                    } catch (e) {
                      console.error(
                        "Couldn't convert value into a JSON string: ",
                        t
                      ),
                        n(null, e);
                    }
                },
                deserialize: function (t) {
                  if (t.substring(0, W) !== I) return JSON.parse(t);
                  var n,
                    e = t.substring(K),
                    r = t.substring(W, K);
                  if (r === P && R.test(e)) {
                    var o = e.match(R);
                    (n = o[1]), (e = e.substring(o[0].length));
                  }
                  var i = q(e);
                  switch (r) {
                    case M:
                      return i;
                    case P:
                      return a([i], { type: n });
                    case H:
                      return new Int8Array(i);
                    case L:
                      return new Uint8Array(i);
                    case N:
                      return new Uint8ClampedArray(i);
                    case D:
                      return new Int16Array(i);
                    case X:
                      return new Uint16Array(i);
                    case F:
                      return new Int32Array(i);
                    case J:
                      return new Uint32Array(i);
                    case z:
                      return new Float32Array(i);
                    case U:
                      return new Float64Array(i);
                    default:
                      throw new Error('Unkown type: ' + r);
                  }
                },
                stringToBuffer: q,
                bufferToString: V,
              };
              function $(t, n, e, r) {
                t.executeSql(
                  'CREATE TABLE IF NOT EXISTS ' +
                    n.storeName +
                    ' (id INTEGER PRIMARY KEY, key unique, value)',
                  [],
                  e,
                  r
                );
              }
              function Q(t, n, e, r, o, a) {
                t.executeSql(
                  e,
                  r,
                  o,
                  function (t, i) {
                    i.code === i.SYNTAX_ERR
                      ? t.executeSql(
                          "SELECT name FROM sqlite_master WHERE type='table' AND name = ?",
                          [n.storeName],
                          function (t, s) {
                            s.rows.length
                              ? a(t, i)
                              : $(
                                  t,
                                  n,
                                  function () {
                                    t.executeSql(e, r, o, a);
                                  },
                                  a
                                );
                          },
                          a
                        )
                      : a(t, i);
                  },
                  a
                );
              }
              function Z(t, n, e, r) {
                var o = this;
                t = u(t);
                var a = new i(function (a, i) {
                  o.ready()
                    .then(function () {
                      void 0 === n && (n = null);
                      var s = n,
                        c = o._dbInfo;
                      c.serializer.serialize(n, function (n, u) {
                        u
                          ? i(u)
                          : c.db.transaction(
                              function (e) {
                                Q(
                                  e,
                                  c,
                                  'INSERT OR REPLACE INTO ' +
                                    c.storeName +
                                    ' (key, value) VALUES (?, ?)',
                                  [t, n],
                                  function () {
                                    a(s);
                                  },
                                  function (t, n) {
                                    i(n);
                                  }
                                );
                              },
                              function (n) {
                                if (n.code === n.QUOTA_ERR) {
                                  if (r > 0)
                                    return void a(Z.apply(o, [t, s, e, r - 1]));
                                  i(n);
                                }
                              }
                            );
                      });
                    })
                    .catch(i);
                });
                return s(a, e), a;
              }
              var tt = {
                _driver: 'webSQLStorage',
                _initStorage: function (t) {
                  var n = this,
                    e = { db: null };
                  if (t)
                    for (var r in t)
                      e[r] = 'string' != typeof t[r] ? t[r].toString() : t[r];
                  var o = new i(function (t, r) {
                    try {
                      e.db = openDatabase(
                        e.name,
                        String(e.version),
                        e.description,
                        e.size
                      );
                    } catch (t) {
                      return r(t);
                    }
                    e.db.transaction(function (o) {
                      $(
                        o,
                        e,
                        function () {
                          (n._dbInfo = e), t();
                        },
                        function (t, n) {
                          r(n);
                        }
                      );
                    }, r);
                  });
                  return (e.serializer = Y), o;
                },
                _support: 'function' == typeof openDatabase,
                iterate: function (t, n) {
                  var e = this,
                    r = new i(function (n, r) {
                      e.ready()
                        .then(function () {
                          var o = e._dbInfo;
                          o.db.transaction(function (e) {
                            Q(
                              e,
                              o,
                              'SELECT * FROM ' + o.storeName,
                              [],
                              function (e, r) {
                                for (
                                  var a = r.rows, i = a.length, s = 0;
                                  s < i;
                                  s++
                                ) {
                                  var c = a.item(s),
                                    u = c.value;
                                  if (
                                    (u && (u = o.serializer.deserialize(u)),
                                    void 0 !== (u = t(u, c.key, s + 1)))
                                  )
                                    return void n(u);
                                }
                                n();
                              },
                              function (t, n) {
                                r(n);
                              }
                            );
                          });
                        })
                        .catch(r);
                    });
                  return s(r, n), r;
                },
                getItem: function (t, n) {
                  var e = this;
                  t = u(t);
                  var r = new i(function (n, r) {
                    e.ready()
                      .then(function () {
                        var o = e._dbInfo;
                        o.db.transaction(function (e) {
                          Q(
                            e,
                            o,
                            'SELECT * FROM ' +
                              o.storeName +
                              ' WHERE key = ? LIMIT 1',
                            [t],
                            function (t, e) {
                              var r = e.rows.length
                                ? e.rows.item(0).value
                                : null;
                              r && (r = o.serializer.deserialize(r)), n(r);
                            },
                            function (t, n) {
                              r(n);
                            }
                          );
                        });
                      })
                      .catch(r);
                  });
                  return s(r, n), r;
                },
                setItem: function (t, n, e) {
                  return Z.apply(this, [t, n, e, 1]);
                },
                removeItem: function (t, n) {
                  var e = this;
                  t = u(t);
                  var r = new i(function (n, r) {
                    e.ready()
                      .then(function () {
                        var o = e._dbInfo;
                        o.db.transaction(function (e) {
                          Q(
                            e,
                            o,
                            'DELETE FROM ' + o.storeName + ' WHERE key = ?',
                            [t],
                            function () {
                              n();
                            },
                            function (t, n) {
                              r(n);
                            }
                          );
                        });
                      })
                      .catch(r);
                  });
                  return s(r, n), r;
                },
                clear: function (t) {
                  var n = this,
                    e = new i(function (t, e) {
                      n.ready()
                        .then(function () {
                          var r = n._dbInfo;
                          r.db.transaction(function (n) {
                            Q(
                              n,
                              r,
                              'DELETE FROM ' + r.storeName,
                              [],
                              function () {
                                t();
                              },
                              function (t, n) {
                                e(n);
                              }
                            );
                          });
                        })
                        .catch(e);
                    });
                  return s(e, t), e;
                },
                length: function (t) {
                  var n = this,
                    e = new i(function (t, e) {
                      n.ready()
                        .then(function () {
                          var r = n._dbInfo;
                          r.db.transaction(function (n) {
                            Q(
                              n,
                              r,
                              'SELECT COUNT(key) as c FROM ' + r.storeName,
                              [],
                              function (n, e) {
                                var r = e.rows.item(0).c;
                                t(r);
                              },
                              function (t, n) {
                                e(n);
                              }
                            );
                          });
                        })
                        .catch(e);
                    });
                  return s(e, t), e;
                },
                key: function (t, n) {
                  var e = this,
                    r = new i(function (n, r) {
                      e.ready()
                        .then(function () {
                          var o = e._dbInfo;
                          o.db.transaction(function (e) {
                            Q(
                              e,
                              o,
                              'SELECT key FROM ' +
                                o.storeName +
                                ' WHERE id = ? LIMIT 1',
                              [t + 1],
                              function (t, e) {
                                var r = e.rows.length
                                  ? e.rows.item(0).key
                                  : null;
                                n(r);
                              },
                              function (t, n) {
                                r(n);
                              }
                            );
                          });
                        })
                        .catch(r);
                    });
                  return s(r, n), r;
                },
                keys: function (t) {
                  var n = this,
                    e = new i(function (t, e) {
                      n.ready()
                        .then(function () {
                          var r = n._dbInfo;
                          r.db.transaction(function (n) {
                            Q(
                              n,
                              r,
                              'SELECT key FROM ' + r.storeName,
                              [],
                              function (n, e) {
                                for (var r = [], o = 0; o < e.rows.length; o++)
                                  r.push(e.rows.item(o).key);
                                t(r);
                              },
                              function (t, n) {
                                e(n);
                              }
                            );
                          });
                        })
                        .catch(e);
                    });
                  return s(e, t), e;
                },
                dropInstance: function (t, n) {
                  n = f.apply(this, arguments);
                  var e = this.config();
                  (t = ('function' != typeof t && t) || {}).name ||
                    ((t.name = t.name || e.name),
                    (t.storeName = t.storeName || e.storeName));
                  var r,
                    o = this;
                  return (
                    s(
                      (r = t.name
                        ? new i(function (n) {
                            var r;
                            (r =
                              t.name === e.name
                                ? o._dbInfo.db
                                : openDatabase(t.name, '', '', 0)),
                              t.storeName
                                ? n({ db: r, storeNames: [t.storeName] })
                                : n(
                                    (function (t) {
                                      return new i(function (n, e) {
                                        t.transaction(
                                          function (r) {
                                            r.executeSql(
                                              "SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",
                                              [],
                                              function (e, r) {
                                                for (
                                                  var o = [], a = 0;
                                                  a < r.rows.length;
                                                  a++
                                                )
                                                  o.push(r.rows.item(a).name);
                                                n({ db: t, storeNames: o });
                                              },
                                              function (t, n) {
                                                e(n);
                                              }
                                            );
                                          },
                                          function (t) {
                                            e(t);
                                          }
                                        );
                                      });
                                    })(r)
                                  );
                          }).then(function (t) {
                            return new i(function (n, e) {
                              t.db.transaction(
                                function (r) {
                                  function o(t) {
                                    return new i(function (n, e) {
                                      r.executeSql(
                                        'DROP TABLE IF EXISTS ' + t,
                                        [],
                                        function () {
                                          n();
                                        },
                                        function (t, n) {
                                          e(n);
                                        }
                                      );
                                    });
                                  }
                                  for (
                                    var a = [], s = 0, c = t.storeNames.length;
                                    s < c;
                                    s++
                                  )
                                    a.push(o(t.storeNames[s]));
                                  i.all(a)
                                    .then(function () {
                                      n();
                                    })
                                    .catch(function (t) {
                                      e(t);
                                    });
                                },
                                function (t) {
                                  e(t);
                                }
                              );
                            });
                          })
                        : i.reject('Invalid arguments')),
                      n
                    ),
                    r
                  );
                },
              };
              function nt(t, n) {
                var e = t.name + '/';
                return (
                  t.storeName !== n.storeName && (e += t.storeName + '/'), e
                );
              }
              function et() {
                return (
                  !(function () {
                    try {
                      return (
                        localStorage.setItem('_localforage_support_test', !0),
                        localStorage.removeItem('_localforage_support_test'),
                        !1
                      );
                    } catch (t) {
                      return !0;
                    }
                  })() || localStorage.length > 0
                );
              }
              var rt = {
                  _driver: 'localStorageWrapper',
                  _initStorage: function (t) {
                    var n = {};
                    if (t) for (var e in t) n[e] = t[e];
                    return (
                      (n.keyPrefix = nt(t, this._defaultConfig)),
                      et()
                        ? ((this._dbInfo = n), (n.serializer = Y), i.resolve())
                        : i.reject()
                    );
                  },
                  _support: (function () {
                    try {
                      return (
                        'undefined' != typeof localStorage &&
                        'setItem' in localStorage &&
                        !!localStorage.setItem
                      );
                    } catch (t) {
                      return !1;
                    }
                  })(),
                  iterate: function (t, n) {
                    var e = this,
                      r = e.ready().then(function () {
                        for (
                          var n = e._dbInfo,
                            r = n.keyPrefix,
                            o = r.length,
                            a = localStorage.length,
                            i = 1,
                            s = 0;
                          s < a;
                          s++
                        ) {
                          var c = localStorage.key(s);
                          if (0 === c.indexOf(r)) {
                            var u = localStorage.getItem(c);
                            if (
                              (u && (u = n.serializer.deserialize(u)),
                              void 0 !== (u = t(u, c.substring(o), i++)))
                            )
                              return u;
                          }
                        }
                      });
                    return s(r, n), r;
                  },
                  getItem: function (t, n) {
                    var e = this;
                    t = u(t);
                    var r = e.ready().then(function () {
                      var n = e._dbInfo,
                        r = localStorage.getItem(n.keyPrefix + t);
                      return r && (r = n.serializer.deserialize(r)), r;
                    });
                    return s(r, n), r;
                  },
                  setItem: function (t, n, e) {
                    var r = this;
                    t = u(t);
                    var o = r.ready().then(function () {
                      void 0 === n && (n = null);
                      var e = n;
                      return new i(function (o, a) {
                        var i = r._dbInfo;
                        i.serializer.serialize(n, function (n, r) {
                          if (r) a(r);
                          else
                            try {
                              localStorage.setItem(i.keyPrefix + t, n), o(e);
                            } catch (t) {
                              ('QuotaExceededError' !== t.name &&
                                'NS_ERROR_DOM_QUOTA_REACHED' !== t.name) ||
                                a(t),
                                a(t);
                            }
                        });
                      });
                    });
                    return s(o, e), o;
                  },
                  removeItem: function (t, n) {
                    var e = this;
                    t = u(t);
                    var r = e.ready().then(function () {
                      var n = e._dbInfo;
                      localStorage.removeItem(n.keyPrefix + t);
                    });
                    return s(r, n), r;
                  },
                  clear: function (t) {
                    var n = this,
                      e = n.ready().then(function () {
                        for (
                          var t = n._dbInfo.keyPrefix,
                            e = localStorage.length - 1;
                          e >= 0;
                          e--
                        ) {
                          var r = localStorage.key(e);
                          0 === r.indexOf(t) && localStorage.removeItem(r);
                        }
                      });
                    return s(e, t), e;
                  },
                  length: function (t) {
                    var n = this.keys().then(function (t) {
                      return t.length;
                    });
                    return s(n, t), n;
                  },
                  key: function (t, n) {
                    var e = this,
                      r = e.ready().then(function () {
                        var n,
                          r = e._dbInfo;
                        try {
                          n = localStorage.key(t);
                        } catch (t) {
                          n = null;
                        }
                        return n && (n = n.substring(r.keyPrefix.length)), n;
                      });
                    return s(r, n), r;
                  },
                  keys: function (t) {
                    var n = this,
                      e = n.ready().then(function () {
                        for (
                          var t = n._dbInfo,
                            e = localStorage.length,
                            r = [],
                            o = 0;
                          o < e;
                          o++
                        ) {
                          var a = localStorage.key(o);
                          0 === a.indexOf(t.keyPrefix) &&
                            r.push(a.substring(t.keyPrefix.length));
                        }
                        return r;
                      });
                    return s(e, t), e;
                  },
                  dropInstance: function (t, n) {
                    if (
                      ((n = f.apply(this, arguments)),
                      !(t = ('function' != typeof t && t) || {}).name)
                    ) {
                      var e = this.config();
                      (t.name = t.name || e.name),
                        (t.storeName = t.storeName || e.storeName);
                    }
                    var r,
                      o = this;
                    return (
                      s(
                        (r = t.name
                          ? new i(function (n) {
                              t.storeName
                                ? n(nt(t, o._defaultConfig))
                                : n(t.name + '/');
                            }).then(function (t) {
                              for (
                                var n = localStorage.length - 1;
                                n >= 0;
                                n--
                              ) {
                                var e = localStorage.key(n);
                                0 === e.indexOf(t) &&
                                  localStorage.removeItem(e);
                              }
                            })
                          : i.reject('Invalid arguments')),
                        n
                      ),
                      r
                    );
                  },
                },
                ot = function (t, n) {
                  for (var e, r, o = t.length, a = 0; a < o; ) {
                    if (
                      (e = t[a]) === (r = n) ||
                      ('number' == typeof e &&
                        'number' == typeof r &&
                        isNaN(e) &&
                        isNaN(r))
                    )
                      return !0;
                    a++;
                  }
                  return !1;
                },
                at =
                  Array.isArray ||
                  function (t) {
                    return (
                      '[object Array]' === Object.prototype.toString.call(t)
                    );
                  },
                it = {},
                st = {},
                ct = { INDEXEDDB: O, WEBSQL: tt, LOCALSTORAGE: rt },
                ut = [
                  ct.INDEXEDDB._driver,
                  ct.WEBSQL._driver,
                  ct.LOCALSTORAGE._driver,
                ],
                ft = ['dropInstance'],
                dt = [
                  'clear',
                  'getItem',
                  'iterate',
                  'key',
                  'keys',
                  'length',
                  'removeItem',
                  'setItem',
                ].concat(ft),
                lt = {
                  description: '',
                  driver: ut.slice(),
                  name: 'localforage',
                  size: 4980736,
                  storeName: 'keyvaluepairs',
                  version: 1,
                };
              function ht(t, n) {
                t[n] = function () {
                  var e = arguments;
                  return t.ready().then(function () {
                    return t[n].apply(t, e);
                  });
                };
              }
              function pt() {
                for (var t = 1; t < arguments.length; t++) {
                  var n = arguments[t];
                  if (n)
                    for (var e in n)
                      n.hasOwnProperty(e) &&
                        (at(n[e])
                          ? (arguments[0][e] = n[e].slice())
                          : (arguments[0][e] = n[e]));
                }
                return arguments[0];
              }
              var yt = new ((function () {
                function t(n) {
                  for (var e in ((function (t, n) {
                    if (!(t instanceof n))
                      throw new TypeError('Cannot call a class as a function');
                  })(this, t),
                  ct))
                    if (ct.hasOwnProperty(e)) {
                      var r = ct[e],
                        o = r._driver;
                      (this[e] = o), it[o] || this.defineDriver(r);
                    }
                  (this._defaultConfig = pt({}, lt)),
                    (this._config = pt({}, this._defaultConfig, n)),
                    (this._driverSet = null),
                    (this._initDriver = null),
                    (this._ready = !1),
                    (this._dbInfo = null),
                    this._wrapLibraryMethodsWithReady(),
                    this.setDriver(this._config.driver).catch(function () {});
                }
                return (
                  (t.prototype.config = function (t) {
                    if ('object' === (void 0 === t ? 'undefined' : r(t))) {
                      if (this._ready)
                        return new Error(
                          "Can't call config() after localforage has been used."
                        );
                      for (var n in t) {
                        if (
                          ('storeName' === n &&
                            (t[n] = t[n].replace(/\W/g, '_')),
                          'version' === n && 'number' != typeof t[n])
                        )
                          return new Error(
                            'Database version must be a number.'
                          );
                        this._config[n] = t[n];
                      }
                      return (
                        !('driver' in t && t.driver) ||
                        this.setDriver(this._config.driver)
                      );
                    }
                    return 'string' == typeof t
                      ? this._config[t]
                      : this._config;
                  }),
                  (t.prototype.defineDriver = function (t, n, e) {
                    var r = new i(function (n, e) {
                      try {
                        var r = t._driver,
                          o = new Error(
                            'Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver'
                          );
                        if (!t._driver) return void e(o);
                        for (
                          var a = dt.concat('_initStorage'),
                            c = 0,
                            u = a.length;
                          c < u;
                          c++
                        ) {
                          var f = a[c];
                          if ((!ot(ft, f) || t[f]) && 'function' != typeof t[f])
                            return void e(o);
                        }
                        !(function () {
                          for (
                            var n = function (t) {
                                return function () {
                                  var n = new Error(
                                      'Method ' +
                                        t +
                                        ' is not implemented by the current driver'
                                    ),
                                    e = i.reject(n);
                                  return (
                                    s(e, arguments[arguments.length - 1]), e
                                  );
                                };
                              },
                              e = 0,
                              r = ft.length;
                            e < r;
                            e++
                          ) {
                            var o = ft[e];
                            t[o] || (t[o] = n(o));
                          }
                        })();
                        var d = function (e) {
                          it[r] &&
                            console.info('Redefining LocalForage driver: ' + r),
                            (it[r] = t),
                            (st[r] = e),
                            n();
                        };
                        '_support' in t
                          ? t._support && 'function' == typeof t._support
                            ? t._support().then(d, e)
                            : d(!!t._support)
                          : d(!0);
                      } catch (t) {
                        e(t);
                      }
                    });
                    return c(r, n, e), r;
                  }),
                  (t.prototype.driver = function () {
                    return this._driver || null;
                  }),
                  (t.prototype.getDriver = function (t, n, e) {
                    var r = it[t]
                      ? i.resolve(it[t])
                      : i.reject(new Error('Driver not found.'));
                    return c(r, n, e), r;
                  }),
                  (t.prototype.getSerializer = function (t) {
                    var n = i.resolve(Y);
                    return c(n, t), n;
                  }),
                  (t.prototype.ready = function (t) {
                    var n = this,
                      e = n._driverSet.then(function () {
                        return (
                          null === n._ready && (n._ready = n._initDriver()),
                          n._ready
                        );
                      });
                    return c(e, t, t), e;
                  }),
                  (t.prototype.setDriver = function (t, n, e) {
                    var r = this;
                    at(t) || (t = [t]);
                    var o = this._getSupportedDrivers(t);
                    function a() {
                      r._config.driver = r.driver();
                    }
                    function s(t) {
                      return (
                        r._extend(t),
                        a(),
                        (r._ready = r._initStorage(r._config)),
                        r._ready
                      );
                    }
                    var u =
                      null !== this._driverSet
                        ? this._driverSet.catch(function () {
                            return i.resolve();
                          })
                        : i.resolve();
                    return (
                      (this._driverSet = u
                        .then(function () {
                          var t = o[0];
                          return (
                            (r._dbInfo = null),
                            (r._ready = null),
                            r.getDriver(t).then(function (t) {
                              (r._driver = t._driver),
                                a(),
                                r._wrapLibraryMethodsWithReady(),
                                (r._initDriver = (function (t) {
                                  return function () {
                                    var n = 0;
                                    return (function e() {
                                      for (; n < t.length; ) {
                                        var o = t[n];
                                        return (
                                          n++,
                                          (r._dbInfo = null),
                                          (r._ready = null),
                                          r.getDriver(o).then(s).catch(e)
                                        );
                                      }
                                      a();
                                      var c = new Error(
                                        'No available storage method found.'
                                      );
                                      return (
                                        (r._driverSet = i.reject(c)),
                                        r._driverSet
                                      );
                                    })();
                                  };
                                })(o));
                            })
                          );
                        })
                        .catch(function () {
                          a();
                          var t = new Error(
                            'No available storage method found.'
                          );
                          return (r._driverSet = i.reject(t)), r._driverSet;
                        })),
                      c(this._driverSet, n, e),
                      this._driverSet
                    );
                  }),
                  (t.prototype.supports = function (t) {
                    return !!st[t];
                  }),
                  (t.prototype._extend = function (t) {
                    pt(this, t);
                  }),
                  (t.prototype._getSupportedDrivers = function (t) {
                    for (var n = [], e = 0, r = t.length; e < r; e++) {
                      var o = t[e];
                      this.supports(o) && n.push(o);
                    }
                    return n;
                  }),
                  (t.prototype._wrapLibraryMethodsWithReady = function () {
                    for (var t = 0, n = dt.length; t < n; t++) ht(this, dt[t]);
                  }),
                  (t.prototype.createInstance = function (n) {
                    return new t(n);
                  }),
                  t
                );
              })())();
              n.exports = yt;
            },
            { 3: 3 },
          ],
        },
        {},
        [4]
      )(4);
    },
    function (t, n) {
      var e = (t.exports = { version: '2.6.11' });
      'number' == typeof __e && (__e = e);
    },
    function (t, n) {
      var e = {}.hasOwnProperty;
      t.exports = function (t, n) {
        return e.call(t, n);
      };
    },
    function (t, n, e) {
      var r = e(7),
        o = e(28);
      t.exports = e(5)
        ? function (t, n, e) {
            return r.f(t, n, o(1, e));
          }
        : function (t, n, e) {
            return (t[n] = e), t;
          };
    },
    function (t, n, e) {
      var r = e(17);
      t.exports = function (t, n, e) {
        if ((r(t), void 0 === n)) return t;
        switch (e) {
          case 1:
            return function (e) {
              return t.call(n, e);
            };
          case 2:
            return function (e, r) {
              return t.call(n, e, r);
            };
          case 3:
            return function (e, r, o) {
              return t.call(n, e, r, o);
            };
        }
        return function () {
          return t.apply(n, arguments);
        };
      };
    },
    function (t, n) {
      t.exports = function (t) {
        if ('function' != typeof t) throw TypeError(t + ' is not a function!');
        return t;
      };
    },
    function (t, n, e) {
      var r = e(56),
        o = e(42);
      t.exports =
        Object.keys ||
        function (t) {
          return r(t, o);
        };
    },
    function (t, n, e) {
      var r = e(57),
        o = e(39);
      t.exports = function (t) {
        return r(o(t));
      };
    },
    function (module, exports, __webpack_require__) {
      var factory;
      'undefined' == typeof window ? global : window,
        (factory = function () {
          return (function (t) {
            var n = {};
            function e(r) {
              if (n[r]) return n[r].exports;
              var o = (n[r] = { i: r, l: !1, exports: {} });
              return (
                t[r].call(o.exports, o, o.exports, e), (o.l = !0), o.exports
              );
            }
            return (
              (e.m = t),
              (e.c = n),
              (e.d = function (t, n, r) {
                e.o(t, n) ||
                  Object.defineProperty(t, n, {
                    configurable: !1,
                    enumerable: !0,
                    get: r,
                  });
              }),
              (e.r = function (t) {
                Object.defineProperty(t, '__esModule', { value: !0 });
              }),
              (e.n = function (t) {
                var n =
                  t && t.__esModule
                    ? function () {
                        return t.default;
                      }
                    : function () {
                        return t;
                      };
                return e.d(n, 'a', n), n;
              }),
              (e.o = function (t, n) {
                return Object.prototype.hasOwnProperty.call(t, n);
              }),
              (e.p = ''),
              e((e.s = './src/index.js'))
            );
          })({
            './node_modules/crypto-js/aes.js':
              /*!***************************************!*\
        !*** ./node_modules/crypto-js/aes.js ***!
        \***************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar BlockCipher = C_lib.BlockCipher;\n\t\tvar C_algo = C.algo;\n\n\t\t// Lookup tables\n\t\tvar SBOX = [];\n\t\tvar INV_SBOX = [];\n\t\tvar SUB_MIX_0 = [];\n\t\tvar SUB_MIX_1 = [];\n\t\tvar SUB_MIX_2 = [];\n\t\tvar SUB_MIX_3 = [];\n\t\tvar INV_SUB_MIX_0 = [];\n\t\tvar INV_SUB_MIX_1 = [];\n\t\tvar INV_SUB_MIX_2 = [];\n\t\tvar INV_SUB_MIX_3 = [];\n\n\t\t// Compute lookup tables\n\t\t(function () {\n\t\t\t// Compute double table\n\t\t\tvar d = [];\n\t\t\tfor (var i = 0; i < 256; i++) {\n\t\t\t\tif (i < 128) {\n\t\t\t\t\td[i] = i << 1;\n\t\t\t\t} else {\n\t\t\t\t\td[i] = i << 1 ^ 0x11b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk GF(2^8)\n\t\t\tvar x = 0;\n\t\t\tvar xi = 0;\n\t\t\tfor (var i = 0; i < 256; i++) {\n\t\t\t\t// Compute sbox\n\t\t\t\tvar sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n\t\t\t\tsx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n\t\t\t\tSBOX[x] = sx;\n\t\t\t\tINV_SBOX[sx] = x;\n\n\t\t\t\t// Compute multiplication\n\t\t\t\tvar x2 = d[x];\n\t\t\t\tvar x4 = d[x2];\n\t\t\t\tvar x8 = d[x4];\n\n\t\t\t\t// Compute sub bytes, mix columns tables\n\t\t\t\tvar t = d[sx] * 0x101 ^ sx * 0x1010100;\n\t\t\t\tSUB_MIX_0[x] = t << 24 | t >>> 8;\n\t\t\t\tSUB_MIX_1[x] = t << 16 | t >>> 16;\n\t\t\t\tSUB_MIX_2[x] = t << 8 | t >>> 24;\n\t\t\t\tSUB_MIX_3[x] = t;\n\n\t\t\t\t// Compute inv sub bytes, inv mix columns tables\n\t\t\t\tvar t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n\t\t\t\tINV_SUB_MIX_0[sx] = t << 24 | t >>> 8;\n\t\t\t\tINV_SUB_MIX_1[sx] = t << 16 | t >>> 16;\n\t\t\t\tINV_SUB_MIX_2[sx] = t << 8 | t >>> 24;\n\t\t\t\tINV_SUB_MIX_3[sx] = t;\n\n\t\t\t\t// Compute next counter\n\t\t\t\tif (!x) {\n\t\t\t\t\tx = xi = 1;\n\t\t\t\t} else {\n\t\t\t\t\tx = x2 ^ d[d[d[x8 ^ x2]]];\n\t\t\t\t\txi ^= d[d[xi]];\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\n\t\t// Precomputed Rcon lookup\n\t\tvar RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n\t\t/**\n   * AES block cipher algorithm.\n   */\n\t\tvar AES = C_algo.AES = BlockCipher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\t// Skip reset of nRounds has been set before and key did not change\n\t\t\t\tif (this._nRounds && this._keyPriorReset === this._key) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar key = this._keyPriorReset = this._key;\n\t\t\t\tvar keyWords = key.words;\n\t\t\t\tvar keySize = key.sigBytes / 4;\n\n\t\t\t\t// Compute number of rounds\n\t\t\t\tvar nRounds = this._nRounds = keySize + 6;\n\n\t\t\t\t// Compute number of key schedule rows\n\t\t\t\tvar ksRows = (nRounds + 1) * 4;\n\n\t\t\t\t// Compute key schedule\n\t\t\t\tvar keySchedule = this._keySchedule = [];\n\t\t\t\tfor (var ksRow = 0; ksRow < ksRows; ksRow++) {\n\t\t\t\t\tif (ksRow < keySize) {\n\t\t\t\t\t\tkeySchedule[ksRow] = keyWords[ksRow];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar t = keySchedule[ksRow - 1];\n\n\t\t\t\t\t\tif (!(ksRow % keySize)) {\n\t\t\t\t\t\t\t// Rot word\n\t\t\t\t\t\t\tt = t << 8 | t >>> 24;\n\n\t\t\t\t\t\t\t// Sub word\n\t\t\t\t\t\t\tt = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff];\n\n\t\t\t\t\t\t\t// Mix Rcon\n\t\t\t\t\t\t\tt ^= RCON[ksRow / keySize | 0] << 24;\n\t\t\t\t\t\t} else if (keySize > 6 && ksRow % keySize == 4) {\n\t\t\t\t\t\t\t// Sub word\n\t\t\t\t\t\t\tt = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tkeySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Compute inv key schedule\n\t\t\t\tvar invKeySchedule = this._invKeySchedule = [];\n\t\t\t\tfor (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n\t\t\t\t\tvar ksRow = ksRows - invKsRow;\n\n\t\t\t\t\tif (invKsRow % 4) {\n\t\t\t\t\t\tvar t = keySchedule[ksRow];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar t = keySchedule[ksRow - 4];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (invKsRow < 4 || ksRow <= 4) {\n\t\t\t\t\t\tinvKeySchedule[invKsRow] = t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinvKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 0xff]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tencryptBlock: function (M, offset) {\n\t\t\t\tthis._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n\t\t\t},\n\n\t\t\tdecryptBlock: function (M, offset) {\n\t\t\t\t// Swap 2nd and 4th rows\n\t\t\t\tvar t = M[offset + 1];\n\t\t\t\tM[offset + 1] = M[offset + 3];\n\t\t\t\tM[offset + 3] = t;\n\n\t\t\t\tthis._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n\t\t\t\t// Inv swap 2nd and 4th rows\n\t\t\t\tvar t = M[offset + 1];\n\t\t\t\tM[offset + 1] = M[offset + 3];\n\t\t\t\tM[offset + 3] = t;\n\t\t\t},\n\n\t\t\t_doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar nRounds = this._nRounds;\n\n\t\t\t\t// Get input, add round key\n\t\t\t\tvar s0 = M[offset] ^ keySchedule[0];\n\t\t\t\tvar s1 = M[offset + 1] ^ keySchedule[1];\n\t\t\t\tvar s2 = M[offset + 2] ^ keySchedule[2];\n\t\t\t\tvar s3 = M[offset + 3] ^ keySchedule[3];\n\n\t\t\t\t// Key schedule row counter\n\t\t\t\tvar ksRow = 4;\n\n\t\t\t\t// Rounds\n\t\t\t\tfor (var round = 1; round < nRounds; round++) {\n\t\t\t\t\t// Shift rows, sub bytes, mix columns, add round key\n\t\t\t\t\tvar t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 0xff] ^ SUB_MIX_2[s2 >>> 8 & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];\n\t\t\t\t\tvar t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 0xff] ^ SUB_MIX_2[s3 >>> 8 & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];\n\t\t\t\t\tvar t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 0xff] ^ SUB_MIX_2[s0 >>> 8 & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];\n\t\t\t\t\tvar t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 0xff] ^ SUB_MIX_2[s1 >>> 8 & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];\n\n\t\t\t\t\t// Update state\n\t\t\t\t\ts0 = t0;\n\t\t\t\t\ts1 = t1;\n\t\t\t\t\ts2 = t2;\n\t\t\t\t\ts3 = t3;\n\t\t\t\t}\n\n\t\t\t\t// Shift rows, sub bytes, add round key\n\t\t\t\tvar t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n\t\t\t\tvar t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n\t\t\t\tvar t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n\t\t\t\tvar t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n\n\t\t\t\t// Set output\n\t\t\t\tM[offset] = t0;\n\t\t\t\tM[offset + 1] = t1;\n\t\t\t\tM[offset + 2] = t2;\n\t\t\t\tM[offset + 3] = t3;\n\t\t\t},\n\n\t\t\tkeySize: 256 / 32\n\t\t});\n\n\t\t/**\n   * Shortcut functions to the cipher\'s object interface.\n   *\n   * @example\n   *\n   *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n   *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n   */\n\t\tC.AES = BlockCipher._createHelper(AES);\n\t})();\n\n\treturn CryptoJS.AES;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/aes.js?'
                );
              },
            './node_modules/crypto-js/cipher-core.js':
              /*!***********************************************!*\
        !*** ./node_modules/crypto-js/cipher-core.js ***!
        \***********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * Cipher core components.\n  */\n\tCryptoJS.lib.Cipher || function (undefined) {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar Base = C_lib.Base;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t\tvar C_enc = C.enc;\n\t\tvar Utf8 = C_enc.Utf8;\n\t\tvar Base64 = C_enc.Base64;\n\t\tvar C_algo = C.algo;\n\t\tvar EvpKDF = C_algo.EvpKDF;\n\n\t\t/**\n   * Abstract base cipher template.\n   *\n   * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n   * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n   * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n   * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n   */\n\t\tvar Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t\t\t/**\n    * Configuration options.\n    *\n    * @property {WordArray} iv The IV to use for this operation.\n    */\n\t\t\tcfg: Base.extend(),\n\n\t\t\t/**\n    * Creates this cipher in encryption mode.\n    *\n    * @param {WordArray} key The key.\n    * @param {Object} cfg (Optional) The configuration options to use for this operation.\n    *\n    * @return {Cipher} A cipher instance.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n    */\n\t\t\tcreateEncryptor: function (key, cfg) {\n\t\t\t\treturn this.create(this._ENC_XFORM_MODE, key, cfg);\n\t\t\t},\n\n\t\t\t/**\n    * Creates this cipher in decryption mode.\n    *\n    * @param {WordArray} key The key.\n    * @param {Object} cfg (Optional) The configuration options to use for this operation.\n    *\n    * @return {Cipher} A cipher instance.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n    */\n\t\t\tcreateDecryptor: function (key, cfg) {\n\t\t\t\treturn this.create(this._DEC_XFORM_MODE, key, cfg);\n\t\t\t},\n\n\t\t\t/**\n    * Initializes a newly created cipher.\n    *\n    * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n    * @param {WordArray} key The key.\n    * @param {Object} cfg (Optional) The configuration options to use for this operation.\n    *\n    * @example\n    *\n    *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n    */\n\t\t\tinit: function (xformMode, key, cfg) {\n\t\t\t\t// Apply config defaults\n\t\t\t\tthis.cfg = this.cfg.extend(cfg);\n\n\t\t\t\t// Store transform mode and key\n\t\t\t\tthis._xformMode = xformMode;\n\t\t\t\tthis._key = key;\n\n\t\t\t\t// Set initial values\n\t\t\t\tthis.reset();\n\t\t\t},\n\n\t\t\t/**\n    * Resets this cipher to its initial state.\n    *\n    * @example\n    *\n    *     cipher.reset();\n    */\n\t\t\treset: function () {\n\t\t\t\t// Reset data buffer\n\t\t\t\tBufferedBlockAlgorithm.reset.call(this);\n\n\t\t\t\t// Perform concrete-cipher logic\n\t\t\t\tthis._doReset();\n\t\t\t},\n\n\t\t\t/**\n    * Adds data to be encrypted or decrypted.\n    *\n    * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n    *\n    * @return {WordArray} The data after processing.\n    *\n    * @example\n    *\n    *     var encrypted = cipher.process('data');\n    *     var encrypted = cipher.process(wordArray);\n    */\n\t\t\tprocess: function (dataUpdate) {\n\t\t\t\t// Append\n\t\t\t\tthis._append(dataUpdate);\n\n\t\t\t\t// Process available blocks\n\t\t\t\treturn this._process();\n\t\t\t},\n\n\t\t\t/**\n    * Finalizes the encryption or decryption process.\n    * Note that the finalize operation is effectively a destructive, read-once operation.\n    *\n    * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n    *\n    * @return {WordArray} The data after final processing.\n    *\n    * @example\n    *\n    *     var encrypted = cipher.finalize();\n    *     var encrypted = cipher.finalize('data');\n    *     var encrypted = cipher.finalize(wordArray);\n    */\n\t\t\tfinalize: function (dataUpdate) {\n\t\t\t\t// Final data update\n\t\t\t\tif (dataUpdate) {\n\t\t\t\t\tthis._append(dataUpdate);\n\t\t\t\t}\n\n\t\t\t\t// Perform concrete-cipher logic\n\t\t\t\tvar finalProcessedData = this._doFinalize();\n\n\t\t\t\treturn finalProcessedData;\n\t\t\t},\n\n\t\t\tkeySize: 128 / 32,\n\n\t\t\tivSize: 128 / 32,\n\n\t\t\t_ENC_XFORM_MODE: 1,\n\n\t\t\t_DEC_XFORM_MODE: 2,\n\n\t\t\t/**\n    * Creates shortcut functions to a cipher's object interface.\n    *\n    * @param {Cipher} cipher The cipher to create a helper for.\n    *\n    * @return {Object} An object with encrypt and decrypt shortcut functions.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n    */\n\t\t\t_createHelper: function () {\n\t\t\t\tfunction selectCipherStrategy(key) {\n\t\t\t\t\tif (typeof key == 'string') {\n\t\t\t\t\t\treturn PasswordBasedCipher;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn SerializableCipher;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn function (cipher) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tencrypt: function (message, key, cfg) {\n\t\t\t\t\t\t\treturn selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdecrypt: function (ciphertext, key, cfg) {\n\t\t\t\t\t\t\treturn selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}()\n\t\t});\n\n\t\t/**\n   * Abstract base stream cipher template.\n   *\n   * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n   */\n\t\tvar StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t\t\t_doFinalize: function () {\n\t\t\t\t// Process partial blocks\n\t\t\t\tvar finalProcessedBlocks = this._process(!!'flush');\n\n\t\t\t\treturn finalProcessedBlocks;\n\t\t\t},\n\n\t\t\tblockSize: 1\n\t\t});\n\n\t\t/**\n   * Mode namespace.\n   */\n\t\tvar C_mode = C.mode = {};\n\n\t\t/**\n   * Abstract base block cipher mode template.\n   */\n\t\tvar BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t\t\t/**\n    * Creates this mode for encryption.\n    *\n    * @param {Cipher} cipher A block cipher instance.\n    * @param {Array} iv The IV words.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n    */\n\t\t\tcreateEncryptor: function (cipher, iv) {\n\t\t\t\treturn this.Encryptor.create(cipher, iv);\n\t\t\t},\n\n\t\t\t/**\n    * Creates this mode for decryption.\n    *\n    * @param {Cipher} cipher A block cipher instance.\n    * @param {Array} iv The IV words.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n    */\n\t\t\tcreateDecryptor: function (cipher, iv) {\n\t\t\t\treturn this.Decryptor.create(cipher, iv);\n\t\t\t},\n\n\t\t\t/**\n    * Initializes a newly created mode.\n    *\n    * @param {Cipher} cipher A block cipher instance.\n    * @param {Array} iv The IV words.\n    *\n    * @example\n    *\n    *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n    */\n\t\t\tinit: function (cipher, iv) {\n\t\t\t\tthis._cipher = cipher;\n\t\t\t\tthis._iv = iv;\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Cipher Block Chaining mode.\n   */\n\t\tvar CBC = C_mode.CBC = function () {\n\t\t\t/**\n    * Abstract base CBC mode.\n    */\n\t\t\tvar CBC = BlockCipherMode.extend();\n\n\t\t\t/**\n    * CBC encryptor.\n    */\n\t\t\tCBC.Encryptor = CBC.extend({\n\t\t\t\t/**\n     * Processes the data block at offset.\n     *\n     * @param {Array} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n\t\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar cipher = this._cipher;\n\t\t\t\t\tvar blockSize = cipher.blockSize;\n\n\t\t\t\t\t// XOR and encrypt\n\t\t\t\t\txorBlock.call(this, words, offset, blockSize);\n\t\t\t\t\tcipher.encryptBlock(words, offset);\n\n\t\t\t\t\t// Remember this block to use with next block\n\t\t\t\t\tthis._prevBlock = words.slice(offset, offset + blockSize);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/**\n    * CBC decryptor.\n    */\n\t\t\tCBC.Decryptor = CBC.extend({\n\t\t\t\t/**\n     * Processes the data block at offset.\n     *\n     * @param {Array} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n\t\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar cipher = this._cipher;\n\t\t\t\t\tvar blockSize = cipher.blockSize;\n\n\t\t\t\t\t// Remember this block to use with next block\n\t\t\t\t\tvar thisBlock = words.slice(offset, offset + blockSize);\n\n\t\t\t\t\t// Decrypt and XOR\n\t\t\t\t\tcipher.decryptBlock(words, offset);\n\t\t\t\t\txorBlock.call(this, words, offset, blockSize);\n\n\t\t\t\t\t// This block becomes the previous block\n\t\t\t\t\tthis._prevBlock = thisBlock;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfunction xorBlock(words, offset, blockSize) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar iv = this._iv;\n\n\t\t\t\t// Choose mixing block\n\t\t\t\tif (iv) {\n\t\t\t\t\tvar block = iv;\n\n\t\t\t\t\t// Remove IV for subsequent blocks\n\t\t\t\t\tthis._iv = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tvar block = this._prevBlock;\n\t\t\t\t}\n\n\t\t\t\t// XOR blocks\n\t\t\t\tfor (var i = 0; i < blockSize; i++) {\n\t\t\t\t\twords[offset + i] ^= block[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn CBC;\n\t\t}();\n\n\t\t/**\n   * Padding namespace.\n   */\n\t\tvar C_pad = C.pad = {};\n\n\t\t/**\n   * PKCS #5/7 padding strategy.\n   */\n\t\tvar Pkcs7 = C_pad.Pkcs7 = {\n\t\t\t/**\n    * Pads data using the algorithm defined in PKCS #5/7.\n    *\n    * @param {WordArray} data The data to pad.\n    * @param {number} blockSize The multiple that the data should be padded to.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n    */\n\t\t\tpad: function (data, blockSize) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar blockSizeBytes = blockSize * 4;\n\n\t\t\t\t// Count padding bytes\n\t\t\t\tvar nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t\t\t\t// Create padding word\n\t\t\t\tvar paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;\n\n\t\t\t\t// Create padding\n\t\t\t\tvar paddingWords = [];\n\t\t\t\tfor (var i = 0; i < nPaddingBytes; i += 4) {\n\t\t\t\t\tpaddingWords.push(paddingWord);\n\t\t\t\t}\n\t\t\t\tvar padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t\t\t\t// Add padding\n\t\t\t\tdata.concat(padding);\n\t\t\t},\n\n\t\t\t/**\n    * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n    *\n    * @param {WordArray} data The data to unpad.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n    */\n\t\t\tunpad: function (data) {\n\t\t\t\t// Get number of padding bytes from last byte\n\t\t\t\tvar nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff;\n\n\t\t\t\t// Remove padding\n\t\t\t\tdata.sigBytes -= nPaddingBytes;\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Abstract base block cipher template.\n   *\n   * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n   */\n\t\tvar BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t\t\t/**\n    * Configuration options.\n    *\n    * @property {Mode} mode The block mode to use. Default: CBC\n    * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n    */\n\t\t\tcfg: Cipher.cfg.extend({\n\t\t\t\tmode: CBC,\n\t\t\t\tpadding: Pkcs7\n\t\t\t}),\n\n\t\t\treset: function () {\n\t\t\t\t// Reset cipher\n\t\t\t\tCipher.reset.call(this);\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar cfg = this.cfg;\n\t\t\t\tvar iv = cfg.iv;\n\t\t\t\tvar mode = cfg.mode;\n\n\t\t\t\t// Reset block mode\n\t\t\t\tif (this._xformMode == this._ENC_XFORM_MODE) {\n\t\t\t\t\tvar modeCreator = mode.createEncryptor;\n\t\t\t\t} else /* if (this._xformMode == this._DEC_XFORM_MODE) */{\n\t\t\t\t\t\tvar modeCreator = mode.createDecryptor;\n\t\t\t\t\t\t// Keep at least one block in the buffer for unpadding\n\t\t\t\t\t\tthis._minBufferSize = 1;\n\t\t\t\t\t}\n\n\t\t\t\tif (this._mode && this._mode.__creator == modeCreator) {\n\t\t\t\t\tthis._mode.init(this, iv && iv.words);\n\t\t\t\t} else {\n\t\t\t\t\tthis._mode = modeCreator.call(mode, this, iv && iv.words);\n\t\t\t\t\tthis._mode.__creator = modeCreator;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (words, offset) {\n\t\t\t\tthis._mode.processBlock(words, offset);\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\t// Shortcut\n\t\t\t\tvar padding = this.cfg.padding;\n\n\t\t\t\t// Finalize\n\t\t\t\tif (this._xformMode == this._ENC_XFORM_MODE) {\n\t\t\t\t\t// Pad data\n\t\t\t\t\tpadding.pad(this._data, this.blockSize);\n\n\t\t\t\t\t// Process final blocks\n\t\t\t\t\tvar finalProcessedBlocks = this._process(!!'flush');\n\t\t\t\t} else /* if (this._xformMode == this._DEC_XFORM_MODE) */{\n\t\t\t\t\t\t// Process final blocks\n\t\t\t\t\t\tvar finalProcessedBlocks = this._process(!!'flush');\n\n\t\t\t\t\t\t// Unpad data\n\t\t\t\t\t\tpadding.unpad(finalProcessedBlocks);\n\t\t\t\t\t}\n\n\t\t\t\treturn finalProcessedBlocks;\n\t\t\t},\n\n\t\t\tblockSize: 128 / 32\n\t\t});\n\n\t\t/**\n   * A collection of cipher parameters.\n   *\n   * @property {WordArray} ciphertext The raw ciphertext.\n   * @property {WordArray} key The key to this ciphertext.\n   * @property {WordArray} iv The IV used in the ciphering operation.\n   * @property {WordArray} salt The salt used with a key derivation function.\n   * @property {Cipher} algorithm The cipher algorithm.\n   * @property {Mode} mode The block mode used in the ciphering operation.\n   * @property {Padding} padding The padding scheme used in the ciphering operation.\n   * @property {number} blockSize The block size of the cipher.\n   * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n   */\n\t\tvar CipherParams = C_lib.CipherParams = Base.extend({\n\t\t\t/**\n    * Initializes a newly created cipher params object.\n    *\n    * @param {Object} cipherParams An object with any of the possible cipher parameters.\n    *\n    * @example\n    *\n    *     var cipherParams = CryptoJS.lib.CipherParams.create({\n    *         ciphertext: ciphertextWordArray,\n    *         key: keyWordArray,\n    *         iv: ivWordArray,\n    *         salt: saltWordArray,\n    *         algorithm: CryptoJS.algo.AES,\n    *         mode: CryptoJS.mode.CBC,\n    *         padding: CryptoJS.pad.PKCS7,\n    *         blockSize: 4,\n    *         formatter: CryptoJS.format.OpenSSL\n    *     });\n    */\n\t\t\tinit: function (cipherParams) {\n\t\t\t\tthis.mixIn(cipherParams);\n\t\t\t},\n\n\t\t\t/**\n    * Converts this cipher params object to a string.\n    *\n    * @param {Format} formatter (Optional) The formatting strategy to use.\n    *\n    * @return {string} The stringified cipher params.\n    *\n    * @throws Error If neither the formatter nor the default formatter is set.\n    *\n    * @example\n    *\n    *     var string = cipherParams + '';\n    *     var string = cipherParams.toString();\n    *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n    */\n\t\t\ttoString: function (formatter) {\n\t\t\t\treturn (formatter || this.formatter).stringify(this);\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Format namespace.\n   */\n\t\tvar C_format = C.format = {};\n\n\t\t/**\n   * OpenSSL formatting strategy.\n   */\n\t\tvar OpenSSLFormatter = C_format.OpenSSL = {\n\t\t\t/**\n    * Converts a cipher params object to an OpenSSL-compatible string.\n    *\n    * @param {CipherParams} cipherParams The cipher params object.\n    *\n    * @return {string} The OpenSSL-compatible string.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n    */\n\t\t\tstringify: function (cipherParams) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar ciphertext = cipherParams.ciphertext;\n\t\t\t\tvar salt = cipherParams.salt;\n\n\t\t\t\t// Format\n\t\t\t\tif (salt) {\n\t\t\t\t\tvar wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t\t\t\t} else {\n\t\t\t\t\tvar wordArray = ciphertext;\n\t\t\t\t}\n\n\t\t\t\treturn wordArray.toString(Base64);\n\t\t\t},\n\n\t\t\t/**\n    * Converts an OpenSSL-compatible string to a cipher params object.\n    *\n    * @param {string} openSSLStr The OpenSSL-compatible string.\n    *\n    * @return {CipherParams} The cipher params object.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n    */\n\t\t\tparse: function (openSSLStr) {\n\t\t\t\t// Parse base64\n\t\t\t\tvar ciphertext = Base64.parse(openSSLStr);\n\n\t\t\t\t// Shortcut\n\t\t\t\tvar ciphertextWords = ciphertext.words;\n\n\t\t\t\t// Test for salt\n\t\t\t\tif (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t\t\t\t\t// Extract salt\n\t\t\t\t\tvar salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t\t\t\t\t// Remove salt from ciphertext\n\t\t\t\t\tciphertextWords.splice(0, 4);\n\t\t\t\t\tciphertext.sigBytes -= 16;\n\t\t\t\t}\n\n\t\t\t\treturn CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n   */\n\t\tvar SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t\t\t/**\n    * Configuration options.\n    *\n    * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n    */\n\t\t\tcfg: Base.extend({\n\t\t\t\tformat: OpenSSLFormatter\n\t\t\t}),\n\n\t\t\t/**\n    * Encrypts a message.\n    *\n    * @param {Cipher} cipher The cipher algorithm to use.\n    * @param {WordArray|string} message The message to encrypt.\n    * @param {WordArray} key The key.\n    * @param {Object} cfg (Optional) The configuration options to use for this operation.\n    *\n    * @return {CipherParams} A cipher params object.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n    *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n    *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n    */\n\t\t\tencrypt: function (cipher, message, key, cfg) {\n\t\t\t\t// Apply config defaults\n\t\t\t\tcfg = this.cfg.extend(cfg);\n\n\t\t\t\t// Encrypt\n\t\t\t\tvar encryptor = cipher.createEncryptor(key, cfg);\n\t\t\t\tvar ciphertext = encryptor.finalize(message);\n\n\t\t\t\t// Shortcut\n\t\t\t\tvar cipherCfg = encryptor.cfg;\n\n\t\t\t\t// Create and return serializable cipher params\n\t\t\t\treturn CipherParams.create({\n\t\t\t\t\tciphertext: ciphertext,\n\t\t\t\t\tkey: key,\n\t\t\t\t\tiv: cipherCfg.iv,\n\t\t\t\t\talgorithm: cipher,\n\t\t\t\t\tmode: cipherCfg.mode,\n\t\t\t\t\tpadding: cipherCfg.padding,\n\t\t\t\t\tblockSize: cipher.blockSize,\n\t\t\t\t\tformatter: cfg.format\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t/**\n    * Decrypts serialized ciphertext.\n    *\n    * @param {Cipher} cipher The cipher algorithm to use.\n    * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n    * @param {WordArray} key The key.\n    * @param {Object} cfg (Optional) The configuration options to use for this operation.\n    *\n    * @return {WordArray} The plaintext.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n    *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n    */\n\t\t\tdecrypt: function (cipher, ciphertext, key, cfg) {\n\t\t\t\t// Apply config defaults\n\t\t\t\tcfg = this.cfg.extend(cfg);\n\n\t\t\t\t// Convert string to CipherParams\n\t\t\t\tciphertext = this._parse(ciphertext, cfg.format);\n\n\t\t\t\t// Decrypt\n\t\t\t\tvar plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t\t\t\treturn plaintext;\n\t\t\t},\n\n\t\t\t/**\n    * Converts serialized ciphertext to CipherParams,\n    * else assumed CipherParams already and returns ciphertext unchanged.\n    *\n    * @param {CipherParams|string} ciphertext The ciphertext.\n    * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n    *\n    * @return {CipherParams} The unserialized ciphertext.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n    */\n\t\t\t_parse: function (ciphertext, format) {\n\t\t\t\tif (typeof ciphertext == 'string') {\n\t\t\t\t\treturn format.parse(ciphertext, this);\n\t\t\t\t} else {\n\t\t\t\t\treturn ciphertext;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Key derivation function namespace.\n   */\n\t\tvar C_kdf = C.kdf = {};\n\n\t\t/**\n   * OpenSSL key derivation function.\n   */\n\t\tvar OpenSSLKdf = C_kdf.OpenSSL = {\n\t\t\t/**\n    * Derives a key and IV from a password.\n    *\n    * @param {string} password The password to derive from.\n    * @param {number} keySize The size in words of the key to generate.\n    * @param {number} ivSize The size in words of the IV to generate.\n    * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n    *\n    * @return {CipherParams} A cipher params object with the key, IV, and salt.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n    *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n    */\n\t\t\texecute: function (password, keySize, ivSize, salt) {\n\t\t\t\t// Generate random salt\n\t\t\t\tif (!salt) {\n\t\t\t\t\tsalt = WordArray.random(64 / 8);\n\t\t\t\t}\n\n\t\t\t\t// Derive key and IV\n\t\t\t\tvar key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\n\t\t\t\t// Separate key and IV\n\t\t\t\tvar iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t\t\t\tkey.sigBytes = keySize * 4;\n\n\t\t\t\t// Return params\n\t\t\t\treturn CipherParams.create({ key: key, iv: iv, salt: salt });\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * A serializable cipher wrapper that derives the key from a password,\n   * and returns ciphertext as a serializable cipher params object.\n   */\n\t\tvar PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t\t\t/**\n    * Configuration options.\n    *\n    * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n    */\n\t\t\tcfg: SerializableCipher.cfg.extend({\n\t\t\t\tkdf: OpenSSLKdf\n\t\t\t}),\n\n\t\t\t/**\n    * Encrypts a message using a password.\n    *\n    * @param {Cipher} cipher The cipher algorithm to use.\n    * @param {WordArray|string} message The message to encrypt.\n    * @param {string} password The password.\n    * @param {Object} cfg (Optional) The configuration options to use for this operation.\n    *\n    * @return {CipherParams} A cipher params object.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n    *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n    */\n\t\t\tencrypt: function (cipher, message, password, cfg) {\n\t\t\t\t// Apply config defaults\n\t\t\t\tcfg = this.cfg.extend(cfg);\n\n\t\t\t\t// Derive key and other params\n\t\t\t\tvar derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n\t\t\t\t// Add IV to config\n\t\t\t\tcfg.iv = derivedParams.iv;\n\n\t\t\t\t// Encrypt\n\t\t\t\tvar ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t\t\t\t// Mix in derived params\n\t\t\t\tciphertext.mixIn(derivedParams);\n\n\t\t\t\treturn ciphertext;\n\t\t\t},\n\n\t\t\t/**\n    * Decrypts serialized ciphertext using a password.\n    *\n    * @param {Cipher} cipher The cipher algorithm to use.\n    * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n    * @param {string} password The password.\n    * @param {Object} cfg (Optional) The configuration options to use for this operation.\n    *\n    * @return {WordArray} The plaintext.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n    *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n    */\n\t\t\tdecrypt: function (cipher, ciphertext, password, cfg) {\n\t\t\t\t// Apply config defaults\n\t\t\t\tcfg = this.cfg.extend(cfg);\n\n\t\t\t\t// Convert string to CipherParams\n\t\t\t\tciphertext = this._parse(ciphertext, cfg.format);\n\n\t\t\t\t// Derive key and other params\n\t\t\t\tvar derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n\t\t\t\t// Add IV to config\n\t\t\t\tcfg.iv = derivedParams.iv;\n\n\t\t\t\t// Decrypt\n\t\t\t\tvar plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t\t\t\treturn plaintext;\n\t\t\t}\n\t\t});\n\t}();\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/cipher-core.js?"
                );
              },
            './node_modules/crypto-js/core.js':
              /*!****************************************!*\
        !*** ./node_modules/crypto-js/core.js ***!
        \****************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t} else {}\n})(this, function () {\n\n\t/**\n  * CryptoJS core components.\n  */\n\tvar CryptoJS = CryptoJS || function (Math, undefined) {\n\t\t/*\n   * Local polyfil of Object.create\n   */\n\t\tvar create = Object.create || function () {\n\t\t\tfunction F() {};\n\n\t\t\treturn function (obj) {\n\t\t\t\tvar subtype;\n\n\t\t\t\tF.prototype = obj;\n\n\t\t\t\tsubtype = new F();\n\n\t\t\t\tF.prototype = null;\n\n\t\t\t\treturn subtype;\n\t\t\t};\n\t\t}();\n\n\t\t/**\n   * CryptoJS namespace.\n   */\n\t\tvar C = {};\n\n\t\t/**\n   * Library namespace.\n   */\n\t\tvar C_lib = C.lib = {};\n\n\t\t/**\n   * Base object for prototypal inheritance.\n   */\n\t\tvar Base = C_lib.Base = function () {\n\n\t\t\treturn {\n\t\t\t\t/**\n     * Creates a new object that inherits from this object.\n     *\n     * @param {Object} overrides Properties to copy into the new object.\n     *\n     * @return {Object} The new object.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var MyType = CryptoJS.lib.Base.extend({\n     *         field: 'value',\n     *\n     *         method: function () {\n     *         }\n     *     });\n     */\n\t\t\t\textend: function (overrides) {\n\t\t\t\t\t// Spawn\n\t\t\t\t\tvar subtype = create(this);\n\n\t\t\t\t\t// Augment\n\t\t\t\t\tif (overrides) {\n\t\t\t\t\t\tsubtype.mixIn(overrides);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create default initializer\n\t\t\t\t\tif (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t\t\t\t\t\tsubtype.init = function () {\n\t\t\t\t\t\t\tsubtype.$super.init.apply(this, arguments);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Initializer's prototype is the subtype object\n\t\t\t\t\tsubtype.init.prototype = subtype;\n\n\t\t\t\t\t// Reference supertype\n\t\t\t\t\tsubtype.$super = this;\n\n\t\t\t\t\treturn subtype;\n\t\t\t\t},\n\n\t\t\t\t/**\n     * Extends this object and runs the init method.\n     * Arguments to create() will be passed to init().\n     *\n     * @return {Object} The new object.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var instance = MyType.create();\n     */\n\t\t\t\tcreate: function () {\n\t\t\t\t\tvar instance = this.extend();\n\t\t\t\t\tinstance.init.apply(instance, arguments);\n\n\t\t\t\t\treturn instance;\n\t\t\t\t},\n\n\t\t\t\t/**\n     * Initializes a newly created object.\n     * Override this method to add some logic when your objects are created.\n     *\n     * @example\n     *\n     *     var MyType = CryptoJS.lib.Base.extend({\n     *         init: function () {\n     *             // ...\n     *         }\n     *     });\n     */\n\t\t\t\tinit: function () {},\n\n\t\t\t\t/**\n     * Copies properties into this object.\n     *\n     * @param {Object} properties The properties to mix in.\n     *\n     * @example\n     *\n     *     MyType.mixIn({\n     *         field: 'value'\n     *     });\n     */\n\t\t\t\tmixIn: function (properties) {\n\t\t\t\t\tfor (var propertyName in properties) {\n\t\t\t\t\t\tif (properties.hasOwnProperty(propertyName)) {\n\t\t\t\t\t\t\tthis[propertyName] = properties[propertyName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// IE won't copy toString using the loop above\n\t\t\t\t\tif (properties.hasOwnProperty('toString')) {\n\t\t\t\t\t\tthis.toString = properties.toString;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t/**\n     * Creates a copy of this object.\n     *\n     * @return {Object} The clone.\n     *\n     * @example\n     *\n     *     var clone = instance.clone();\n     */\n\t\t\t\tclone: function () {\n\t\t\t\t\treturn this.init.prototype.extend(this);\n\t\t\t\t}\n\t\t\t};\n\t\t}();\n\n\t\t/**\n   * An array of 32-bit words.\n   *\n   * @property {Array} words The array of 32-bit words.\n   * @property {number} sigBytes The number of significant bytes in this word array.\n   */\n\t\tvar WordArray = C_lib.WordArray = Base.extend({\n\t\t\t/**\n    * Initializes a newly created word array.\n    *\n    * @param {Array} words (Optional) An array of 32-bit words.\n    * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.lib.WordArray.create();\n    *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n    *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n    */\n\t\t\tinit: function (words, sigBytes) {\n\t\t\t\twords = this.words = words || [];\n\n\t\t\t\tif (sigBytes != undefined) {\n\t\t\t\t\tthis.sigBytes = sigBytes;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sigBytes = words.length * 4;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n    * Converts this word array to a string.\n    *\n    * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n    *\n    * @return {string} The stringified word array.\n    *\n    * @example\n    *\n    *     var string = wordArray + '';\n    *     var string = wordArray.toString();\n    *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n    */\n\t\t\ttoString: function (encoder) {\n\t\t\t\treturn (encoder || Hex).stringify(this);\n\t\t\t},\n\n\t\t\t/**\n    * Concatenates a word array to this word array.\n    *\n    * @param {WordArray} wordArray The word array to append.\n    *\n    * @return {WordArray} This word array.\n    *\n    * @example\n    *\n    *     wordArray1.concat(wordArray2);\n    */\n\t\t\tconcat: function (wordArray) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar thisWords = this.words;\n\t\t\t\tvar thatWords = wordArray.words;\n\t\t\t\tvar thisSigBytes = this.sigBytes;\n\t\t\t\tvar thatSigBytes = wordArray.sigBytes;\n\n\t\t\t\t// Clamp excess bits\n\t\t\t\tthis.clamp();\n\n\t\t\t\t// Concat\n\t\t\t\tif (thisSigBytes % 4) {\n\t\t\t\t\t// Copy one byte at a time\n\t\t\t\t\tfor (var i = 0; i < thatSigBytes; i++) {\n\t\t\t\t\t\tvar thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n\t\t\t\t\t\tthisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Copy one word at a time\n\t\t\t\t\tfor (var i = 0; i < thatSigBytes; i += 4) {\n\t\t\t\t\t\tthisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.sigBytes += thatSigBytes;\n\n\t\t\t\t// Chainable\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t/**\n    * Removes insignificant bits.\n    *\n    * @example\n    *\n    *     wordArray.clamp();\n    */\n\t\t\tclamp: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar words = this.words;\n\t\t\t\tvar sigBytes = this.sigBytes;\n\n\t\t\t\t// Clamp\n\t\t\t\twords[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;\n\t\t\t\twords.length = Math.ceil(sigBytes / 4);\n\t\t\t},\n\n\t\t\t/**\n    * Creates a copy of this word array.\n    *\n    * @return {WordArray} The clone.\n    *\n    * @example\n    *\n    *     var clone = wordArray.clone();\n    */\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Base.clone.call(this);\n\t\t\t\tclone.words = this.words.slice(0);\n\n\t\t\t\treturn clone;\n\t\t\t},\n\n\t\t\t/**\n    * Creates a word array filled with random bytes.\n    *\n    * @param {number} nBytes The number of random bytes to generate.\n    *\n    * @return {WordArray} The random word array.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.lib.WordArray.random(16);\n    */\n\t\t\trandom: function (nBytes) {\n\t\t\t\tvar words = [];\n\n\t\t\t\tvar r = function (m_w) {\n\t\t\t\t\tvar m_w = m_w;\n\t\t\t\t\tvar m_z = 0x3ade68b1;\n\t\t\t\t\tvar mask = 0xffffffff;\n\n\t\t\t\t\treturn function () {\n\t\t\t\t\t\tm_z = 0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10) & mask;\n\t\t\t\t\t\tm_w = 0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10) & mask;\n\t\t\t\t\t\tvar result = (m_z << 0x10) + m_w & mask;\n\t\t\t\t\t\tresult /= 0x100000000;\n\t\t\t\t\t\tresult += 0.5;\n\t\t\t\t\t\treturn result * (Math.random() > .5 ? 1 : -1);\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\tfor (var i = 0, rcache; i < nBytes; i += 4) {\n\t\t\t\t\tvar _r = r((rcache || Math.random()) * 0x100000000);\n\n\t\t\t\t\trcache = _r() * 0x3ade67b7;\n\t\t\t\t\twords.push(_r() * 0x100000000 | 0);\n\t\t\t\t}\n\n\t\t\t\treturn new WordArray.init(words, nBytes);\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Encoder namespace.\n   */\n\t\tvar C_enc = C.enc = {};\n\n\t\t/**\n   * Hex encoding strategy.\n   */\n\t\tvar Hex = C_enc.Hex = {\n\t\t\t/**\n    * Converts a word array to a hex string.\n    *\n    * @param {WordArray} wordArray The word array.\n    *\n    * @return {string} The hex string.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n    */\n\t\t\tstringify: function (wordArray) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar words = wordArray.words;\n\t\t\t\tvar sigBytes = wordArray.sigBytes;\n\n\t\t\t\t// Convert\n\t\t\t\tvar hexChars = [];\n\t\t\t\tfor (var i = 0; i < sigBytes; i++) {\n\t\t\t\t\tvar bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n\t\t\t\t\thexChars.push((bite >>> 4).toString(16));\n\t\t\t\t\thexChars.push((bite & 0x0f).toString(16));\n\t\t\t\t}\n\n\t\t\t\treturn hexChars.join('');\n\t\t\t},\n\n\t\t\t/**\n    * Converts a hex string to a word array.\n    *\n    * @param {string} hexStr The hex string.\n    *\n    * @return {WordArray} The word array.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n    */\n\t\t\tparse: function (hexStr) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar hexStrLength = hexStr.length;\n\n\t\t\t\t// Convert\n\t\t\t\tvar words = [];\n\t\t\t\tfor (var i = 0; i < hexStrLength; i += 2) {\n\t\t\t\t\twords[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;\n\t\t\t\t}\n\n\t\t\t\treturn new WordArray.init(words, hexStrLength / 2);\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Latin1 encoding strategy.\n   */\n\t\tvar Latin1 = C_enc.Latin1 = {\n\t\t\t/**\n    * Converts a word array to a Latin1 string.\n    *\n    * @param {WordArray} wordArray The word array.\n    *\n    * @return {string} The Latin1 string.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n    */\n\t\t\tstringify: function (wordArray) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar words = wordArray.words;\n\t\t\t\tvar sigBytes = wordArray.sigBytes;\n\n\t\t\t\t// Convert\n\t\t\t\tvar latin1Chars = [];\n\t\t\t\tfor (var i = 0; i < sigBytes; i++) {\n\t\t\t\t\tvar bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n\t\t\t\t\tlatin1Chars.push(String.fromCharCode(bite));\n\t\t\t\t}\n\n\t\t\t\treturn latin1Chars.join('');\n\t\t\t},\n\n\t\t\t/**\n    * Converts a Latin1 string to a word array.\n    *\n    * @param {string} latin1Str The Latin1 string.\n    *\n    * @return {WordArray} The word array.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n    */\n\t\t\tparse: function (latin1Str) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar latin1StrLength = latin1Str.length;\n\n\t\t\t\t// Convert\n\t\t\t\tvar words = [];\n\t\t\t\tfor (var i = 0; i < latin1StrLength; i++) {\n\t\t\t\t\twords[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;\n\t\t\t\t}\n\n\t\t\t\treturn new WordArray.init(words, latin1StrLength);\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * UTF-8 encoding strategy.\n   */\n\t\tvar Utf8 = C_enc.Utf8 = {\n\t\t\t/**\n    * Converts a word array to a UTF-8 string.\n    *\n    * @param {WordArray} wordArray The word array.\n    *\n    * @return {string} The UTF-8 string.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n    */\n\t\t\tstringify: function (wordArray) {\n\t\t\t\ttry {\n\t\t\t\t\treturn decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow new Error('Malformed UTF-8 data');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n    * Converts a UTF-8 string to a word array.\n    *\n    * @param {string} utf8Str The UTF-8 string.\n    *\n    * @return {WordArray} The word array.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n    */\n\t\t\tparse: function (utf8Str) {\n\t\t\t\treturn Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Abstract buffered block algorithm template.\n   *\n   * The property blockSize must be implemented in a concrete subtype.\n   *\n   * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n   */\n\t\tvar BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t\t\t/**\n    * Resets this block algorithm's data buffer to its initial state.\n    *\n    * @example\n    *\n    *     bufferedBlockAlgorithm.reset();\n    */\n\t\t\treset: function () {\n\t\t\t\t// Initial values\n\t\t\t\tthis._data = new WordArray.init();\n\t\t\t\tthis._nDataBytes = 0;\n\t\t\t},\n\n\t\t\t/**\n    * Adds new data to this block algorithm's buffer.\n    *\n    * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n    *\n    * @example\n    *\n    *     bufferedBlockAlgorithm._append('data');\n    *     bufferedBlockAlgorithm._append(wordArray);\n    */\n\t\t\t_append: function (data) {\n\t\t\t\t// Convert string to WordArray, else assume WordArray already\n\t\t\t\tif (typeof data == 'string') {\n\t\t\t\t\tdata = Utf8.parse(data);\n\t\t\t\t}\n\n\t\t\t\t// Append\n\t\t\t\tthis._data.concat(data);\n\t\t\t\tthis._nDataBytes += data.sigBytes;\n\t\t\t},\n\n\t\t\t/**\n    * Processes available data blocks.\n    *\n    * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n    *\n    * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n    *\n    * @return {WordArray} The processed data.\n    *\n    * @example\n    *\n    *     var processedData = bufferedBlockAlgorithm._process();\n    *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n    */\n\t\t\t_process: function (doFlush) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar data = this._data;\n\t\t\t\tvar dataWords = data.words;\n\t\t\t\tvar dataSigBytes = data.sigBytes;\n\t\t\t\tvar blockSize = this.blockSize;\n\t\t\t\tvar blockSizeBytes = blockSize * 4;\n\n\t\t\t\t// Count blocks ready\n\t\t\t\tvar nBlocksReady = dataSigBytes / blockSizeBytes;\n\t\t\t\tif (doFlush) {\n\t\t\t\t\t// Round up to include partial blocks\n\t\t\t\t\tnBlocksReady = Math.ceil(nBlocksReady);\n\t\t\t\t} else {\n\t\t\t\t\t// Round down to include only full blocks,\n\t\t\t\t\t// less the number of blocks that must remain in the buffer\n\t\t\t\t\tnBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t\t\t\t}\n\n\t\t\t\t// Count words ready\n\t\t\t\tvar nWordsReady = nBlocksReady * blockSize;\n\n\t\t\t\t// Count bytes ready\n\t\t\t\tvar nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t\t\t\t// Process blocks\n\t\t\t\tif (nWordsReady) {\n\t\t\t\t\tfor (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t\t\t\t\t\t// Perform concrete-algorithm logic\n\t\t\t\t\t\tthis._doProcessBlock(dataWords, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove processed words\n\t\t\t\t\tvar processedWords = dataWords.splice(0, nWordsReady);\n\t\t\t\t\tdata.sigBytes -= nBytesReady;\n\t\t\t\t}\n\n\t\t\t\t// Return processed words\n\t\t\t\treturn new WordArray.init(processedWords, nBytesReady);\n\t\t\t},\n\n\t\t\t/**\n    * Creates a copy of this object.\n    *\n    * @return {Object} The clone.\n    *\n    * @example\n    *\n    *     var clone = bufferedBlockAlgorithm.clone();\n    */\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Base.clone.call(this);\n\t\t\t\tclone._data = this._data.clone();\n\n\t\t\t\treturn clone;\n\t\t\t},\n\n\t\t\t_minBufferSize: 0\n\t\t});\n\n\t\t/**\n   * Abstract hasher template.\n   *\n   * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n   */\n\t\tvar Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t\t\t/**\n    * Configuration options.\n    */\n\t\t\tcfg: Base.extend(),\n\n\t\t\t/**\n    * Initializes a newly created hasher.\n    *\n    * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n    *\n    * @example\n    *\n    *     var hasher = CryptoJS.algo.SHA256.create();\n    */\n\t\t\tinit: function (cfg) {\n\t\t\t\t// Apply config defaults\n\t\t\t\tthis.cfg = this.cfg.extend(cfg);\n\n\t\t\t\t// Set initial values\n\t\t\t\tthis.reset();\n\t\t\t},\n\n\t\t\t/**\n    * Resets this hasher to its initial state.\n    *\n    * @example\n    *\n    *     hasher.reset();\n    */\n\t\t\treset: function () {\n\t\t\t\t// Reset data buffer\n\t\t\t\tBufferedBlockAlgorithm.reset.call(this);\n\n\t\t\t\t// Perform concrete-hasher logic\n\t\t\t\tthis._doReset();\n\t\t\t},\n\n\t\t\t/**\n    * Updates this hasher with a message.\n    *\n    * @param {WordArray|string} messageUpdate The message to append.\n    *\n    * @return {Hasher} This hasher.\n    *\n    * @example\n    *\n    *     hasher.update('message');\n    *     hasher.update(wordArray);\n    */\n\t\t\tupdate: function (messageUpdate) {\n\t\t\t\t// Append\n\t\t\t\tthis._append(messageUpdate);\n\n\t\t\t\t// Update the hash\n\t\t\t\tthis._process();\n\n\t\t\t\t// Chainable\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t/**\n    * Finalizes the hash computation.\n    * Note that the finalize operation is effectively a destructive, read-once operation.\n    *\n    * @param {WordArray|string} messageUpdate (Optional) A final message update.\n    *\n    * @return {WordArray} The hash.\n    *\n    * @example\n    *\n    *     var hash = hasher.finalize();\n    *     var hash = hasher.finalize('message');\n    *     var hash = hasher.finalize(wordArray);\n    */\n\t\t\tfinalize: function (messageUpdate) {\n\t\t\t\t// Final message update\n\t\t\t\tif (messageUpdate) {\n\t\t\t\t\tthis._append(messageUpdate);\n\t\t\t\t}\n\n\t\t\t\t// Perform concrete-hasher logic\n\t\t\t\tvar hash = this._doFinalize();\n\n\t\t\t\treturn hash;\n\t\t\t},\n\n\t\t\tblockSize: 512 / 32,\n\n\t\t\t/**\n    * Creates a shortcut function to a hasher's object interface.\n    *\n    * @param {Hasher} hasher The hasher to create a helper for.\n    *\n    * @return {Function} The shortcut function.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n    */\n\t\t\t_createHelper: function (hasher) {\n\t\t\t\treturn function (message, cfg) {\n\t\t\t\t\treturn new hasher.init(cfg).finalize(message);\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t/**\n    * Creates a shortcut function to the HMAC's object interface.\n    *\n    * @param {Hasher} hasher The hasher to use in this HMAC helper.\n    *\n    * @return {Function} The shortcut function.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n    */\n\t\t\t_createHmacHelper: function (hasher) {\n\t\t\t\treturn function (message, key) {\n\t\t\t\t\treturn new C_algo.HMAC.init(hasher, key).finalize(message);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Algorithm namespace.\n   */\n\t\tvar C_algo = C.algo = {};\n\n\t\treturn C;\n\t}(Math);\n\n\treturn CryptoJS;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/core.js?"
                );
              },
            './node_modules/crypto-js/enc-base64.js':
              /*!**********************************************!*\
        !*** ./node_modules/crypto-js/enc-base64.js ***!
        \**********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar C_enc = C.enc;\n\n\t\t/**\n   * Base64 encoding strategy.\n   */\n\t\tvar Base64 = C_enc.Base64 = {\n\t\t\t/**\n    * Converts a word array to a Base64 string.\n    *\n    * @param {WordArray} wordArray The word array.\n    *\n    * @return {string} The Base64 string.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n    */\n\t\t\tstringify: function (wordArray) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar words = wordArray.words;\n\t\t\t\tvar sigBytes = wordArray.sigBytes;\n\t\t\t\tvar map = this._map;\n\n\t\t\t\t// Clamp excess bits\n\t\t\t\twordArray.clamp();\n\n\t\t\t\t// Convert\n\t\t\t\tvar base64Chars = [];\n\t\t\t\tfor (var i = 0; i < sigBytes; i += 3) {\n\t\t\t\t\tvar byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n\t\t\t\t\tvar byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;\n\t\t\t\t\tvar byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;\n\n\t\t\t\t\tvar triplet = byte1 << 16 | byte2 << 8 | byte3;\n\n\t\t\t\t\tfor (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {\n\t\t\t\t\t\tbase64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add padding\n\t\t\t\tvar paddingChar = map.charAt(64);\n\t\t\t\tif (paddingChar) {\n\t\t\t\t\twhile (base64Chars.length % 4) {\n\t\t\t\t\t\tbase64Chars.push(paddingChar);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn base64Chars.join('');\n\t\t\t},\n\n\t\t\t/**\n    * Converts a Base64 string to a word array.\n    *\n    * @param {string} base64Str The Base64 string.\n    *\n    * @return {WordArray} The word array.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n    */\n\t\t\tparse: function (base64Str) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar base64StrLength = base64Str.length;\n\t\t\t\tvar map = this._map;\n\t\t\t\tvar reverseMap = this._reverseMap;\n\n\t\t\t\tif (!reverseMap) {\n\t\t\t\t\treverseMap = this._reverseMap = [];\n\t\t\t\t\tfor (var j = 0; j < map.length; j++) {\n\t\t\t\t\t\treverseMap[map.charCodeAt(j)] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Ignore padding\n\t\t\t\tvar paddingChar = map.charAt(64);\n\t\t\t\tif (paddingChar) {\n\t\t\t\t\tvar paddingIndex = base64Str.indexOf(paddingChar);\n\t\t\t\t\tif (paddingIndex !== -1) {\n\t\t\t\t\t\tbase64StrLength = paddingIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Convert\n\t\t\t\treturn parseLoop(base64Str, base64StrLength, reverseMap);\n\t\t\t},\n\n\t\t\t_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t\t};\n\n\t\tfunction parseLoop(base64Str, base64StrLength, reverseMap) {\n\t\t\tvar words = [];\n\t\t\tvar nBytes = 0;\n\t\t\tfor (var i = 0; i < base64StrLength; i++) {\n\t\t\t\tif (i % 4) {\n\t\t\t\t\tvar bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;\n\t\t\t\t\tvar bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;\n\t\t\t\t\twords[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;\n\t\t\t\t\tnBytes++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn WordArray.create(words, nBytes);\n\t\t}\n\t})();\n\n\treturn CryptoJS.enc.Base64;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/enc-base64.js?"
                );
              },
            './node_modules/crypto-js/enc-utf16.js':
              /*!*********************************************!*\
        !*** ./node_modules/crypto-js/enc-utf16.js ***!
        \*********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar C_enc = C.enc;\n\n\t\t/**\n   * UTF-16 BE encoding strategy.\n   */\n\t\tvar Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {\n\t\t\t/**\n    * Converts a word array to a UTF-16 BE string.\n    *\n    * @param {WordArray} wordArray The word array.\n    *\n    * @return {string} The UTF-16 BE string.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n    */\n\t\t\tstringify: function (wordArray) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar words = wordArray.words;\n\t\t\t\tvar sigBytes = wordArray.sigBytes;\n\n\t\t\t\t// Convert\n\t\t\t\tvar utf16Chars = [];\n\t\t\t\tfor (var i = 0; i < sigBytes; i += 2) {\n\t\t\t\t\tvar codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff;\n\t\t\t\t\tutf16Chars.push(String.fromCharCode(codePoint));\n\t\t\t\t}\n\n\t\t\t\treturn utf16Chars.join('');\n\t\t\t},\n\n\t\t\t/**\n    * Converts a UTF-16 BE string to a word array.\n    *\n    * @param {string} utf16Str The UTF-16 BE string.\n    *\n    * @return {WordArray} The word array.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n    */\n\t\t\tparse: function (utf16Str) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar utf16StrLength = utf16Str.length;\n\n\t\t\t\t// Convert\n\t\t\t\tvar words = [];\n\t\t\t\tfor (var i = 0; i < utf16StrLength; i++) {\n\t\t\t\t\twords[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;\n\t\t\t\t}\n\n\t\t\t\treturn WordArray.create(words, utf16StrLength * 2);\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * UTF-16 LE encoding strategy.\n   */\n\t\tC_enc.Utf16LE = {\n\t\t\t/**\n    * Converts a word array to a UTF-16 LE string.\n    *\n    * @param {WordArray} wordArray The word array.\n    *\n    * @return {string} The UTF-16 LE string.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n    */\n\t\t\tstringify: function (wordArray) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar words = wordArray.words;\n\t\t\t\tvar sigBytes = wordArray.sigBytes;\n\n\t\t\t\t// Convert\n\t\t\t\tvar utf16Chars = [];\n\t\t\t\tfor (var i = 0; i < sigBytes; i += 2) {\n\t\t\t\t\tvar codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff);\n\t\t\t\t\tutf16Chars.push(String.fromCharCode(codePoint));\n\t\t\t\t}\n\n\t\t\t\treturn utf16Chars.join('');\n\t\t\t},\n\n\t\t\t/**\n    * Converts a UTF-16 LE string to a word array.\n    *\n    * @param {string} utf16Str The UTF-16 LE string.\n    *\n    * @return {WordArray} The word array.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n    */\n\t\t\tparse: function (utf16Str) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar utf16StrLength = utf16Str.length;\n\n\t\t\t\t// Convert\n\t\t\t\tvar words = [];\n\t\t\t\tfor (var i = 0; i < utf16StrLength; i++) {\n\t\t\t\t\twords[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);\n\t\t\t\t}\n\n\t\t\t\treturn WordArray.create(words, utf16StrLength * 2);\n\t\t\t}\n\t\t};\n\n\t\tfunction swapEndian(word) {\n\t\t\treturn word << 8 & 0xff00ff00 | word >>> 8 & 0x00ff00ff;\n\t\t}\n\t})();\n\n\treturn CryptoJS.enc.Utf16;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/enc-utf16.js?"
                );
              },
            './node_modules/crypto-js/evpkdf.js':
              /*!******************************************!*\
        !*** ./node_modules/crypto-js/evpkdf.js ***!
        \******************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar Base = C_lib.Base;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar C_algo = C.algo;\n\t\tvar MD5 = C_algo.MD5;\n\n\t\t/**\n   * This key derivation function is meant to conform with EVP_BytesToKey.\n   * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n   */\n\t\tvar EvpKDF = C_algo.EvpKDF = Base.extend({\n\t\t\t/**\n    * Configuration options.\n    *\n    * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n    * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n    * @property {number} iterations The number of iterations to perform. Default: 1\n    */\n\t\t\tcfg: Base.extend({\n\t\t\t\tkeySize: 128 / 32,\n\t\t\t\thasher: MD5,\n\t\t\t\titerations: 1\n\t\t\t}),\n\n\t\t\t/**\n    * Initializes a newly created key derivation function.\n    *\n    * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n    *\n    * @example\n    *\n    *     var kdf = CryptoJS.algo.EvpKDF.create();\n    *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n    *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n    */\n\t\t\tinit: function (cfg) {\n\t\t\t\tthis.cfg = this.cfg.extend(cfg);\n\t\t\t},\n\n\t\t\t/**\n    * Derives a key from a password.\n    *\n    * @param {WordArray|string} password The password.\n    * @param {WordArray|string} salt A salt.\n    *\n    * @return {WordArray} The derived key.\n    *\n    * @example\n    *\n    *     var key = kdf.compute(password, salt);\n    */\n\t\t\tcompute: function (password, salt) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar cfg = this.cfg;\n\n\t\t\t\t// Init hasher\n\t\t\t\tvar hasher = cfg.hasher.create();\n\n\t\t\t\t// Initial values\n\t\t\t\tvar derivedKey = WordArray.create();\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar derivedKeyWords = derivedKey.words;\n\t\t\t\tvar keySize = cfg.keySize;\n\t\t\t\tvar iterations = cfg.iterations;\n\n\t\t\t\t// Generate key\n\t\t\t\twhile (derivedKeyWords.length < keySize) {\n\t\t\t\t\tif (block) {\n\t\t\t\t\t\thasher.update(block);\n\t\t\t\t\t}\n\t\t\t\t\tvar block = hasher.update(password).finalize(salt);\n\t\t\t\t\thasher.reset();\n\n\t\t\t\t\t// Iterations\n\t\t\t\t\tfor (var i = 1; i < iterations; i++) {\n\t\t\t\t\t\tblock = hasher.finalize(block);\n\t\t\t\t\t\thasher.reset();\n\t\t\t\t\t}\n\n\t\t\t\t\tderivedKey.concat(block);\n\t\t\t\t}\n\t\t\t\tderivedKey.sigBytes = keySize * 4;\n\n\t\t\t\treturn derivedKey;\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   * @param {Object} cfg (Optional) The configuration options to use for this computation.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var key = CryptoJS.EvpKDF(password, salt);\n   *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n   *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n   */\n\t\tC.EvpKDF = function (password, salt, cfg) {\n\t\t\treturn EvpKDF.create(cfg).compute(password, salt);\n\t\t};\n\t})();\n\n\treturn CryptoJS.EvpKDF;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/evpkdf.js?'
                );
              },
            './node_modules/crypto-js/format-hex.js':
              /*!**********************************************!*\
        !*** ./node_modules/crypto-js/format-hex.js ***!
        \**********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar CipherParams = C_lib.CipherParams;\n\t\tvar C_enc = C.enc;\n\t\tvar Hex = C_enc.Hex;\n\t\tvar C_format = C.format;\n\n\t\tvar HexFormatter = C_format.Hex = {\n\t\t\t/**\n    * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n    *\n    * @param {CipherParams} cipherParams The cipher params object.\n    *\n    * @return {string} The hexadecimally encoded string.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n    */\n\t\t\tstringify: function (cipherParams) {\n\t\t\t\treturn cipherParams.ciphertext.toString(Hex);\n\t\t\t},\n\n\t\t\t/**\n    * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n    *\n    * @param {string} input The hexadecimally encoded string.\n    *\n    * @return {CipherParams} The cipher params object.\n    *\n    * @static\n    *\n    * @example\n    *\n    *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n    */\n\t\t\tparse: function (input) {\n\t\t\t\tvar ciphertext = Hex.parse(input);\n\t\t\t\treturn CipherParams.create({ ciphertext: ciphertext });\n\t\t\t}\n\t\t};\n\t})();\n\n\treturn CryptoJS.format.Hex;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/format-hex.js?'
                );
              },
            './node_modules/crypto-js/hmac.js':
              /*!****************************************!*\
        !*** ./node_modules/crypto-js/hmac.js ***!
        \****************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar Base = C_lib.Base;\n\t\tvar C_enc = C.enc;\n\t\tvar Utf8 = C_enc.Utf8;\n\t\tvar C_algo = C.algo;\n\n\t\t/**\n   * HMAC algorithm.\n   */\n\t\tvar HMAC = C_algo.HMAC = Base.extend({\n\t\t\t/**\n    * Initializes a newly created HMAC.\n    *\n    * @param {Hasher} hasher The hash algorithm to use.\n    * @param {WordArray|string} key The secret key.\n    *\n    * @example\n    *\n    *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n    */\n\t\t\tinit: function (hasher, key) {\n\t\t\t\t// Init hasher\n\t\t\t\thasher = this._hasher = new hasher.init();\n\n\t\t\t\t// Convert string to WordArray, else assume WordArray already\n\t\t\t\tif (typeof key == 'string') {\n\t\t\t\t\tkey = Utf8.parse(key);\n\t\t\t\t}\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar hasherBlockSize = hasher.blockSize;\n\t\t\t\tvar hasherBlockSizeBytes = hasherBlockSize * 4;\n\n\t\t\t\t// Allow arbitrary length keys\n\t\t\t\tif (key.sigBytes > hasherBlockSizeBytes) {\n\t\t\t\t\tkey = hasher.finalize(key);\n\t\t\t\t}\n\n\t\t\t\t// Clamp excess bits\n\t\t\t\tkey.clamp();\n\n\t\t\t\t// Clone key for inner and outer pads\n\t\t\t\tvar oKey = this._oKey = key.clone();\n\t\t\t\tvar iKey = this._iKey = key.clone();\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar oKeyWords = oKey.words;\n\t\t\t\tvar iKeyWords = iKey.words;\n\n\t\t\t\t// XOR keys with pad constants\n\t\t\t\tfor (var i = 0; i < hasherBlockSize; i++) {\n\t\t\t\t\toKeyWords[i] ^= 0x5c5c5c5c;\n\t\t\t\t\tiKeyWords[i] ^= 0x36363636;\n\t\t\t\t}\n\t\t\t\toKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n\n\t\t\t\t// Set initial values\n\t\t\t\tthis.reset();\n\t\t\t},\n\n\t\t\t/**\n    * Resets this HMAC to its initial state.\n    *\n    * @example\n    *\n    *     hmacHasher.reset();\n    */\n\t\t\treset: function () {\n\t\t\t\t// Shortcut\n\t\t\t\tvar hasher = this._hasher;\n\n\t\t\t\t// Reset\n\t\t\t\thasher.reset();\n\t\t\t\thasher.update(this._iKey);\n\t\t\t},\n\n\t\t\t/**\n    * Updates this HMAC with a message.\n    *\n    * @param {WordArray|string} messageUpdate The message to append.\n    *\n    * @return {HMAC} This HMAC instance.\n    *\n    * @example\n    *\n    *     hmacHasher.update('message');\n    *     hmacHasher.update(wordArray);\n    */\n\t\t\tupdate: function (messageUpdate) {\n\t\t\t\tthis._hasher.update(messageUpdate);\n\n\t\t\t\t// Chainable\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t/**\n    * Finalizes the HMAC computation.\n    * Note that the finalize operation is effectively a destructive, read-once operation.\n    *\n    * @param {WordArray|string} messageUpdate (Optional) A final message update.\n    *\n    * @return {WordArray} The HMAC.\n    *\n    * @example\n    *\n    *     var hmac = hmacHasher.finalize();\n    *     var hmac = hmacHasher.finalize('message');\n    *     var hmac = hmacHasher.finalize(wordArray);\n    */\n\t\t\tfinalize: function (messageUpdate) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar hasher = this._hasher;\n\n\t\t\t\t// Compute HMAC\n\t\t\t\tvar innerHash = hasher.finalize(messageUpdate);\n\t\t\t\thasher.reset();\n\t\t\t\tvar hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n\t\t\t\treturn hmac;\n\t\t\t}\n\t\t});\n\t})();\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/hmac.js?"
                );
              },
            './node_modules/crypto-js/index.js':
              /*!*****************************************!*\
        !*** ./node_modules/crypto-js/index.js ***!
        \*****************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"), __webpack_require__(/*! ./lib-typedarrays */ "./node_modules/crypto-js/lib-typedarrays.js"), __webpack_require__(/*! ./enc-utf16 */ "./node_modules/crypto-js/enc-utf16.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"), __webpack_require__(/*! ./sha224 */ "./node_modules/crypto-js/sha224.js"), __webpack_require__(/*! ./sha512 */ "./node_modules/crypto-js/sha512.js"), __webpack_require__(/*! ./sha384 */ "./node_modules/crypto-js/sha384.js"), __webpack_require__(/*! ./sha3 */ "./node_modules/crypto-js/sha3.js"), __webpack_require__(/*! ./ripemd160 */ "./node_modules/crypto-js/ripemd160.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"), __webpack_require__(/*! ./pbkdf2 */ "./node_modules/crypto-js/pbkdf2.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"), __webpack_require__(/*! ./mode-cfb */ "./node_modules/crypto-js/mode-cfb.js"), __webpack_require__(/*! ./mode-ctr */ "./node_modules/crypto-js/mode-ctr.js"), __webpack_require__(/*! ./mode-ctr-gladman */ "./node_modules/crypto-js/mode-ctr-gladman.js"), __webpack_require__(/*! ./mode-ofb */ "./node_modules/crypto-js/mode-ofb.js"), __webpack_require__(/*! ./mode-ecb */ "./node_modules/crypto-js/mode-ecb.js"), __webpack_require__(/*! ./pad-ansix923 */ "./node_modules/crypto-js/pad-ansix923.js"), __webpack_require__(/*! ./pad-iso10126 */ "./node_modules/crypto-js/pad-iso10126.js"), __webpack_require__(/*! ./pad-iso97971 */ "./node_modules/crypto-js/pad-iso97971.js"), __webpack_require__(/*! ./pad-zeropadding */ "./node_modules/crypto-js/pad-zeropadding.js"), __webpack_require__(/*! ./pad-nopadding */ "./node_modules/crypto-js/pad-nopadding.js"), __webpack_require__(/*! ./format-hex */ "./node_modules/crypto-js/format-hex.js"), __webpack_require__(/*! ./aes */ "./node_modules/crypto-js/aes.js"), __webpack_require__(/*! ./tripledes */ "./node_modules/crypto-js/tripledes.js"), __webpack_require__(/*! ./rc4 */ "./node_modules/crypto-js/rc4.js"), __webpack_require__(/*! ./rabbit */ "./node_modules/crypto-js/rabbit.js"), __webpack_require__(/*! ./rabbit-legacy */ "./node_modules/crypto-js/rabbit-legacy.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\treturn CryptoJS;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/index.js?'
                );
              },
            './node_modules/crypto-js/lib-typedarrays.js':
              /*!***************************************************!*\
        !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
        \***************************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Check if typed arrays are supported\n\t\tif (typeof ArrayBuffer != \'function\') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\n\t\t// Reference original init\n\t\tvar superInit = WordArray.init;\n\n\t\t// Augment WordArray.init to handle typed arrays\n\t\tvar subInit = WordArray.init = function (typedArray) {\n\t\t\t// Convert buffers to uint8\n\t\t\tif (typedArray instanceof ArrayBuffer) {\n\t\t\t\ttypedArray = new Uint8Array(typedArray);\n\t\t\t}\n\n\t\t\t// Convert other array views to uint8\n\t\t\tif (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {\n\t\t\t\ttypedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t\t\t}\n\n\t\t\t// Handle Uint8Array\n\t\t\tif (typedArray instanceof Uint8Array) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar typedArrayByteLength = typedArray.byteLength;\n\n\t\t\t\t// Extract bytes\n\t\t\t\tvar words = [];\n\t\t\t\tfor (var i = 0; i < typedArrayByteLength; i++) {\n\t\t\t\t\twords[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;\n\t\t\t\t}\n\n\t\t\t\t// Initialize this word array\n\t\t\t\tsuperInit.call(this, words, typedArrayByteLength);\n\t\t\t} else {\n\t\t\t\t// Else call normal init\n\t\t\t\tsuperInit.apply(this, arguments);\n\t\t\t}\n\t\t};\n\n\t\tsubInit.prototype = WordArray;\n\t})();\n\n\treturn CryptoJS.lib.WordArray;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/lib-typedarrays.js?'
                );
              },
            './node_modules/crypto-js/md5.js':
              /*!***************************************!*\
        !*** ./node_modules/crypto-js/md5.js ***!
        \***************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar Hasher = C_lib.Hasher;\n\t\tvar C_algo = C.algo;\n\n\t\t// Constants table\n\t\tvar T = [];\n\n\t\t// Compute constants\n\t\t(function () {\n\t\t\tfor (var i = 0; i < 64; i++) {\n\t\t\t\tT[i] = Math.abs(Math.sin(i + 1)) * 0x100000000 | 0;\n\t\t\t}\n\t\t})();\n\n\t\t/**\n   * MD5 hash algorithm.\n   */\n\t\tvar MD5 = C_algo.MD5 = Hasher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\tthis._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\t\t\t\t// Swap endian\n\t\t\t\tfor (var i = 0; i < 16; i++) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar offset_i = offset + i;\n\t\t\t\t\tvar M_offset_i = M[offset_i];\n\n\t\t\t\t\tM[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;\n\t\t\t\t}\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar H = this._hash.words;\n\n\t\t\t\tvar M_offset_0 = M[offset + 0];\n\t\t\t\tvar M_offset_1 = M[offset + 1];\n\t\t\t\tvar M_offset_2 = M[offset + 2];\n\t\t\t\tvar M_offset_3 = M[offset + 3];\n\t\t\t\tvar M_offset_4 = M[offset + 4];\n\t\t\t\tvar M_offset_5 = M[offset + 5];\n\t\t\t\tvar M_offset_6 = M[offset + 6];\n\t\t\t\tvar M_offset_7 = M[offset + 7];\n\t\t\t\tvar M_offset_8 = M[offset + 8];\n\t\t\t\tvar M_offset_9 = M[offset + 9];\n\t\t\t\tvar M_offset_10 = M[offset + 10];\n\t\t\t\tvar M_offset_11 = M[offset + 11];\n\t\t\t\tvar M_offset_12 = M[offset + 12];\n\t\t\t\tvar M_offset_13 = M[offset + 13];\n\t\t\t\tvar M_offset_14 = M[offset + 14];\n\t\t\t\tvar M_offset_15 = M[offset + 15];\n\n\t\t\t\t// Working varialbes\n\t\t\t\tvar a = H[0];\n\t\t\t\tvar b = H[1];\n\t\t\t\tvar c = H[2];\n\t\t\t\tvar d = H[3];\n\n\t\t\t\t// Computation\n\t\t\t\ta = FF(a, b, c, d, M_offset_0, 7, T[0]);\n\t\t\t\td = FF(d, a, b, c, M_offset_1, 12, T[1]);\n\t\t\t\tc = FF(c, d, a, b, M_offset_2, 17, T[2]);\n\t\t\t\tb = FF(b, c, d, a, M_offset_3, 22, T[3]);\n\t\t\t\ta = FF(a, b, c, d, M_offset_4, 7, T[4]);\n\t\t\t\td = FF(d, a, b, c, M_offset_5, 12, T[5]);\n\t\t\t\tc = FF(c, d, a, b, M_offset_6, 17, T[6]);\n\t\t\t\tb = FF(b, c, d, a, M_offset_7, 22, T[7]);\n\t\t\t\ta = FF(a, b, c, d, M_offset_8, 7, T[8]);\n\t\t\t\td = FF(d, a, b, c, M_offset_9, 12, T[9]);\n\t\t\t\tc = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t\t\t\tb = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t\t\t\ta = FF(a, b, c, d, M_offset_12, 7, T[12]);\n\t\t\t\td = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t\t\t\tc = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t\t\t\tb = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t\t\t\ta = GG(a, b, c, d, M_offset_1, 5, T[16]);\n\t\t\t\td = GG(d, a, b, c, M_offset_6, 9, T[17]);\n\t\t\t\tc = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t\t\t\tb = GG(b, c, d, a, M_offset_0, 20, T[19]);\n\t\t\t\ta = GG(a, b, c, d, M_offset_5, 5, T[20]);\n\t\t\t\td = GG(d, a, b, c, M_offset_10, 9, T[21]);\n\t\t\t\tc = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t\t\t\tb = GG(b, c, d, a, M_offset_4, 20, T[23]);\n\t\t\t\ta = GG(a, b, c, d, M_offset_9, 5, T[24]);\n\t\t\t\td = GG(d, a, b, c, M_offset_14, 9, T[25]);\n\t\t\t\tc = GG(c, d, a, b, M_offset_3, 14, T[26]);\n\t\t\t\tb = GG(b, c, d, a, M_offset_8, 20, T[27]);\n\t\t\t\ta = GG(a, b, c, d, M_offset_13, 5, T[28]);\n\t\t\t\td = GG(d, a, b, c, M_offset_2, 9, T[29]);\n\t\t\t\tc = GG(c, d, a, b, M_offset_7, 14, T[30]);\n\t\t\t\tb = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t\t\t\ta = HH(a, b, c, d, M_offset_5, 4, T[32]);\n\t\t\t\td = HH(d, a, b, c, M_offset_8, 11, T[33]);\n\t\t\t\tc = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t\t\t\tb = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t\t\t\ta = HH(a, b, c, d, M_offset_1, 4, T[36]);\n\t\t\t\td = HH(d, a, b, c, M_offset_4, 11, T[37]);\n\t\t\t\tc = HH(c, d, a, b, M_offset_7, 16, T[38]);\n\t\t\t\tb = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t\t\t\ta = HH(a, b, c, d, M_offset_13, 4, T[40]);\n\t\t\t\td = HH(d, a, b, c, M_offset_0, 11, T[41]);\n\t\t\t\tc = HH(c, d, a, b, M_offset_3, 16, T[42]);\n\t\t\t\tb = HH(b, c, d, a, M_offset_6, 23, T[43]);\n\t\t\t\ta = HH(a, b, c, d, M_offset_9, 4, T[44]);\n\t\t\t\td = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t\t\t\tc = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t\t\t\tb = HH(b, c, d, a, M_offset_2, 23, T[47]);\n\n\t\t\t\ta = II(a, b, c, d, M_offset_0, 6, T[48]);\n\t\t\t\td = II(d, a, b, c, M_offset_7, 10, T[49]);\n\t\t\t\tc = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t\t\t\tb = II(b, c, d, a, M_offset_5, 21, T[51]);\n\t\t\t\ta = II(a, b, c, d, M_offset_12, 6, T[52]);\n\t\t\t\td = II(d, a, b, c, M_offset_3, 10, T[53]);\n\t\t\t\tc = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t\t\t\tb = II(b, c, d, a, M_offset_1, 21, T[55]);\n\t\t\t\ta = II(a, b, c, d, M_offset_8, 6, T[56]);\n\t\t\t\td = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t\t\t\tc = II(c, d, a, b, M_offset_6, 15, T[58]);\n\t\t\t\tb = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t\t\t\ta = II(a, b, c, d, M_offset_4, 6, T[60]);\n\t\t\t\td = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t\t\t\tc = II(c, d, a, b, M_offset_2, 15, T[62]);\n\t\t\t\tb = II(b, c, d, a, M_offset_9, 21, T[63]);\n\n\t\t\t\t// Intermediate hash value\n\t\t\t\tH[0] = H[0] + a | 0;\n\t\t\t\tH[1] = H[1] + b | 0;\n\t\t\t\tH[2] = H[2] + c | 0;\n\t\t\t\tH[3] = H[3] + d | 0;\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar data = this._data;\n\t\t\t\tvar dataWords = data.words;\n\n\t\t\t\tvar nBitsTotal = this._nDataBytes * 8;\n\t\t\t\tvar nBitsLeft = data.sigBytes * 8;\n\n\t\t\t\t// Add padding\n\t\t\t\tdataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n\n\t\t\t\tvar nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t\t\t\tvar nBitsTotalL = nBitsTotal;\n\t\t\t\tdataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 0x00ff00ff | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 0xff00ff00;\n\t\t\t\tdataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 0x00ff00ff | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 0xff00ff00;\n\n\t\t\t\tdata.sigBytes = (dataWords.length + 1) * 4;\n\n\t\t\t\t// Hash final blocks\n\t\t\t\tthis._process();\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar hash = this._hash;\n\t\t\t\tvar H = hash.words;\n\n\t\t\t\t// Swap endian\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t// Shortcut\n\t\t\t\t\tvar H_i = H[i];\n\n\t\t\t\t\tH[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;\n\t\t\t\t}\n\n\t\t\t\t// Return final computed hash\n\t\t\t\treturn hash;\n\t\t\t},\n\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Hasher.clone.call(this);\n\t\t\t\tclone._hash = this._hash.clone();\n\n\t\t\t\treturn clone;\n\t\t\t}\n\t\t});\n\n\t\tfunction FF(a, b, c, d, x, s, t) {\n\t\t\tvar n = a + (b & c | ~b & d) + x + t;\n\t\t\treturn (n << s | n >>> 32 - s) + b;\n\t\t}\n\n\t\tfunction GG(a, b, c, d, x, s, t) {\n\t\t\tvar n = a + (b & d | c & ~d) + x + t;\n\t\t\treturn (n << s | n >>> 32 - s) + b;\n\t\t}\n\n\t\tfunction HH(a, b, c, d, x, s, t) {\n\t\t\tvar n = a + (b ^ c ^ d) + x + t;\n\t\t\treturn (n << s | n >>> 32 - s) + b;\n\t\t}\n\n\t\tfunction II(a, b, c, d, x, s, t) {\n\t\t\tvar n = a + (c ^ (b | ~d)) + x + t;\n\t\t\treturn (n << s | n >>> 32 - s) + b;\n\t\t}\n\n\t\t/**\n   * Shortcut function to the hasher's object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hash = CryptoJS.MD5('message');\n   *     var hash = CryptoJS.MD5(wordArray);\n   */\n\t\tC.MD5 = Hasher._createHelper(MD5);\n\n\t\t/**\n   * Shortcut function to the HMAC's object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hmac = CryptoJS.HmacMD5(message, key);\n   */\n\t\tC.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t})(Math);\n\n\treturn CryptoJS.MD5;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/md5.js?"
                );
              },
            './node_modules/crypto-js/mode-cfb.js':
              /*!********************************************!*\
        !*** ./node_modules/crypto-js/mode-cfb.js ***!
        \********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * Cipher Feedback block mode.\n  */\n\tCryptoJS.mode.CFB = function () {\n\t\tvar CFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tCFB.Encryptor = CFB.extend({\n\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar cipher = this._cipher;\n\t\t\t\tvar blockSize = cipher.blockSize;\n\n\t\t\t\tgenerateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t\t\t\t// Remember this block to use with next block\n\t\t\t\tthis._prevBlock = words.slice(offset, offset + blockSize);\n\t\t\t}\n\t\t});\n\n\t\tCFB.Decryptor = CFB.extend({\n\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar cipher = this._cipher;\n\t\t\t\tvar blockSize = cipher.blockSize;\n\n\t\t\t\t// Remember this block to use with next block\n\t\t\t\tvar thisBlock = words.slice(offset, offset + blockSize);\n\n\t\t\t\tgenerateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t\t\t\t// This block becomes the previous block\n\t\t\t\tthis._prevBlock = thisBlock;\n\t\t\t}\n\t\t});\n\n\t\tfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n\t\t\t// Shortcut\n\t\t\tvar iv = this._iv;\n\n\t\t\t// Generate keystream\n\t\t\tif (iv) {\n\t\t\t\tvar keystream = iv.slice(0);\n\n\t\t\t\t// Remove IV for subsequent blocks\n\t\t\t\tthis._iv = undefined;\n\t\t\t} else {\n\t\t\t\tvar keystream = this._prevBlock;\n\t\t\t}\n\t\t\tcipher.encryptBlock(keystream, 0);\n\n\t\t\t// Encrypt\n\t\t\tfor (var i = 0; i < blockSize; i++) {\n\t\t\t\twords[offset + i] ^= keystream[i];\n\t\t\t}\n\t\t}\n\n\t\treturn CFB;\n\t}();\n\n\treturn CryptoJS.mode.CFB;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/mode-cfb.js?'
                );
              },
            './node_modules/crypto-js/mode-ctr-gladman.js':
              /*!****************************************************!*\
        !*** ./node_modules/crypto-js/mode-ctr-gladman.js ***!
        \****************************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/** @preserve\n  * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n  * derived from CryptoJS.mode.CTR\n  * Jan Hruby jhruby.web@gmail.com\n  */\n\tCryptoJS.mode.CTRGladman = function () {\n\t\tvar CTRGladman = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tfunction incWord(word) {\n\t\t\tif ((word >> 24 & 0xff) === 0xff) {\n\t\t\t\t//overflow\n\t\t\t\tvar b1 = word >> 16 & 0xff;\n\t\t\t\tvar b2 = word >> 8 & 0xff;\n\t\t\t\tvar b3 = word & 0xff;\n\n\t\t\t\tif (b1 === 0xff) // overflow b1\n\t\t\t\t\t{\n\t\t\t\t\t\tb1 = 0;\n\t\t\t\t\t\tif (b2 === 0xff) {\n\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\tif (b3 === 0xff) {\n\t\t\t\t\t\t\t\tb3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t++b3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t++b2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t++b1;\n\t\t\t\t}\n\n\t\t\t\tword = 0;\n\t\t\t\tword += b1 << 16;\n\t\t\t\tword += b2 << 8;\n\t\t\t\tword += b3;\n\t\t\t} else {\n\t\t\t\tword += 0x01 << 24;\n\t\t\t}\n\t\t\treturn word;\n\t\t}\n\n\t\tfunction incCounter(counter) {\n\t\t\tif ((counter[0] = incWord(counter[0])) === 0) {\n\t\t\t\t// encr_data in fileenc.c from  Dr Brian Gladman\'s counts only with DWORD j < 8\n\t\t\t\tcounter[1] = incWord(counter[1]);\n\t\t\t}\n\t\t\treturn counter;\n\t\t}\n\n\t\tvar Encryptor = CTRGladman.Encryptor = CTRGladman.extend({\n\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar cipher = this._cipher;\n\t\t\t\tvar blockSize = cipher.blockSize;\n\t\t\t\tvar iv = this._iv;\n\t\t\t\tvar counter = this._counter;\n\n\t\t\t\t// Generate keystream\n\t\t\t\tif (iv) {\n\t\t\t\t\tcounter = this._counter = iv.slice(0);\n\n\t\t\t\t\t// Remove IV for subsequent blocks\n\t\t\t\t\tthis._iv = undefined;\n\t\t\t\t}\n\n\t\t\t\tincCounter(counter);\n\n\t\t\t\tvar keystream = counter.slice(0);\n\t\t\t\tcipher.encryptBlock(keystream, 0);\n\n\t\t\t\t// Encrypt\n\t\t\t\tfor (var i = 0; i < blockSize; i++) {\n\t\t\t\t\twords[offset + i] ^= keystream[i];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tCTRGladman.Decryptor = Encryptor;\n\n\t\treturn CTRGladman;\n\t}();\n\n\treturn CryptoJS.mode.CTRGladman;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/mode-ctr-gladman.js?'
                );
              },
            './node_modules/crypto-js/mode-ctr.js':
              /*!********************************************!*\
        !*** ./node_modules/crypto-js/mode-ctr.js ***!
        \********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * Counter block mode.\n  */\n\tCryptoJS.mode.CTR = function () {\n\t\tvar CTR = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tvar Encryptor = CTR.Encryptor = CTR.extend({\n\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar cipher = this._cipher;\n\t\t\t\tvar blockSize = cipher.blockSize;\n\t\t\t\tvar iv = this._iv;\n\t\t\t\tvar counter = this._counter;\n\n\t\t\t\t// Generate keystream\n\t\t\t\tif (iv) {\n\t\t\t\t\tcounter = this._counter = iv.slice(0);\n\n\t\t\t\t\t// Remove IV for subsequent blocks\n\t\t\t\t\tthis._iv = undefined;\n\t\t\t\t}\n\t\t\t\tvar keystream = counter.slice(0);\n\t\t\t\tcipher.encryptBlock(keystream, 0);\n\n\t\t\t\t// Increment counter\n\t\t\t\tcounter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;\n\n\t\t\t\t// Encrypt\n\t\t\t\tfor (var i = 0; i < blockSize; i++) {\n\t\t\t\t\twords[offset + i] ^= keystream[i];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tCTR.Decryptor = Encryptor;\n\n\t\treturn CTR;\n\t}();\n\n\treturn CryptoJS.mode.CTR;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/mode-ctr.js?'
                );
              },
            './node_modules/crypto-js/mode-ecb.js':
              /*!********************************************!*\
        !*** ./node_modules/crypto-js/mode-ecb.js ***!
        \********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * Electronic Codebook block mode.\n  */\n\tCryptoJS.mode.ECB = function () {\n\t\tvar ECB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tECB.Encryptor = ECB.extend({\n\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\tthis._cipher.encryptBlock(words, offset);\n\t\t\t}\n\t\t});\n\n\t\tECB.Decryptor = ECB.extend({\n\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\tthis._cipher.decryptBlock(words, offset);\n\t\t\t}\n\t\t});\n\n\t\treturn ECB;\n\t}();\n\n\treturn CryptoJS.mode.ECB;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/mode-ecb.js?'
                );
              },
            './node_modules/crypto-js/mode-ofb.js':
              /*!********************************************!*\
        !*** ./node_modules/crypto-js/mode-ofb.js ***!
        \********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * Output Feedback block mode.\n  */\n\tCryptoJS.mode.OFB = function () {\n\t\tvar OFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tvar Encryptor = OFB.Encryptor = OFB.extend({\n\t\t\tprocessBlock: function (words, offset) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar cipher = this._cipher;\n\t\t\t\tvar blockSize = cipher.blockSize;\n\t\t\t\tvar iv = this._iv;\n\t\t\t\tvar keystream = this._keystream;\n\n\t\t\t\t// Generate keystream\n\t\t\t\tif (iv) {\n\t\t\t\t\tkeystream = this._keystream = iv.slice(0);\n\n\t\t\t\t\t// Remove IV for subsequent blocks\n\t\t\t\t\tthis._iv = undefined;\n\t\t\t\t}\n\t\t\t\tcipher.encryptBlock(keystream, 0);\n\n\t\t\t\t// Encrypt\n\t\t\t\tfor (var i = 0; i < blockSize; i++) {\n\t\t\t\t\twords[offset + i] ^= keystream[i];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tOFB.Decryptor = Encryptor;\n\n\t\treturn OFB;\n\t}();\n\n\treturn CryptoJS.mode.OFB;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/mode-ofb.js?'
                );
              },
            './node_modules/crypto-js/pad-ansix923.js':
              /*!************************************************!*\
        !*** ./node_modules/crypto-js/pad-ansix923.js ***!
        \************************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * ANSI X.923 padding strategy.\n  */\n\tCryptoJS.pad.AnsiX923 = {\n\t\tpad: function (data, blockSize) {\n\t\t\t// Shortcuts\n\t\t\tvar dataSigBytes = data.sigBytes;\n\t\t\tvar blockSizeBytes = blockSize * 4;\n\n\t\t\t// Count padding bytes\n\t\t\tvar nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;\n\n\t\t\t// Compute last byte position\n\t\t\tvar lastBytePos = dataSigBytes + nPaddingBytes - 1;\n\n\t\t\t// Pad\n\t\t\tdata.clamp();\n\t\t\tdata.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;\n\t\t\tdata.sigBytes += nPaddingBytes;\n\t\t},\n\n\t\tunpad: function (data) {\n\t\t\t// Get number of padding bytes from last byte\n\t\t\tvar nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff;\n\n\t\t\t// Remove padding\n\t\t\tdata.sigBytes -= nPaddingBytes;\n\t\t}\n\t};\n\n\treturn CryptoJS.pad.Ansix923;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/pad-ansix923.js?'
                );
              },
            './node_modules/crypto-js/pad-iso10126.js':
              /*!************************************************!*\
        !*** ./node_modules/crypto-js/pad-iso10126.js ***!
        \************************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * ISO 10126 padding strategy.\n  */\n\tCryptoJS.pad.Iso10126 = {\n\t\tpad: function (data, blockSize) {\n\t\t\t// Shortcut\n\t\t\tvar blockSizeBytes = blockSize * 4;\n\n\t\t\t// Count padding bytes\n\t\t\tvar nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t\t\t// Pad\n\t\t\tdata.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));\n\t\t},\n\n\t\tunpad: function (data) {\n\t\t\t// Get number of padding bytes from last byte\n\t\t\tvar nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff;\n\n\t\t\t// Remove padding\n\t\t\tdata.sigBytes -= nPaddingBytes;\n\t\t}\n\t};\n\n\treturn CryptoJS.pad.Iso10126;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/pad-iso10126.js?'
                );
              },
            './node_modules/crypto-js/pad-iso97971.js':
              /*!************************************************!*\
        !*** ./node_modules/crypto-js/pad-iso97971.js ***!
        \************************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * ISO/IEC 9797-1 Padding Method 2.\n  */\n\tCryptoJS.pad.Iso97971 = {\n\t\tpad: function (data, blockSize) {\n\t\t\t// Add 0x80 byte\n\t\t\tdata.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));\n\n\t\t\t// Zero pad the rest\n\t\t\tCryptoJS.pad.ZeroPadding.pad(data, blockSize);\n\t\t},\n\n\t\tunpad: function (data) {\n\t\t\t// Remove zero padding\n\t\t\tCryptoJS.pad.ZeroPadding.unpad(data);\n\n\t\t\t// Remove one more byte -- the 0x80 byte\n\t\t\tdata.sigBytes--;\n\t\t}\n\t};\n\n\treturn CryptoJS.pad.Iso97971;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/pad-iso97971.js?'
                );
              },
            './node_modules/crypto-js/pad-nopadding.js':
              /*!*************************************************!*\
        !*** ./node_modules/crypto-js/pad-nopadding.js ***!
        \*************************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * A noop padding strategy.\n  */\n\tCryptoJS.pad.NoPadding = {\n\t\tpad: function () {},\n\n\t\tunpad: function () {}\n\t};\n\n\treturn CryptoJS.pad.NoPadding;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/pad-nopadding.js?'
                );
              },
            './node_modules/crypto-js/pad-zeropadding.js':
              /*!***************************************************!*\
        !*** ./node_modules/crypto-js/pad-zeropadding.js ***!
        \***************************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/**\n  * Zero padding strategy.\n  */\n\tCryptoJS.pad.ZeroPadding = {\n\t\tpad: function (data, blockSize) {\n\t\t\t// Shortcut\n\t\t\tvar blockSizeBytes = blockSize * 4;\n\n\t\t\t// Pad\n\t\t\tdata.clamp();\n\t\t\tdata.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);\n\t\t},\n\n\t\tunpad: function (data) {\n\t\t\t// Shortcut\n\t\t\tvar dataWords = data.words;\n\n\t\t\t// Unpad\n\t\t\tvar i = data.sigBytes - 1;\n\t\t\twhile (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff)) {\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tdata.sigBytes = i + 1;\n\t\t}\n\t};\n\n\treturn CryptoJS.pad.ZeroPadding;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/pad-zeropadding.js?'
                );
              },
            './node_modules/crypto-js/pbkdf2.js':
              /*!******************************************!*\
        !*** ./node_modules/crypto-js/pbkdf2.js ***!
        \******************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar Base = C_lib.Base;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar C_algo = C.algo;\n\t\tvar SHA1 = C_algo.SHA1;\n\t\tvar HMAC = C_algo.HMAC;\n\n\t\t/**\n   * Password-Based Key Derivation Function 2 algorithm.\n   */\n\t\tvar PBKDF2 = C_algo.PBKDF2 = Base.extend({\n\t\t\t/**\n    * Configuration options.\n    *\n    * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n    * @property {Hasher} hasher The hasher to use. Default: SHA1\n    * @property {number} iterations The number of iterations to perform. Default: 1\n    */\n\t\t\tcfg: Base.extend({\n\t\t\t\tkeySize: 128 / 32,\n\t\t\t\thasher: SHA1,\n\t\t\t\titerations: 1\n\t\t\t}),\n\n\t\t\t/**\n    * Initializes a newly created key derivation function.\n    *\n    * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n    *\n    * @example\n    *\n    *     var kdf = CryptoJS.algo.PBKDF2.create();\n    *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n    *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n    */\n\t\t\tinit: function (cfg) {\n\t\t\t\tthis.cfg = this.cfg.extend(cfg);\n\t\t\t},\n\n\t\t\t/**\n    * Computes the Password-Based Key Derivation Function 2.\n    *\n    * @param {WordArray|string} password The password.\n    * @param {WordArray|string} salt A salt.\n    *\n    * @return {WordArray} The derived key.\n    *\n    * @example\n    *\n    *     var key = kdf.compute(password, salt);\n    */\n\t\t\tcompute: function (password, salt) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar cfg = this.cfg;\n\n\t\t\t\t// Init HMAC\n\t\t\t\tvar hmac = HMAC.create(cfg.hasher, password);\n\n\t\t\t\t// Initial values\n\t\t\t\tvar derivedKey = WordArray.create();\n\t\t\t\tvar blockIndex = WordArray.create([0x00000001]);\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar derivedKeyWords = derivedKey.words;\n\t\t\t\tvar blockIndexWords = blockIndex.words;\n\t\t\t\tvar keySize = cfg.keySize;\n\t\t\t\tvar iterations = cfg.iterations;\n\n\t\t\t\t// Generate key\n\t\t\t\twhile (derivedKeyWords.length < keySize) {\n\t\t\t\t\tvar block = hmac.update(salt).finalize(blockIndex);\n\t\t\t\t\thmac.reset();\n\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar blockWords = block.words;\n\t\t\t\t\tvar blockWordsLength = blockWords.length;\n\n\t\t\t\t\t// Iterations\n\t\t\t\t\tvar intermediate = block;\n\t\t\t\t\tfor (var i = 1; i < iterations; i++) {\n\t\t\t\t\t\tintermediate = hmac.finalize(intermediate);\n\t\t\t\t\t\thmac.reset();\n\n\t\t\t\t\t\t// Shortcut\n\t\t\t\t\t\tvar intermediateWords = intermediate.words;\n\n\t\t\t\t\t\t// XOR intermediate with block\n\t\t\t\t\t\tfor (var j = 0; j < blockWordsLength; j++) {\n\t\t\t\t\t\t\tblockWords[j] ^= intermediateWords[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tderivedKey.concat(block);\n\t\t\t\t\tblockIndexWords[0]++;\n\t\t\t\t}\n\t\t\t\tderivedKey.sigBytes = keySize * 4;\n\n\t\t\t\treturn derivedKey;\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Computes the Password-Based Key Derivation Function 2.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   * @param {Object} cfg (Optional) The configuration options to use for this computation.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var key = CryptoJS.PBKDF2(password, salt);\n   *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n   *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n   */\n\t\tC.PBKDF2 = function (password, salt, cfg) {\n\t\t\treturn PBKDF2.create(cfg).compute(password, salt);\n\t\t};\n\t})();\n\n\treturn CryptoJS.PBKDF2;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/pbkdf2.js?'
                );
              },
            './node_modules/crypto-js/rabbit-legacy.js':
              /*!*************************************************!*\
        !*** ./node_modules/crypto-js/rabbit-legacy.js ***!
        \*************************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar StreamCipher = C_lib.StreamCipher;\n\t\tvar C_algo = C.algo;\n\n\t\t// Reusable objects\n\t\tvar S = [];\n\t\tvar C_ = [];\n\t\tvar G = [];\n\n\t\t/**\n   * Rabbit stream cipher algorithm.\n   *\n   * This is a legacy version that neglected to convert the key to little-endian.\n   * This error doesn\'t affect the cipher\'s security,\n   * but it does affect its compatibility with other implementations.\n   */\n\t\tvar RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar K = this._key.words;\n\t\t\t\tvar iv = this.cfg.iv;\n\n\t\t\t\t// Generate initial state values\n\t\t\t\tvar X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];\n\n\t\t\t\t// Generate initial counter values\n\t\t\t\tvar C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff];\n\n\t\t\t\t// Carry bit\n\t\t\t\tthis._b = 0;\n\n\t\t\t\t// Iterate the system four times\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tnextState.call(this);\n\t\t\t\t}\n\n\t\t\t\t// Modify the counters\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tC[i] ^= X[i + 4 & 7];\n\t\t\t\t}\n\n\t\t\t\t// IV setup\n\t\t\t\tif (iv) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar IV = iv.words;\n\t\t\t\t\tvar IV_0 = IV[0];\n\t\t\t\t\tvar IV_1 = IV[1];\n\n\t\t\t\t\t// Generate four subvectors\n\t\t\t\t\tvar i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;\n\t\t\t\t\tvar i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;\n\t\t\t\t\tvar i1 = i0 >>> 16 | i2 & 0xffff0000;\n\t\t\t\t\tvar i3 = i2 << 16 | i0 & 0x0000ffff;\n\n\t\t\t\t\t// Modify counter values\n\t\t\t\t\tC[0] ^= i0;\n\t\t\t\t\tC[1] ^= i1;\n\t\t\t\t\tC[2] ^= i2;\n\t\t\t\t\tC[3] ^= i3;\n\t\t\t\t\tC[4] ^= i0;\n\t\t\t\t\tC[5] ^= i1;\n\t\t\t\t\tC[6] ^= i2;\n\t\t\t\t\tC[7] ^= i3;\n\n\t\t\t\t\t// Iterate the system four times\n\t\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t\tnextState.call(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar X = this._X;\n\n\t\t\t\t// Iterate the system\n\t\t\t\tnextState.call(this);\n\n\t\t\t\t// Generate four keystream words\n\t\t\t\tS[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;\n\t\t\t\tS[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;\n\t\t\t\tS[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;\n\t\t\t\tS[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;\n\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t// Swap endian\n\t\t\t\t\tS[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00;\n\n\t\t\t\t\t// Encrypt\n\t\t\t\t\tM[offset + i] ^= S[i];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tblockSize: 128 / 32,\n\n\t\t\tivSize: 64 / 32\n\t\t});\n\n\t\tfunction nextState() {\n\t\t\t// Shortcuts\n\t\t\tvar X = this._X;\n\t\t\tvar C = this._C;\n\n\t\t\t// Save old counter values\n\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\tC_[i] = C[i];\n\t\t\t}\n\n\t\t\t// Calculate new counter values\n\t\t\tC[0] = C[0] + 0x4d34d34d + this._b | 0;\n\t\t\tC[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;\n\t\t\tthis._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;\n\n\t\t\t// Calculate the g-values\n\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\tvar gx = X[i] + C[i];\n\n\t\t\t\t// Construct high and low argument for squaring\n\t\t\t\tvar ga = gx & 0xffff;\n\t\t\t\tvar gb = gx >>> 16;\n\n\t\t\t\t// Calculate high and low result of squaring\n\t\t\t\tvar gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;\n\t\t\t\tvar gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0);\n\n\t\t\t\t// High XOR low\n\t\t\t\tG[i] = gh ^ gl;\n\t\t\t}\n\n\t\t\t// Calculate new state values\n\t\t\tX[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;\n\t\t\tX[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;\n\t\t\tX[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;\n\t\t\tX[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;\n\t\t\tX[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;\n\t\t\tX[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;\n\t\t\tX[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;\n\t\t\tX[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;\n\t\t}\n\n\t\t/**\n   * Shortcut functions to the cipher\'s object interface.\n   *\n   * @example\n   *\n   *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n   *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n   */\n\t\tC.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);\n\t})();\n\n\treturn CryptoJS.RabbitLegacy;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/rabbit-legacy.js?'
                );
              },
            './node_modules/crypto-js/rabbit.js':
              /*!******************************************!*\
        !*** ./node_modules/crypto-js/rabbit.js ***!
        \******************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar StreamCipher = C_lib.StreamCipher;\n\t\tvar C_algo = C.algo;\n\n\t\t// Reusable objects\n\t\tvar S = [];\n\t\tvar C_ = [];\n\t\tvar G = [];\n\n\t\t/**\n   * Rabbit stream cipher algorithm\n   */\n\t\tvar Rabbit = C_algo.Rabbit = StreamCipher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar K = this._key.words;\n\t\t\t\tvar iv = this.cfg.iv;\n\n\t\t\t\t// Swap endian\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tK[i] = (K[i] << 8 | K[i] >>> 24) & 0x00ff00ff | (K[i] << 24 | K[i] >>> 8) & 0xff00ff00;\n\t\t\t\t}\n\n\t\t\t\t// Generate initial state values\n\t\t\t\tvar X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];\n\n\t\t\t\t// Generate initial counter values\n\t\t\t\tvar C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff];\n\n\t\t\t\t// Carry bit\n\t\t\t\tthis._b = 0;\n\n\t\t\t\t// Iterate the system four times\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tnextState.call(this);\n\t\t\t\t}\n\n\t\t\t\t// Modify the counters\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tC[i] ^= X[i + 4 & 7];\n\t\t\t\t}\n\n\t\t\t\t// IV setup\n\t\t\t\tif (iv) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar IV = iv.words;\n\t\t\t\t\tvar IV_0 = IV[0];\n\t\t\t\t\tvar IV_1 = IV[1];\n\n\t\t\t\t\t// Generate four subvectors\n\t\t\t\t\tvar i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;\n\t\t\t\t\tvar i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;\n\t\t\t\t\tvar i1 = i0 >>> 16 | i2 & 0xffff0000;\n\t\t\t\t\tvar i3 = i2 << 16 | i0 & 0x0000ffff;\n\n\t\t\t\t\t// Modify counter values\n\t\t\t\t\tC[0] ^= i0;\n\t\t\t\t\tC[1] ^= i1;\n\t\t\t\t\tC[2] ^= i2;\n\t\t\t\t\tC[3] ^= i3;\n\t\t\t\t\tC[4] ^= i0;\n\t\t\t\t\tC[5] ^= i1;\n\t\t\t\t\tC[6] ^= i2;\n\t\t\t\t\tC[7] ^= i3;\n\n\t\t\t\t\t// Iterate the system four times\n\t\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t\tnextState.call(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar X = this._X;\n\n\t\t\t\t// Iterate the system\n\t\t\t\tnextState.call(this);\n\n\t\t\t\t// Generate four keystream words\n\t\t\t\tS[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;\n\t\t\t\tS[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;\n\t\t\t\tS[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;\n\t\t\t\tS[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;\n\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t// Swap endian\n\t\t\t\t\tS[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00;\n\n\t\t\t\t\t// Encrypt\n\t\t\t\t\tM[offset + i] ^= S[i];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tblockSize: 128 / 32,\n\n\t\t\tivSize: 64 / 32\n\t\t});\n\n\t\tfunction nextState() {\n\t\t\t// Shortcuts\n\t\t\tvar X = this._X;\n\t\t\tvar C = this._C;\n\n\t\t\t// Save old counter values\n\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\tC_[i] = C[i];\n\t\t\t}\n\n\t\t\t// Calculate new counter values\n\t\t\tC[0] = C[0] + 0x4d34d34d + this._b | 0;\n\t\t\tC[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;\n\t\t\tC[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;\n\t\t\tthis._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;\n\n\t\t\t// Calculate the g-values\n\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\tvar gx = X[i] + C[i];\n\n\t\t\t\t// Construct high and low argument for squaring\n\t\t\t\tvar ga = gx & 0xffff;\n\t\t\t\tvar gb = gx >>> 16;\n\n\t\t\t\t// Calculate high and low result of squaring\n\t\t\t\tvar gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;\n\t\t\t\tvar gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0);\n\n\t\t\t\t// High XOR low\n\t\t\t\tG[i] = gh ^ gl;\n\t\t\t}\n\n\t\t\t// Calculate new state values\n\t\t\tX[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;\n\t\t\tX[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;\n\t\t\tX[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;\n\t\t\tX[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;\n\t\t\tX[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;\n\t\t\tX[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;\n\t\t\tX[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;\n\t\t\tX[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;\n\t\t}\n\n\t\t/**\n   * Shortcut functions to the cipher\'s object interface.\n   *\n   * @example\n   *\n   *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n   *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n   */\n\t\tC.Rabbit = StreamCipher._createHelper(Rabbit);\n\t})();\n\n\treturn CryptoJS.Rabbit;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/rabbit.js?'
                );
              },
            './node_modules/crypto-js/rc4.js':
              /*!***************************************!*\
        !*** ./node_modules/crypto-js/rc4.js ***!
        \***************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar StreamCipher = C_lib.StreamCipher;\n\t\tvar C_algo = C.algo;\n\n\t\t/**\n   * RC4 stream cipher algorithm.\n   */\n\t\tvar RC4 = C_algo.RC4 = StreamCipher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar key = this._key;\n\t\t\t\tvar keyWords = key.words;\n\t\t\t\tvar keySigBytes = key.sigBytes;\n\n\t\t\t\t// Init sbox\n\t\t\t\tvar S = this._S = [];\n\t\t\t\tfor (var i = 0; i < 256; i++) {\n\t\t\t\t\tS[i] = i;\n\t\t\t\t}\n\n\t\t\t\t// Key setup\n\t\t\t\tfor (var i = 0, j = 0; i < 256; i++) {\n\t\t\t\t\tvar keyByteIndex = i % keySigBytes;\n\t\t\t\t\tvar keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 0xff;\n\n\t\t\t\t\tj = (j + S[i] + keyByte) % 256;\n\n\t\t\t\t\t// Swap\n\t\t\t\t\tvar t = S[i];\n\t\t\t\t\tS[i] = S[j];\n\t\t\t\t\tS[j] = t;\n\t\t\t\t}\n\n\t\t\t\t// Counters\n\t\t\t\tthis._i = this._j = 0;\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\t\t\t\tM[offset] ^= generateKeystreamWord.call(this);\n\t\t\t},\n\n\t\t\tkeySize: 256 / 32,\n\n\t\t\tivSize: 0\n\t\t});\n\n\t\tfunction generateKeystreamWord() {\n\t\t\t// Shortcuts\n\t\t\tvar S = this._S;\n\t\t\tvar i = this._i;\n\t\t\tvar j = this._j;\n\n\t\t\t// Generate keystream word\n\t\t\tvar keystreamWord = 0;\n\t\t\tfor (var n = 0; n < 4; n++) {\n\t\t\t\ti = (i + 1) % 256;\n\t\t\t\tj = (j + S[i]) % 256;\n\n\t\t\t\t// Swap\n\t\t\t\tvar t = S[i];\n\t\t\t\tS[i] = S[j];\n\t\t\t\tS[j] = t;\n\n\t\t\t\tkeystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;\n\t\t\t}\n\n\t\t\t// Update counters\n\t\t\tthis._i = i;\n\t\t\tthis._j = j;\n\n\t\t\treturn keystreamWord;\n\t\t}\n\n\t\t/**\n   * Shortcut functions to the cipher\'s object interface.\n   *\n   * @example\n   *\n   *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n   *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n   */\n\t\tC.RC4 = StreamCipher._createHelper(RC4);\n\n\t\t/**\n   * Modified RC4 stream cipher algorithm.\n   */\n\t\tvar RC4Drop = C_algo.RC4Drop = RC4.extend({\n\t\t\t/**\n    * Configuration options.\n    *\n    * @property {number} drop The number of keystream words to drop. Default 192\n    */\n\t\t\tcfg: RC4.cfg.extend({\n\t\t\t\tdrop: 192\n\t\t\t}),\n\n\t\t\t_doReset: function () {\n\t\t\t\tRC4._doReset.call(this);\n\n\t\t\t\t// Drop\n\t\t\t\tfor (var i = this.cfg.drop; i > 0; i--) {\n\t\t\t\t\tgenerateKeystreamWord.call(this);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Shortcut functions to the cipher\'s object interface.\n   *\n   * @example\n   *\n   *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n   *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n   */\n\t\tC.RC4Drop = StreamCipher._createHelper(RC4Drop);\n\t})();\n\n\treturn CryptoJS.RC4;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/rc4.js?'
                );
              },
            './node_modules/crypto-js/ripemd160.js':
              /*!*********************************************!*\
        !*** ./node_modules/crypto-js/ripemd160.js ***!
        \*********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t/** @preserve\n (c) 2012 by Cdric Mesnil. All rights reserved.\n \tRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n \t    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n     - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n \tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\t(function (Math) {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar Hasher = C_lib.Hasher;\n\t\tvar C_algo = C.algo;\n\n\t\t// Constants table\n\t\tvar _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);\n\t\tvar _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);\n\t\tvar _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);\n\t\tvar _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);\n\n\t\tvar _hl = WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\n\t\tvar _hr = WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\n\t\t/**\n   * RIPEMD160 hash algorithm.\n   */\n\t\tvar RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\tthis._hash = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\n\t\t\t\t// Swap endian\n\t\t\t\tfor (var i = 0; i < 16; i++) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar offset_i = offset + i;\n\t\t\t\t\tvar M_offset_i = M[offset_i];\n\n\t\t\t\t\t// Swap\n\t\t\t\t\tM[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;\n\t\t\t\t}\n\t\t\t\t// Shortcut\n\t\t\t\tvar H = this._hash.words;\n\t\t\t\tvar hl = _hl.words;\n\t\t\t\tvar hr = _hr.words;\n\t\t\t\tvar zl = _zl.words;\n\t\t\t\tvar zr = _zr.words;\n\t\t\t\tvar sl = _sl.words;\n\t\t\t\tvar sr = _sr.words;\n\n\t\t\t\t// Working variables\n\t\t\t\tvar al, bl, cl, dl, el;\n\t\t\t\tvar ar, br, cr, dr, er;\n\n\t\t\t\tar = al = H[0];\n\t\t\t\tbr = bl = H[1];\n\t\t\t\tcr = cl = H[2];\n\t\t\t\tdr = dl = H[3];\n\t\t\t\ter = el = H[4];\n\t\t\t\t// Computation\n\t\t\t\tvar t;\n\t\t\t\tfor (var i = 0; i < 80; i += 1) {\n\t\t\t\t\tt = al + M[offset + zl[i]] | 0;\n\t\t\t\t\tif (i < 16) {\n\t\t\t\t\t\tt += f1(bl, cl, dl) + hl[0];\n\t\t\t\t\t} else if (i < 32) {\n\t\t\t\t\t\tt += f2(bl, cl, dl) + hl[1];\n\t\t\t\t\t} else if (i < 48) {\n\t\t\t\t\t\tt += f3(bl, cl, dl) + hl[2];\n\t\t\t\t\t} else if (i < 64) {\n\t\t\t\t\t\tt += f4(bl, cl, dl) + hl[3];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if (i<80) {\n\t\t\t\t\t\tt += f5(bl, cl, dl) + hl[4];\n\t\t\t\t\t}\n\t\t\t\t\tt = t | 0;\n\t\t\t\t\tt = rotl(t, sl[i]);\n\t\t\t\t\tt = t + el | 0;\n\t\t\t\t\tal = el;\n\t\t\t\t\tel = dl;\n\t\t\t\t\tdl = rotl(cl, 10);\n\t\t\t\t\tcl = bl;\n\t\t\t\t\tbl = t;\n\n\t\t\t\t\tt = ar + M[offset + zr[i]] | 0;\n\t\t\t\t\tif (i < 16) {\n\t\t\t\t\t\tt += f5(br, cr, dr) + hr[0];\n\t\t\t\t\t} else if (i < 32) {\n\t\t\t\t\t\tt += f4(br, cr, dr) + hr[1];\n\t\t\t\t\t} else if (i < 48) {\n\t\t\t\t\t\tt += f3(br, cr, dr) + hr[2];\n\t\t\t\t\t} else if (i < 64) {\n\t\t\t\t\t\tt += f2(br, cr, dr) + hr[3];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if (i<80) {\n\t\t\t\t\t\tt += f1(br, cr, dr) + hr[4];\n\t\t\t\t\t}\n\t\t\t\t\tt = t | 0;\n\t\t\t\t\tt = rotl(t, sr[i]);\n\t\t\t\t\tt = t + er | 0;\n\t\t\t\t\tar = er;\n\t\t\t\t\ter = dr;\n\t\t\t\t\tdr = rotl(cr, 10);\n\t\t\t\t\tcr = br;\n\t\t\t\t\tbr = t;\n\t\t\t\t}\n\t\t\t\t// Intermediate hash value\n\t\t\t\tt = H[1] + cl + dr | 0;\n\t\t\t\tH[1] = H[2] + dl + er | 0;\n\t\t\t\tH[2] = H[3] + el + ar | 0;\n\t\t\t\tH[3] = H[4] + al + br | 0;\n\t\t\t\tH[4] = H[0] + bl + cr | 0;\n\t\t\t\tH[0] = t;\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar data = this._data;\n\t\t\t\tvar dataWords = data.words;\n\n\t\t\t\tvar nBitsTotal = this._nDataBytes * 8;\n\t\t\t\tvar nBitsLeft = data.sigBytes * 8;\n\n\t\t\t\t// Add padding\n\t\t\t\tdataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n\t\t\t\tdataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 0x00ff00ff | (nBitsTotal << 24 | nBitsTotal >>> 8) & 0xff00ff00;\n\t\t\t\tdata.sigBytes = (dataWords.length + 1) * 4;\n\n\t\t\t\t// Hash final blocks\n\t\t\t\tthis._process();\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar hash = this._hash;\n\t\t\t\tvar H = hash.words;\n\n\t\t\t\t// Swap endian\n\t\t\t\tfor (var i = 0; i < 5; i++) {\n\t\t\t\t\t// Shortcut\n\t\t\t\t\tvar H_i = H[i];\n\n\t\t\t\t\t// Swap\n\t\t\t\t\tH[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;\n\t\t\t\t}\n\n\t\t\t\t// Return final computed hash\n\t\t\t\treturn hash;\n\t\t\t},\n\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Hasher.clone.call(this);\n\t\t\t\tclone._hash = this._hash.clone();\n\n\t\t\t\treturn clone;\n\t\t\t}\n\t\t});\n\n\t\tfunction f1(x, y, z) {\n\t\t\treturn x ^ y ^ z;\n\t\t}\n\n\t\tfunction f2(x, y, z) {\n\t\t\treturn x & y | ~x & z;\n\t\t}\n\n\t\tfunction f3(x, y, z) {\n\t\t\treturn (x | ~y) ^ z;\n\t\t}\n\n\t\tfunction f4(x, y, z) {\n\t\t\treturn x & z | y & ~z;\n\t\t}\n\n\t\tfunction f5(x, y, z) {\n\t\t\treturn x ^ (y | ~z);\n\t\t}\n\n\t\tfunction rotl(x, n) {\n\t\t\treturn x << n | x >>> 32 - n;\n\t\t}\n\n\t\t/**\n   * Shortcut function to the hasher\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hash = CryptoJS.RIPEMD160(\'message\');\n   *     var hash = CryptoJS.RIPEMD160(wordArray);\n   */\n\t\tC.RIPEMD160 = Hasher._createHelper(RIPEMD160);\n\n\t\t/**\n   * Shortcut function to the HMAC\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n   */\n\t\tC.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);\n\t})(Math);\n\n\treturn CryptoJS.RIPEMD160;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/ripemd160.js?'
                );
              },
            './node_modules/crypto-js/sha1.js':
              /*!****************************************!*\
        !*** ./node_modules/crypto-js/sha1.js ***!
        \****************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar Hasher = C_lib.Hasher;\n\t\tvar C_algo = C.algo;\n\n\t\t// Reusable object\n\t\tvar W = [];\n\n\t\t/**\n   * SHA-1 hash algorithm.\n   */\n\t\tvar SHA1 = C_algo.SHA1 = Hasher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\tthis._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar H = this._hash.words;\n\n\t\t\t\t// Working variables\n\t\t\t\tvar a = H[0];\n\t\t\t\tvar b = H[1];\n\t\t\t\tvar c = H[2];\n\t\t\t\tvar d = H[3];\n\t\t\t\tvar e = H[4];\n\n\t\t\t\t// Computation\n\t\t\t\tfor (var i = 0; i < 80; i++) {\n\t\t\t\t\tif (i < 16) {\n\t\t\t\t\t\tW[i] = M[offset + i] | 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n\t\t\t\t\t\tW[i] = n << 1 | n >>> 31;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar t = (a << 5 | a >>> 27) + e + W[i];\n\t\t\t\t\tif (i < 20) {\n\t\t\t\t\t\tt += (b & c | ~b & d) + 0x5a827999;\n\t\t\t\t\t} else if (i < 40) {\n\t\t\t\t\t\tt += (b ^ c ^ d) + 0x6ed9eba1;\n\t\t\t\t\t} else if (i < 60) {\n\t\t\t\t\t\tt += (b & c | b & d | c & d) - 0x70e44324;\n\t\t\t\t\t} else /* if (i < 80) */{\n\t\t\t\t\t\t\tt += (b ^ c ^ d) - 0x359d3e2a;\n\t\t\t\t\t\t}\n\n\t\t\t\t\te = d;\n\t\t\t\t\td = c;\n\t\t\t\t\tc = b << 30 | b >>> 2;\n\t\t\t\t\tb = a;\n\t\t\t\t\ta = t;\n\t\t\t\t}\n\n\t\t\t\t// Intermediate hash value\n\t\t\t\tH[0] = H[0] + a | 0;\n\t\t\t\tH[1] = H[1] + b | 0;\n\t\t\t\tH[2] = H[2] + c | 0;\n\t\t\t\tH[3] = H[3] + d | 0;\n\t\t\t\tH[4] = H[4] + e | 0;\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar data = this._data;\n\t\t\t\tvar dataWords = data.words;\n\n\t\t\t\tvar nBitsTotal = this._nDataBytes * 8;\n\t\t\t\tvar nBitsLeft = data.sigBytes * 8;\n\n\t\t\t\t// Add padding\n\t\t\t\tdataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n\t\t\t\tdataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t\t\t\tdataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n\t\t\t\tdata.sigBytes = dataWords.length * 4;\n\n\t\t\t\t// Hash final blocks\n\t\t\t\tthis._process();\n\n\t\t\t\t// Return final computed hash\n\t\t\t\treturn this._hash;\n\t\t\t},\n\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Hasher.clone.call(this);\n\t\t\t\tclone._hash = this._hash.clone();\n\n\t\t\t\treturn clone;\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Shortcut function to the hasher's object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hash = CryptoJS.SHA1('message');\n   *     var hash = CryptoJS.SHA1(wordArray);\n   */\n\t\tC.SHA1 = Hasher._createHelper(SHA1);\n\n\t\t/**\n   * Shortcut function to the HMAC's object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hmac = CryptoJS.HmacSHA1(message, key);\n   */\n\t\tC.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n\t})();\n\n\treturn CryptoJS.SHA1;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/sha1.js?"
                );
              },
            './node_modules/crypto-js/sha224.js':
              /*!******************************************!*\
        !*** ./node_modules/crypto-js/sha224.js ***!
        \******************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar C_algo = C.algo;\n\t\tvar SHA256 = C_algo.SHA256;\n\n\t\t/**\n   * SHA-224 hash algorithm.\n   */\n\t\tvar SHA224 = C_algo.SHA224 = SHA256.extend({\n\t\t\t_doReset: function () {\n\t\t\t\tthis._hash = new WordArray.init([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\tvar hash = SHA256._doFinalize.call(this);\n\n\t\t\t\thash.sigBytes -= 4;\n\n\t\t\t\treturn hash;\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Shortcut function to the hasher\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hash = CryptoJS.SHA224(\'message\');\n   *     var hash = CryptoJS.SHA224(wordArray);\n   */\n\t\tC.SHA224 = SHA256._createHelper(SHA224);\n\n\t\t/**\n   * Shortcut function to the HMAC\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hmac = CryptoJS.HmacSHA224(message, key);\n   */\n\t\tC.HmacSHA224 = SHA256._createHmacHelper(SHA224);\n\t})();\n\n\treturn CryptoJS.SHA224;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/sha224.js?'
                );
              },
            './node_modules/crypto-js/sha256.js':
              /*!******************************************!*\
        !*** ./node_modules/crypto-js/sha256.js ***!
        \******************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar Hasher = C_lib.Hasher;\n\t\tvar C_algo = C.algo;\n\n\t\t// Initialization and round constants tables\n\t\tvar H = [];\n\t\tvar K = [];\n\n\t\t// Compute constants\n\t\t(function () {\n\t\t\tfunction isPrime(n) {\n\t\t\t\tvar sqrtN = Math.sqrt(n);\n\t\t\t\tfor (var factor = 2; factor <= sqrtN; factor++) {\n\t\t\t\t\tif (!(n % factor)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction getFractionalBits(n) {\n\t\t\t\treturn (n - (n | 0)) * 0x100000000 | 0;\n\t\t\t}\n\n\t\t\tvar n = 2;\n\t\t\tvar nPrime = 0;\n\t\t\twhile (nPrime < 64) {\n\t\t\t\tif (isPrime(n)) {\n\t\t\t\t\tif (nPrime < 8) {\n\t\t\t\t\t\tH[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t\t\t\t\t}\n\t\t\t\t\tK[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t\t\t\t\tnPrime++;\n\t\t\t\t}\n\n\t\t\t\tn++;\n\t\t\t}\n\t\t})();\n\n\t\t// Reusable object\n\t\tvar W = [];\n\n\t\t/**\n   * SHA-256 hash algorithm.\n   */\n\t\tvar SHA256 = C_algo.SHA256 = Hasher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\tthis._hash = new WordArray.init(H.slice(0));\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\t\t\t\t// Shortcut\n\t\t\t\tvar H = this._hash.words;\n\n\t\t\t\t// Working variables\n\t\t\t\tvar a = H[0];\n\t\t\t\tvar b = H[1];\n\t\t\t\tvar c = H[2];\n\t\t\t\tvar d = H[3];\n\t\t\t\tvar e = H[4];\n\t\t\t\tvar f = H[5];\n\t\t\t\tvar g = H[6];\n\t\t\t\tvar h = H[7];\n\n\t\t\t\t// Computation\n\t\t\t\tfor (var i = 0; i < 64; i++) {\n\t\t\t\t\tif (i < 16) {\n\t\t\t\t\t\tW[i] = M[offset + i] | 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar gamma0x = W[i - 15];\n\t\t\t\t\t\tvar gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n\n\t\t\t\t\t\tvar gamma1x = W[i - 2];\n\t\t\t\t\t\tvar gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n\n\t\t\t\t\t\tW[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t\t\t\t\t}\n\n\t\t\t\t\tvar ch = e & f ^ ~e & g;\n\t\t\t\t\tvar maj = a & b ^ a & c ^ b & c;\n\n\t\t\t\t\tvar sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n\t\t\t\t\tvar sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n\n\t\t\t\t\tvar t1 = h + sigma1 + ch + K[i] + W[i];\n\t\t\t\t\tvar t2 = sigma0 + maj;\n\n\t\t\t\t\th = g;\n\t\t\t\t\tg = f;\n\t\t\t\t\tf = e;\n\t\t\t\t\te = d + t1 | 0;\n\t\t\t\t\td = c;\n\t\t\t\t\tc = b;\n\t\t\t\t\tb = a;\n\t\t\t\t\ta = t1 + t2 | 0;\n\t\t\t\t}\n\n\t\t\t\t// Intermediate hash value\n\t\t\t\tH[0] = H[0] + a | 0;\n\t\t\t\tH[1] = H[1] + b | 0;\n\t\t\t\tH[2] = H[2] + c | 0;\n\t\t\t\tH[3] = H[3] + d | 0;\n\t\t\t\tH[4] = H[4] + e | 0;\n\t\t\t\tH[5] = H[5] + f | 0;\n\t\t\t\tH[6] = H[6] + g | 0;\n\t\t\t\tH[7] = H[7] + h | 0;\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar data = this._data;\n\t\t\t\tvar dataWords = data.words;\n\n\t\t\t\tvar nBitsTotal = this._nDataBytes * 8;\n\t\t\t\tvar nBitsLeft = data.sigBytes * 8;\n\n\t\t\t\t// Add padding\n\t\t\t\tdataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n\t\t\t\tdataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t\t\t\tdataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n\t\t\t\tdata.sigBytes = dataWords.length * 4;\n\n\t\t\t\t// Hash final blocks\n\t\t\t\tthis._process();\n\n\t\t\t\t// Return final computed hash\n\t\t\t\treturn this._hash;\n\t\t\t},\n\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Hasher.clone.call(this);\n\t\t\t\tclone._hash = this._hash.clone();\n\n\t\t\t\treturn clone;\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Shortcut function to the hasher's object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hash = CryptoJS.SHA256('message');\n   *     var hash = CryptoJS.SHA256(wordArray);\n   */\n\t\tC.SHA256 = Hasher._createHelper(SHA256);\n\n\t\t/**\n   * Shortcut function to the HMAC's object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hmac = CryptoJS.HmacSHA256(message, key);\n   */\n\t\tC.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t})(Math);\n\n\treturn CryptoJS.SHA256;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/sha256.js?"
                );
              },
            './node_modules/crypto-js/sha3.js':
              /*!****************************************!*\
        !*** ./node_modules/crypto-js/sha3.js ***!
        \****************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar Hasher = C_lib.Hasher;\n\t\tvar C_x64 = C.x64;\n\t\tvar X64Word = C_x64.Word;\n\t\tvar C_algo = C.algo;\n\n\t\t// Constants tables\n\t\tvar RHO_OFFSETS = [];\n\t\tvar PI_INDEXES = [];\n\t\tvar ROUND_CONSTANTS = [];\n\n\t\t// Compute Constants\n\t\t(function () {\n\t\t\t// Compute rho offset constants\n\t\t\tvar x = 1,\n\t\t\t    y = 0;\n\t\t\tfor (var t = 0; t < 24; t++) {\n\t\t\t\tRHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;\n\n\t\t\t\tvar newX = y % 5;\n\t\t\t\tvar newY = (2 * x + 3 * y) % 5;\n\t\t\t\tx = newX;\n\t\t\t\ty = newY;\n\t\t\t}\n\n\t\t\t// Compute pi index constants\n\t\t\tfor (var x = 0; x < 5; x++) {\n\t\t\t\tfor (var y = 0; y < 5; y++) {\n\t\t\t\t\tPI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Compute round constants\n\t\t\tvar LFSR = 0x01;\n\t\t\tfor (var i = 0; i < 24; i++) {\n\t\t\t\tvar roundConstantMsw = 0;\n\t\t\t\tvar roundConstantLsw = 0;\n\n\t\t\t\tfor (var j = 0; j < 7; j++) {\n\t\t\t\t\tif (LFSR & 0x01) {\n\t\t\t\t\t\tvar bitPosition = (1 << j) - 1;\n\t\t\t\t\t\tif (bitPosition < 32) {\n\t\t\t\t\t\t\troundConstantLsw ^= 1 << bitPosition;\n\t\t\t\t\t\t} else /* if (bitPosition >= 32) */{\n\t\t\t\t\t\t\t\troundConstantMsw ^= 1 << bitPosition - 32;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Compute next LFSR\n\t\t\t\t\tif (LFSR & 0x80) {\n\t\t\t\t\t\t// Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t\t\t\t\t\tLFSR = LFSR << 1 ^ 0x71;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLFSR <<= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t\t\t}\n\t\t})();\n\n\t\t// Reusable objects for temporary values\n\t\tvar T = [];\n\t\t(function () {\n\t\t\tfor (var i = 0; i < 25; i++) {\n\t\t\t\tT[i] = X64Word.create();\n\t\t\t}\n\t\t})();\n\n\t\t/**\n   * SHA-3 hash algorithm.\n   */\n\t\tvar SHA3 = C_algo.SHA3 = Hasher.extend({\n\t\t\t/**\n    * Configuration options.\n    *\n    * @property {number} outputLength\n    *   The desired number of bits in the output hash.\n    *   Only values permitted are: 224, 256, 384, 512.\n    *   Default: 512\n    */\n\t\t\tcfg: Hasher.cfg.extend({\n\t\t\t\toutputLength: 512\n\t\t\t}),\n\n\t\t\t_doReset: function () {\n\t\t\t\tvar state = this._state = [];\n\t\t\t\tfor (var i = 0; i < 25; i++) {\n\t\t\t\t\tstate[i] = new X64Word.init();\n\t\t\t\t}\n\n\t\t\t\tthis.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar state = this._state;\n\t\t\t\tvar nBlockSizeLanes = this.blockSize / 2;\n\n\t\t\t\t// Absorb\n\t\t\t\tfor (var i = 0; i < nBlockSizeLanes; i++) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar M2i = M[offset + 2 * i];\n\t\t\t\t\tvar M2i1 = M[offset + 2 * i + 1];\n\n\t\t\t\t\t// Swap endian\n\t\t\t\t\tM2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;\n\t\t\t\t\tM2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00;\n\n\t\t\t\t\t// Absorb message into state\n\t\t\t\t\tvar lane = state[i];\n\t\t\t\t\tlane.high ^= M2i1;\n\t\t\t\t\tlane.low ^= M2i;\n\t\t\t\t}\n\n\t\t\t\t// Rounds\n\t\t\t\tfor (var round = 0; round < 24; round++) {\n\t\t\t\t\t// Theta\n\t\t\t\t\tfor (var x = 0; x < 5; x++) {\n\t\t\t\t\t\t// Mix column lanes\n\t\t\t\t\t\tvar tMsw = 0,\n\t\t\t\t\t\t    tLsw = 0;\n\t\t\t\t\t\tfor (var y = 0; y < 5; y++) {\n\t\t\t\t\t\t\tvar lane = state[x + 5 * y];\n\t\t\t\t\t\t\ttMsw ^= lane.high;\n\t\t\t\t\t\t\ttLsw ^= lane.low;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Temporary values\n\t\t\t\t\t\tvar Tx = T[x];\n\t\t\t\t\t\tTx.high = tMsw;\n\t\t\t\t\t\tTx.low = tLsw;\n\t\t\t\t\t}\n\t\t\t\t\tfor (var x = 0; x < 5; x++) {\n\t\t\t\t\t\t// Shortcuts\n\t\t\t\t\t\tvar Tx4 = T[(x + 4) % 5];\n\t\t\t\t\t\tvar Tx1 = T[(x + 1) % 5];\n\t\t\t\t\t\tvar Tx1Msw = Tx1.high;\n\t\t\t\t\t\tvar Tx1Lsw = Tx1.low;\n\n\t\t\t\t\t\t// Mix surrounding columns\n\t\t\t\t\t\tvar tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);\n\t\t\t\t\t\tvar tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);\n\t\t\t\t\t\tfor (var y = 0; y < 5; y++) {\n\t\t\t\t\t\t\tvar lane = state[x + 5 * y];\n\t\t\t\t\t\t\tlane.high ^= tMsw;\n\t\t\t\t\t\t\tlane.low ^= tLsw;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Rho Pi\n\t\t\t\t\tfor (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t\t\t\t\t\t// Shortcuts\n\t\t\t\t\t\tvar lane = state[laneIndex];\n\t\t\t\t\t\tvar laneMsw = lane.high;\n\t\t\t\t\t\tvar laneLsw = lane.low;\n\t\t\t\t\t\tvar rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t\t\t\t\t\t// Rotate lanes\n\t\t\t\t\t\tif (rhoOffset < 32) {\n\t\t\t\t\t\t\tvar tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;\n\t\t\t\t\t\t\tvar tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;\n\t\t\t\t\t\t} else /* if (rhoOffset >= 32) */{\n\t\t\t\t\t\t\t\tvar tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;\n\t\t\t\t\t\t\t\tvar tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Transpose lanes\n\t\t\t\t\t\tvar TPiLane = T[PI_INDEXES[laneIndex]];\n\t\t\t\t\t\tTPiLane.high = tMsw;\n\t\t\t\t\t\tTPiLane.low = tLsw;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Rho pi at x = y = 0\n\t\t\t\t\tvar T0 = T[0];\n\t\t\t\t\tvar state0 = state[0];\n\t\t\t\t\tT0.high = state0.high;\n\t\t\t\t\tT0.low = state0.low;\n\n\t\t\t\t\t// Chi\n\t\t\t\t\tfor (var x = 0; x < 5; x++) {\n\t\t\t\t\t\tfor (var y = 0; y < 5; y++) {\n\t\t\t\t\t\t\t// Shortcuts\n\t\t\t\t\t\t\tvar laneIndex = x + 5 * y;\n\t\t\t\t\t\t\tvar lane = state[laneIndex];\n\t\t\t\t\t\t\tvar TLane = T[laneIndex];\n\t\t\t\t\t\t\tvar Tx1Lane = T[(x + 1) % 5 + 5 * y];\n\t\t\t\t\t\t\tvar Tx2Lane = T[(x + 2) % 5 + 5 * y];\n\n\t\t\t\t\t\t\t// Mix rows\n\t\t\t\t\t\t\tlane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;\n\t\t\t\t\t\t\tlane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Iota\n\t\t\t\t\tvar lane = state[0];\n\t\t\t\t\tvar roundConstant = ROUND_CONSTANTS[round];\n\t\t\t\t\tlane.high ^= roundConstant.high;\n\t\t\t\t\tlane.low ^= roundConstant.low;;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar data = this._data;\n\t\t\t\tvar dataWords = data.words;\n\t\t\t\tvar nBitsTotal = this._nDataBytes * 8;\n\t\t\t\tvar nBitsLeft = data.sigBytes * 8;\n\t\t\t\tvar blockSizeBits = this.blockSize * 32;\n\n\t\t\t\t// Add padding\n\t\t\t\tdataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;\n\t\t\t\tdataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;\n\t\t\t\tdata.sigBytes = dataWords.length * 4;\n\n\t\t\t\t// Hash final blocks\n\t\t\t\tthis._process();\n\n\t\t\t\t// Shortcuts\n\t\t\t\tvar state = this._state;\n\t\t\t\tvar outputLengthBytes = this.cfg.outputLength / 8;\n\t\t\t\tvar outputLengthLanes = outputLengthBytes / 8;\n\n\t\t\t\t// Squeeze\n\t\t\t\tvar hashWords = [];\n\t\t\t\tfor (var i = 0; i < outputLengthLanes; i++) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar lane = state[i];\n\t\t\t\t\tvar laneMsw = lane.high;\n\t\t\t\t\tvar laneLsw = lane.low;\n\n\t\t\t\t\t// Swap endian\n\t\t\t\t\tlaneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;\n\t\t\t\t\tlaneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00;\n\n\t\t\t\t\t// Squeeze state to retrieve hash\n\t\t\t\t\thashWords.push(laneLsw);\n\t\t\t\t\thashWords.push(laneMsw);\n\t\t\t\t}\n\n\t\t\t\t// Return final computed hash\n\t\t\t\treturn new WordArray.init(hashWords, outputLengthBytes);\n\t\t\t},\n\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Hasher.clone.call(this);\n\n\t\t\t\tvar state = clone._state = this._state.slice(0);\n\t\t\t\tfor (var i = 0; i < 25; i++) {\n\t\t\t\t\tstate[i] = state[i].clone();\n\t\t\t\t}\n\n\t\t\t\treturn clone;\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Shortcut function to the hasher\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hash = CryptoJS.SHA3(\'message\');\n   *     var hash = CryptoJS.SHA3(wordArray);\n   */\n\t\tC.SHA3 = Hasher._createHelper(SHA3);\n\n\t\t/**\n   * Shortcut function to the HMAC\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hmac = CryptoJS.HmacSHA3(message, key);\n   */\n\t\tC.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t})(Math);\n\n\treturn CryptoJS.SHA3;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/sha3.js?'
                );
              },
            './node_modules/crypto-js/sha384.js':
              /*!******************************************!*\
        !*** ./node_modules/crypto-js/sha384.js ***!
        \******************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"), __webpack_require__(/*! ./sha512 */ "./node_modules/crypto-js/sha512.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_x64 = C.x64;\n\t\tvar X64Word = C_x64.Word;\n\t\tvar X64WordArray = C_x64.WordArray;\n\t\tvar C_algo = C.algo;\n\t\tvar SHA512 = C_algo.SHA512;\n\n\t\t/**\n   * SHA-384 hash algorithm.\n   */\n\t\tvar SHA384 = C_algo.SHA384 = SHA512.extend({\n\t\t\t_doReset: function () {\n\t\t\t\tthis._hash = new X64WordArray.init([new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507), new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939), new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511), new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)]);\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\tvar hash = SHA512._doFinalize.call(this);\n\n\t\t\t\thash.sigBytes -= 16;\n\n\t\t\t\treturn hash;\n\t\t\t}\n\t\t});\n\n\t\t/**\n   * Shortcut function to the hasher\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hash = CryptoJS.SHA384(\'message\');\n   *     var hash = CryptoJS.SHA384(wordArray);\n   */\n\t\tC.SHA384 = SHA512._createHelper(SHA384);\n\n\t\t/**\n   * Shortcut function to the HMAC\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hmac = CryptoJS.HmacSHA384(message, key);\n   */\n\t\tC.HmacSHA384 = SHA512._createHmacHelper(SHA384);\n\t})();\n\n\treturn CryptoJS.SHA384;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/sha384.js?'
                );
              },
            './node_modules/crypto-js/sha512.js':
              /*!******************************************!*\
        !*** ./node_modules/crypto-js/sha512.js ***!
        \******************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar Hasher = C_lib.Hasher;\n\t\tvar C_x64 = C.x64;\n\t\tvar X64Word = C_x64.Word;\n\t\tvar X64WordArray = C_x64.WordArray;\n\t\tvar C_algo = C.algo;\n\n\t\tfunction X64Word_create() {\n\t\t\treturn X64Word.create.apply(X64Word, arguments);\n\t\t}\n\n\t\t// Constants\n\t\tvar K = [X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd), X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc), X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019), X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118), X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe), X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2), X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1), X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694), X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3), X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65), X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483), X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5), X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210), X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4), X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725), X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70), X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926), X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df), X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8), X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b), X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001), X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30), X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910), X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8), X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53), X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8), X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb), X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3), X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60), X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec), X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9), X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b), X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207), X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178), X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6), X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b), X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493), X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c), X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a), X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)];\n\n\t\t// Reusable objects\n\t\tvar W = [];\n\t\t(function () {\n\t\t\tfor (var i = 0; i < 80; i++) {\n\t\t\t\tW[i] = X64Word_create();\n\t\t\t}\n\t\t})();\n\n\t\t/**\n   * SHA-512 hash algorithm.\n   */\n\t\tvar SHA512 = C_algo.SHA512 = Hasher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\tthis._hash = new X64WordArray.init([new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b), new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1), new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f), new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)]);\n\t\t\t},\n\n\t\t\t_doProcessBlock: function (M, offset) {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar H = this._hash.words;\n\n\t\t\t\tvar H0 = H[0];\n\t\t\t\tvar H1 = H[1];\n\t\t\t\tvar H2 = H[2];\n\t\t\t\tvar H3 = H[3];\n\t\t\t\tvar H4 = H[4];\n\t\t\t\tvar H5 = H[5];\n\t\t\t\tvar H6 = H[6];\n\t\t\t\tvar H7 = H[7];\n\n\t\t\t\tvar H0h = H0.high;\n\t\t\t\tvar H0l = H0.low;\n\t\t\t\tvar H1h = H1.high;\n\t\t\t\tvar H1l = H1.low;\n\t\t\t\tvar H2h = H2.high;\n\t\t\t\tvar H2l = H2.low;\n\t\t\t\tvar H3h = H3.high;\n\t\t\t\tvar H3l = H3.low;\n\t\t\t\tvar H4h = H4.high;\n\t\t\t\tvar H4l = H4.low;\n\t\t\t\tvar H5h = H5.high;\n\t\t\t\tvar H5l = H5.low;\n\t\t\t\tvar H6h = H6.high;\n\t\t\t\tvar H6l = H6.low;\n\t\t\t\tvar H7h = H7.high;\n\t\t\t\tvar H7l = H7.low;\n\n\t\t\t\t// Working variables\n\t\t\t\tvar ah = H0h;\n\t\t\t\tvar al = H0l;\n\t\t\t\tvar bh = H1h;\n\t\t\t\tvar bl = H1l;\n\t\t\t\tvar ch = H2h;\n\t\t\t\tvar cl = H2l;\n\t\t\t\tvar dh = H3h;\n\t\t\t\tvar dl = H3l;\n\t\t\t\tvar eh = H4h;\n\t\t\t\tvar el = H4l;\n\t\t\t\tvar fh = H5h;\n\t\t\t\tvar fl = H5l;\n\t\t\t\tvar gh = H6h;\n\t\t\t\tvar gl = H6l;\n\t\t\t\tvar hh = H7h;\n\t\t\t\tvar hl = H7l;\n\n\t\t\t\t// Rounds\n\t\t\t\tfor (var i = 0; i < 80; i++) {\n\t\t\t\t\t// Shortcut\n\t\t\t\t\tvar Wi = W[i];\n\n\t\t\t\t\t// Extend message\n\t\t\t\t\tif (i < 16) {\n\t\t\t\t\t\tvar Wih = Wi.high = M[offset + i * 2] | 0;\n\t\t\t\t\t\tvar Wil = Wi.low = M[offset + i * 2 + 1] | 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Gamma0\n\t\t\t\t\t\tvar gamma0x = W[i - 15];\n\t\t\t\t\t\tvar gamma0xh = gamma0x.high;\n\t\t\t\t\t\tvar gamma0xl = gamma0x.low;\n\t\t\t\t\t\tvar gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;\n\t\t\t\t\t\tvar gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);\n\n\t\t\t\t\t\t// Gamma1\n\t\t\t\t\t\tvar gamma1x = W[i - 2];\n\t\t\t\t\t\tvar gamma1xh = gamma1x.high;\n\t\t\t\t\t\tvar gamma1xl = gamma1x.low;\n\t\t\t\t\t\tvar gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;\n\t\t\t\t\t\tvar gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);\n\n\t\t\t\t\t\t// W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n\t\t\t\t\t\tvar Wi7 = W[i - 7];\n\t\t\t\t\t\tvar Wi7h = Wi7.high;\n\t\t\t\t\t\tvar Wi7l = Wi7.low;\n\n\t\t\t\t\t\tvar Wi16 = W[i - 16];\n\t\t\t\t\t\tvar Wi16h = Wi16.high;\n\t\t\t\t\t\tvar Wi16l = Wi16.low;\n\n\t\t\t\t\t\tvar Wil = gamma0l + Wi7l;\n\t\t\t\t\t\tvar Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);\n\t\t\t\t\t\tvar Wil = Wil + gamma1l;\n\t\t\t\t\t\tvar Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);\n\t\t\t\t\t\tvar Wil = Wil + Wi16l;\n\t\t\t\t\t\tvar Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);\n\n\t\t\t\t\t\tWi.high = Wih;\n\t\t\t\t\t\tWi.low = Wil;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar chh = eh & fh ^ ~eh & gh;\n\t\t\t\t\tvar chl = el & fl ^ ~el & gl;\n\t\t\t\t\tvar majh = ah & bh ^ ah & ch ^ bh & ch;\n\t\t\t\t\tvar majl = al & bl ^ al & cl ^ bl & cl;\n\n\t\t\t\t\tvar sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);\n\t\t\t\t\tvar sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);\n\t\t\t\t\tvar sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);\n\t\t\t\t\tvar sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);\n\n\t\t\t\t\t// t1 = h + sigma1 + ch + K[i] + W[i]\n\t\t\t\t\tvar Ki = K[i];\n\t\t\t\t\tvar Kih = Ki.high;\n\t\t\t\t\tvar Kil = Ki.low;\n\n\t\t\t\t\tvar t1l = hl + sigma1l;\n\t\t\t\t\tvar t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);\n\t\t\t\t\tvar t1l = t1l + chl;\n\t\t\t\t\tvar t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);\n\t\t\t\t\tvar t1l = t1l + Kil;\n\t\t\t\t\tvar t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);\n\t\t\t\t\tvar t1l = t1l + Wil;\n\t\t\t\t\tvar t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);\n\n\t\t\t\t\t// t2 = sigma0 + maj\n\t\t\t\t\tvar t2l = sigma0l + majl;\n\t\t\t\t\tvar t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);\n\n\t\t\t\t\t// Update working variables\n\t\t\t\t\thh = gh;\n\t\t\t\t\thl = gl;\n\t\t\t\t\tgh = fh;\n\t\t\t\t\tgl = fl;\n\t\t\t\t\tfh = eh;\n\t\t\t\t\tfl = el;\n\t\t\t\t\tel = dl + t1l | 0;\n\t\t\t\t\teh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;\n\t\t\t\t\tdh = ch;\n\t\t\t\t\tdl = cl;\n\t\t\t\t\tch = bh;\n\t\t\t\t\tcl = bl;\n\t\t\t\t\tbh = ah;\n\t\t\t\t\tbl = al;\n\t\t\t\t\tal = t1l + t2l | 0;\n\t\t\t\t\tah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;\n\t\t\t\t}\n\n\t\t\t\t// Intermediate hash value\n\t\t\t\tH0l = H0.low = H0l + al;\n\t\t\t\tH0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);\n\t\t\t\tH1l = H1.low = H1l + bl;\n\t\t\t\tH1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);\n\t\t\t\tH2l = H2.low = H2l + cl;\n\t\t\t\tH2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);\n\t\t\t\tH3l = H3.low = H3l + dl;\n\t\t\t\tH3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);\n\t\t\t\tH4l = H4.low = H4l + el;\n\t\t\t\tH4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);\n\t\t\t\tH5l = H5.low = H5l + fl;\n\t\t\t\tH5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);\n\t\t\t\tH6l = H6.low = H6l + gl;\n\t\t\t\tH6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);\n\t\t\t\tH7l = H7.low = H7l + hl;\n\t\t\t\tH7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);\n\t\t\t},\n\n\t\t\t_doFinalize: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar data = this._data;\n\t\t\t\tvar dataWords = data.words;\n\n\t\t\t\tvar nBitsTotal = this._nDataBytes * 8;\n\t\t\t\tvar nBitsLeft = data.sigBytes * 8;\n\n\t\t\t\t// Add padding\n\t\t\t\tdataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n\t\t\t\tdataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n\t\t\t\tdataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;\n\t\t\t\tdata.sigBytes = dataWords.length * 4;\n\n\t\t\t\t// Hash final blocks\n\t\t\t\tthis._process();\n\n\t\t\t\t// Convert hash to 32-bit word array before returning\n\t\t\t\tvar hash = this._hash.toX32();\n\n\t\t\t\t// Return final computed hash\n\t\t\t\treturn hash;\n\t\t\t},\n\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Hasher.clone.call(this);\n\t\t\t\tclone._hash = this._hash.clone();\n\n\t\t\t\treturn clone;\n\t\t\t},\n\n\t\t\tblockSize: 1024 / 32\n\t\t});\n\n\t\t/**\n   * Shortcut function to the hasher\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hash = CryptoJS.SHA512(\'message\');\n   *     var hash = CryptoJS.SHA512(wordArray);\n   */\n\t\tC.SHA512 = Hasher._createHelper(SHA512);\n\n\t\t/**\n   * Shortcut function to the HMAC\'s object interface.\n   *\n   * @param {WordArray|string} message The message to hash.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hmac = CryptoJS.HmacSHA512(message, key);\n   */\n\t\tC.HmacSHA512 = Hasher._createHmacHelper(SHA512);\n\t})();\n\n\treturn CryptoJS.SHA512;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/sha512.js?'
                );
              },
            './node_modules/crypto-js/tripledes.js':
              /*!*********************************************!*\
        !*** ./node_modules/crypto-js/tripledes.js ***!
        \*********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function () {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar WordArray = C_lib.WordArray;\n\t\tvar BlockCipher = C_lib.BlockCipher;\n\t\tvar C_algo = C.algo;\n\n\t\t// Permuted Choice 1 constants\n\t\tvar PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4];\n\n\t\t// Permuted Choice 2 constants\n\t\tvar PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32];\n\n\t\t// Cumulative bit shift constants\n\t\tvar BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\n\n\t\t// SBOXes and round permutation constants\n\t\tvar SBOX_P = [{\n\t\t\t0x0: 0x808200,\n\t\t\t0x10000000: 0x8000,\n\t\t\t0x20000000: 0x808002,\n\t\t\t0x30000000: 0x2,\n\t\t\t0x40000000: 0x200,\n\t\t\t0x50000000: 0x808202,\n\t\t\t0x60000000: 0x800202,\n\t\t\t0x70000000: 0x800000,\n\t\t\t0x80000000: 0x202,\n\t\t\t0x90000000: 0x800200,\n\t\t\t0xa0000000: 0x8200,\n\t\t\t0xb0000000: 0x808000,\n\t\t\t0xc0000000: 0x8002,\n\t\t\t0xd0000000: 0x800002,\n\t\t\t0xe0000000: 0x0,\n\t\t\t0xf0000000: 0x8202,\n\t\t\t0x8000000: 0x0,\n\t\t\t0x18000000: 0x808202,\n\t\t\t0x28000000: 0x8202,\n\t\t\t0x38000000: 0x8000,\n\t\t\t0x48000000: 0x808200,\n\t\t\t0x58000000: 0x200,\n\t\t\t0x68000000: 0x808002,\n\t\t\t0x78000000: 0x2,\n\t\t\t0x88000000: 0x800200,\n\t\t\t0x98000000: 0x8200,\n\t\t\t0xa8000000: 0x808000,\n\t\t\t0xb8000000: 0x800202,\n\t\t\t0xc8000000: 0x800002,\n\t\t\t0xd8000000: 0x8002,\n\t\t\t0xe8000000: 0x202,\n\t\t\t0xf8000000: 0x800000,\n\t\t\t0x1: 0x8000,\n\t\t\t0x10000001: 0x2,\n\t\t\t0x20000001: 0x808200,\n\t\t\t0x30000001: 0x800000,\n\t\t\t0x40000001: 0x808002,\n\t\t\t0x50000001: 0x8200,\n\t\t\t0x60000001: 0x200,\n\t\t\t0x70000001: 0x800202,\n\t\t\t0x80000001: 0x808202,\n\t\t\t0x90000001: 0x808000,\n\t\t\t0xa0000001: 0x800002,\n\t\t\t0xb0000001: 0x8202,\n\t\t\t0xc0000001: 0x202,\n\t\t\t0xd0000001: 0x800200,\n\t\t\t0xe0000001: 0x8002,\n\t\t\t0xf0000001: 0x0,\n\t\t\t0x8000001: 0x808202,\n\t\t\t0x18000001: 0x808000,\n\t\t\t0x28000001: 0x800000,\n\t\t\t0x38000001: 0x200,\n\t\t\t0x48000001: 0x8000,\n\t\t\t0x58000001: 0x800002,\n\t\t\t0x68000001: 0x2,\n\t\t\t0x78000001: 0x8202,\n\t\t\t0x88000001: 0x8002,\n\t\t\t0x98000001: 0x800202,\n\t\t\t0xa8000001: 0x202,\n\t\t\t0xb8000001: 0x808200,\n\t\t\t0xc8000001: 0x800200,\n\t\t\t0xd8000001: 0x0,\n\t\t\t0xe8000001: 0x8200,\n\t\t\t0xf8000001: 0x808002\n\t\t}, {\n\t\t\t0x0: 0x40084010,\n\t\t\t0x1000000: 0x4000,\n\t\t\t0x2000000: 0x80000,\n\t\t\t0x3000000: 0x40080010,\n\t\t\t0x4000000: 0x40000010,\n\t\t\t0x5000000: 0x40084000,\n\t\t\t0x6000000: 0x40004000,\n\t\t\t0x7000000: 0x10,\n\t\t\t0x8000000: 0x84000,\n\t\t\t0x9000000: 0x40004010,\n\t\t\t0xa000000: 0x40000000,\n\t\t\t0xb000000: 0x84010,\n\t\t\t0xc000000: 0x80010,\n\t\t\t0xd000000: 0x0,\n\t\t\t0xe000000: 0x4010,\n\t\t\t0xf000000: 0x40080000,\n\t\t\t0x800000: 0x40004000,\n\t\t\t0x1800000: 0x84010,\n\t\t\t0x2800000: 0x10,\n\t\t\t0x3800000: 0x40004010,\n\t\t\t0x4800000: 0x40084010,\n\t\t\t0x5800000: 0x40000000,\n\t\t\t0x6800000: 0x80000,\n\t\t\t0x7800000: 0x40080010,\n\t\t\t0x8800000: 0x80010,\n\t\t\t0x9800000: 0x0,\n\t\t\t0xa800000: 0x4000,\n\t\t\t0xb800000: 0x40080000,\n\t\t\t0xc800000: 0x40000010,\n\t\t\t0xd800000: 0x84000,\n\t\t\t0xe800000: 0x40084000,\n\t\t\t0xf800000: 0x4010,\n\t\t\t0x10000000: 0x0,\n\t\t\t0x11000000: 0x40080010,\n\t\t\t0x12000000: 0x40004010,\n\t\t\t0x13000000: 0x40084000,\n\t\t\t0x14000000: 0x40080000,\n\t\t\t0x15000000: 0x10,\n\t\t\t0x16000000: 0x84010,\n\t\t\t0x17000000: 0x4000,\n\t\t\t0x18000000: 0x4010,\n\t\t\t0x19000000: 0x80000,\n\t\t\t0x1a000000: 0x80010,\n\t\t\t0x1b000000: 0x40000010,\n\t\t\t0x1c000000: 0x84000,\n\t\t\t0x1d000000: 0x40004000,\n\t\t\t0x1e000000: 0x40000000,\n\t\t\t0x1f000000: 0x40084010,\n\t\t\t0x10800000: 0x84010,\n\t\t\t0x11800000: 0x80000,\n\t\t\t0x12800000: 0x40080000,\n\t\t\t0x13800000: 0x4000,\n\t\t\t0x14800000: 0x40004000,\n\t\t\t0x15800000: 0x40084010,\n\t\t\t0x16800000: 0x10,\n\t\t\t0x17800000: 0x40000000,\n\t\t\t0x18800000: 0x40084000,\n\t\t\t0x19800000: 0x40000010,\n\t\t\t0x1a800000: 0x40004010,\n\t\t\t0x1b800000: 0x80010,\n\t\t\t0x1c800000: 0x0,\n\t\t\t0x1d800000: 0x4010,\n\t\t\t0x1e800000: 0x40080010,\n\t\t\t0x1f800000: 0x84000\n\t\t}, {\n\t\t\t0x0: 0x104,\n\t\t\t0x100000: 0x0,\n\t\t\t0x200000: 0x4000100,\n\t\t\t0x300000: 0x10104,\n\t\t\t0x400000: 0x10004,\n\t\t\t0x500000: 0x4000004,\n\t\t\t0x600000: 0x4010104,\n\t\t\t0x700000: 0x4010000,\n\t\t\t0x800000: 0x4000000,\n\t\t\t0x900000: 0x4010100,\n\t\t\t0xa00000: 0x10100,\n\t\t\t0xb00000: 0x4010004,\n\t\t\t0xc00000: 0x4000104,\n\t\t\t0xd00000: 0x10000,\n\t\t\t0xe00000: 0x4,\n\t\t\t0xf00000: 0x100,\n\t\t\t0x80000: 0x4010100,\n\t\t\t0x180000: 0x4010004,\n\t\t\t0x280000: 0x0,\n\t\t\t0x380000: 0x4000100,\n\t\t\t0x480000: 0x4000004,\n\t\t\t0x580000: 0x10000,\n\t\t\t0x680000: 0x10004,\n\t\t\t0x780000: 0x104,\n\t\t\t0x880000: 0x4,\n\t\t\t0x980000: 0x100,\n\t\t\t0xa80000: 0x4010000,\n\t\t\t0xb80000: 0x10104,\n\t\t\t0xc80000: 0x10100,\n\t\t\t0xd80000: 0x4000104,\n\t\t\t0xe80000: 0x4010104,\n\t\t\t0xf80000: 0x4000000,\n\t\t\t0x1000000: 0x4010100,\n\t\t\t0x1100000: 0x10004,\n\t\t\t0x1200000: 0x10000,\n\t\t\t0x1300000: 0x4000100,\n\t\t\t0x1400000: 0x100,\n\t\t\t0x1500000: 0x4010104,\n\t\t\t0x1600000: 0x4000004,\n\t\t\t0x1700000: 0x0,\n\t\t\t0x1800000: 0x4000104,\n\t\t\t0x1900000: 0x4000000,\n\t\t\t0x1a00000: 0x4,\n\t\t\t0x1b00000: 0x10100,\n\t\t\t0x1c00000: 0x4010000,\n\t\t\t0x1d00000: 0x104,\n\t\t\t0x1e00000: 0x10104,\n\t\t\t0x1f00000: 0x4010004,\n\t\t\t0x1080000: 0x4000000,\n\t\t\t0x1180000: 0x104,\n\t\t\t0x1280000: 0x4010100,\n\t\t\t0x1380000: 0x0,\n\t\t\t0x1480000: 0x10004,\n\t\t\t0x1580000: 0x4000100,\n\t\t\t0x1680000: 0x100,\n\t\t\t0x1780000: 0x4010004,\n\t\t\t0x1880000: 0x10000,\n\t\t\t0x1980000: 0x4010104,\n\t\t\t0x1a80000: 0x10104,\n\t\t\t0x1b80000: 0x4000004,\n\t\t\t0x1c80000: 0x4000104,\n\t\t\t0x1d80000: 0x4010000,\n\t\t\t0x1e80000: 0x4,\n\t\t\t0x1f80000: 0x10100\n\t\t}, {\n\t\t\t0x0: 0x80401000,\n\t\t\t0x10000: 0x80001040,\n\t\t\t0x20000: 0x401040,\n\t\t\t0x30000: 0x80400000,\n\t\t\t0x40000: 0x0,\n\t\t\t0x50000: 0x401000,\n\t\t\t0x60000: 0x80000040,\n\t\t\t0x70000: 0x400040,\n\t\t\t0x80000: 0x80000000,\n\t\t\t0x90000: 0x400000,\n\t\t\t0xa0000: 0x40,\n\t\t\t0xb0000: 0x80001000,\n\t\t\t0xc0000: 0x80400040,\n\t\t\t0xd0000: 0x1040,\n\t\t\t0xe0000: 0x1000,\n\t\t\t0xf0000: 0x80401040,\n\t\t\t0x8000: 0x80001040,\n\t\t\t0x18000: 0x40,\n\t\t\t0x28000: 0x80400040,\n\t\t\t0x38000: 0x80001000,\n\t\t\t0x48000: 0x401000,\n\t\t\t0x58000: 0x80401040,\n\t\t\t0x68000: 0x0,\n\t\t\t0x78000: 0x80400000,\n\t\t\t0x88000: 0x1000,\n\t\t\t0x98000: 0x80401000,\n\t\t\t0xa8000: 0x400000,\n\t\t\t0xb8000: 0x1040,\n\t\t\t0xc8000: 0x80000000,\n\t\t\t0xd8000: 0x400040,\n\t\t\t0xe8000: 0x401040,\n\t\t\t0xf8000: 0x80000040,\n\t\t\t0x100000: 0x400040,\n\t\t\t0x110000: 0x401000,\n\t\t\t0x120000: 0x80000040,\n\t\t\t0x130000: 0x0,\n\t\t\t0x140000: 0x1040,\n\t\t\t0x150000: 0x80400040,\n\t\t\t0x160000: 0x80401000,\n\t\t\t0x170000: 0x80001040,\n\t\t\t0x180000: 0x80401040,\n\t\t\t0x190000: 0x80000000,\n\t\t\t0x1a0000: 0x80400000,\n\t\t\t0x1b0000: 0x401040,\n\t\t\t0x1c0000: 0x80001000,\n\t\t\t0x1d0000: 0x400000,\n\t\t\t0x1e0000: 0x40,\n\t\t\t0x1f0000: 0x1000,\n\t\t\t0x108000: 0x80400000,\n\t\t\t0x118000: 0x80401040,\n\t\t\t0x128000: 0x0,\n\t\t\t0x138000: 0x401000,\n\t\t\t0x148000: 0x400040,\n\t\t\t0x158000: 0x80000000,\n\t\t\t0x168000: 0x80001040,\n\t\t\t0x178000: 0x40,\n\t\t\t0x188000: 0x80000040,\n\t\t\t0x198000: 0x1000,\n\t\t\t0x1a8000: 0x80001000,\n\t\t\t0x1b8000: 0x80400040,\n\t\t\t0x1c8000: 0x1040,\n\t\t\t0x1d8000: 0x80401000,\n\t\t\t0x1e8000: 0x400000,\n\t\t\t0x1f8000: 0x401040\n\t\t}, {\n\t\t\t0x0: 0x80,\n\t\t\t0x1000: 0x1040000,\n\t\t\t0x2000: 0x40000,\n\t\t\t0x3000: 0x20000000,\n\t\t\t0x4000: 0x20040080,\n\t\t\t0x5000: 0x1000080,\n\t\t\t0x6000: 0x21000080,\n\t\t\t0x7000: 0x40080,\n\t\t\t0x8000: 0x1000000,\n\t\t\t0x9000: 0x20040000,\n\t\t\t0xa000: 0x20000080,\n\t\t\t0xb000: 0x21040080,\n\t\t\t0xc000: 0x21040000,\n\t\t\t0xd000: 0x0,\n\t\t\t0xe000: 0x1040080,\n\t\t\t0xf000: 0x21000000,\n\t\t\t0x800: 0x1040080,\n\t\t\t0x1800: 0x21000080,\n\t\t\t0x2800: 0x80,\n\t\t\t0x3800: 0x1040000,\n\t\t\t0x4800: 0x40000,\n\t\t\t0x5800: 0x20040080,\n\t\t\t0x6800: 0x21040000,\n\t\t\t0x7800: 0x20000000,\n\t\t\t0x8800: 0x20040000,\n\t\t\t0x9800: 0x0,\n\t\t\t0xa800: 0x21040080,\n\t\t\t0xb800: 0x1000080,\n\t\t\t0xc800: 0x20000080,\n\t\t\t0xd800: 0x21000000,\n\t\t\t0xe800: 0x1000000,\n\t\t\t0xf800: 0x40080,\n\t\t\t0x10000: 0x40000,\n\t\t\t0x11000: 0x80,\n\t\t\t0x12000: 0x20000000,\n\t\t\t0x13000: 0x21000080,\n\t\t\t0x14000: 0x1000080,\n\t\t\t0x15000: 0x21040000,\n\t\t\t0x16000: 0x20040080,\n\t\t\t0x17000: 0x1000000,\n\t\t\t0x18000: 0x21040080,\n\t\t\t0x19000: 0x21000000,\n\t\t\t0x1a000: 0x1040000,\n\t\t\t0x1b000: 0x20040000,\n\t\t\t0x1c000: 0x40080,\n\t\t\t0x1d000: 0x20000080,\n\t\t\t0x1e000: 0x0,\n\t\t\t0x1f000: 0x1040080,\n\t\t\t0x10800: 0x21000080,\n\t\t\t0x11800: 0x1000000,\n\t\t\t0x12800: 0x1040000,\n\t\t\t0x13800: 0x20040080,\n\t\t\t0x14800: 0x20000000,\n\t\t\t0x15800: 0x1040080,\n\t\t\t0x16800: 0x80,\n\t\t\t0x17800: 0x21040000,\n\t\t\t0x18800: 0x40080,\n\t\t\t0x19800: 0x21040080,\n\t\t\t0x1a800: 0x0,\n\t\t\t0x1b800: 0x21000000,\n\t\t\t0x1c800: 0x1000080,\n\t\t\t0x1d800: 0x40000,\n\t\t\t0x1e800: 0x20040000,\n\t\t\t0x1f800: 0x20000080\n\t\t}, {\n\t\t\t0x0: 0x10000008,\n\t\t\t0x100: 0x2000,\n\t\t\t0x200: 0x10200000,\n\t\t\t0x300: 0x10202008,\n\t\t\t0x400: 0x10002000,\n\t\t\t0x500: 0x200000,\n\t\t\t0x600: 0x200008,\n\t\t\t0x700: 0x10000000,\n\t\t\t0x800: 0x0,\n\t\t\t0x900: 0x10002008,\n\t\t\t0xa00: 0x202000,\n\t\t\t0xb00: 0x8,\n\t\t\t0xc00: 0x10200008,\n\t\t\t0xd00: 0x202008,\n\t\t\t0xe00: 0x2008,\n\t\t\t0xf00: 0x10202000,\n\t\t\t0x80: 0x10200000,\n\t\t\t0x180: 0x10202008,\n\t\t\t0x280: 0x8,\n\t\t\t0x380: 0x200000,\n\t\t\t0x480: 0x202008,\n\t\t\t0x580: 0x10000008,\n\t\t\t0x680: 0x10002000,\n\t\t\t0x780: 0x2008,\n\t\t\t0x880: 0x200008,\n\t\t\t0x980: 0x2000,\n\t\t\t0xa80: 0x10002008,\n\t\t\t0xb80: 0x10200008,\n\t\t\t0xc80: 0x0,\n\t\t\t0xd80: 0x10202000,\n\t\t\t0xe80: 0x202000,\n\t\t\t0xf80: 0x10000000,\n\t\t\t0x1000: 0x10002000,\n\t\t\t0x1100: 0x10200008,\n\t\t\t0x1200: 0x10202008,\n\t\t\t0x1300: 0x2008,\n\t\t\t0x1400: 0x200000,\n\t\t\t0x1500: 0x10000000,\n\t\t\t0x1600: 0x10000008,\n\t\t\t0x1700: 0x202000,\n\t\t\t0x1800: 0x202008,\n\t\t\t0x1900: 0x0,\n\t\t\t0x1a00: 0x8,\n\t\t\t0x1b00: 0x10200000,\n\t\t\t0x1c00: 0x2000,\n\t\t\t0x1d00: 0x10002008,\n\t\t\t0x1e00: 0x10202000,\n\t\t\t0x1f00: 0x200008,\n\t\t\t0x1080: 0x8,\n\t\t\t0x1180: 0x202000,\n\t\t\t0x1280: 0x200000,\n\t\t\t0x1380: 0x10000008,\n\t\t\t0x1480: 0x10002000,\n\t\t\t0x1580: 0x2008,\n\t\t\t0x1680: 0x10202008,\n\t\t\t0x1780: 0x10200000,\n\t\t\t0x1880: 0x10202000,\n\t\t\t0x1980: 0x10200008,\n\t\t\t0x1a80: 0x2000,\n\t\t\t0x1b80: 0x202008,\n\t\t\t0x1c80: 0x200008,\n\t\t\t0x1d80: 0x0,\n\t\t\t0x1e80: 0x10000000,\n\t\t\t0x1f80: 0x10002008\n\t\t}, {\n\t\t\t0x0: 0x100000,\n\t\t\t0x10: 0x2000401,\n\t\t\t0x20: 0x400,\n\t\t\t0x30: 0x100401,\n\t\t\t0x40: 0x2100401,\n\t\t\t0x50: 0x0,\n\t\t\t0x60: 0x1,\n\t\t\t0x70: 0x2100001,\n\t\t\t0x80: 0x2000400,\n\t\t\t0x90: 0x100001,\n\t\t\t0xa0: 0x2000001,\n\t\t\t0xb0: 0x2100400,\n\t\t\t0xc0: 0x2100000,\n\t\t\t0xd0: 0x401,\n\t\t\t0xe0: 0x100400,\n\t\t\t0xf0: 0x2000000,\n\t\t\t0x8: 0x2100001,\n\t\t\t0x18: 0x0,\n\t\t\t0x28: 0x2000401,\n\t\t\t0x38: 0x2100400,\n\t\t\t0x48: 0x100000,\n\t\t\t0x58: 0x2000001,\n\t\t\t0x68: 0x2000000,\n\t\t\t0x78: 0x401,\n\t\t\t0x88: 0x100401,\n\t\t\t0x98: 0x2000400,\n\t\t\t0xa8: 0x2100000,\n\t\t\t0xb8: 0x100001,\n\t\t\t0xc8: 0x400,\n\t\t\t0xd8: 0x2100401,\n\t\t\t0xe8: 0x1,\n\t\t\t0xf8: 0x100400,\n\t\t\t0x100: 0x2000000,\n\t\t\t0x110: 0x100000,\n\t\t\t0x120: 0x2000401,\n\t\t\t0x130: 0x2100001,\n\t\t\t0x140: 0x100001,\n\t\t\t0x150: 0x2000400,\n\t\t\t0x160: 0x2100400,\n\t\t\t0x170: 0x100401,\n\t\t\t0x180: 0x401,\n\t\t\t0x190: 0x2100401,\n\t\t\t0x1a0: 0x100400,\n\t\t\t0x1b0: 0x1,\n\t\t\t0x1c0: 0x0,\n\t\t\t0x1d0: 0x2100000,\n\t\t\t0x1e0: 0x2000001,\n\t\t\t0x1f0: 0x400,\n\t\t\t0x108: 0x100400,\n\t\t\t0x118: 0x2000401,\n\t\t\t0x128: 0x2100001,\n\t\t\t0x138: 0x1,\n\t\t\t0x148: 0x2000000,\n\t\t\t0x158: 0x100000,\n\t\t\t0x168: 0x401,\n\t\t\t0x178: 0x2100400,\n\t\t\t0x188: 0x2000001,\n\t\t\t0x198: 0x2100000,\n\t\t\t0x1a8: 0x0,\n\t\t\t0x1b8: 0x2100401,\n\t\t\t0x1c8: 0x100401,\n\t\t\t0x1d8: 0x400,\n\t\t\t0x1e8: 0x2000400,\n\t\t\t0x1f8: 0x100001\n\t\t}, {\n\t\t\t0x0: 0x8000820,\n\t\t\t0x1: 0x20000,\n\t\t\t0x2: 0x8000000,\n\t\t\t0x3: 0x20,\n\t\t\t0x4: 0x20020,\n\t\t\t0x5: 0x8020820,\n\t\t\t0x6: 0x8020800,\n\t\t\t0x7: 0x800,\n\t\t\t0x8: 0x8020000,\n\t\t\t0x9: 0x8000800,\n\t\t\t0xa: 0x20800,\n\t\t\t0xb: 0x8020020,\n\t\t\t0xc: 0x820,\n\t\t\t0xd: 0x0,\n\t\t\t0xe: 0x8000020,\n\t\t\t0xf: 0x20820,\n\t\t\t0x80000000: 0x800,\n\t\t\t0x80000001: 0x8020820,\n\t\t\t0x80000002: 0x8000820,\n\t\t\t0x80000003: 0x8000000,\n\t\t\t0x80000004: 0x8020000,\n\t\t\t0x80000005: 0x20800,\n\t\t\t0x80000006: 0x20820,\n\t\t\t0x80000007: 0x20,\n\t\t\t0x80000008: 0x8000020,\n\t\t\t0x80000009: 0x820,\n\t\t\t0x8000000a: 0x20020,\n\t\t\t0x8000000b: 0x8020800,\n\t\t\t0x8000000c: 0x0,\n\t\t\t0x8000000d: 0x8020020,\n\t\t\t0x8000000e: 0x8000800,\n\t\t\t0x8000000f: 0x20000,\n\t\t\t0x10: 0x20820,\n\t\t\t0x11: 0x8020800,\n\t\t\t0x12: 0x20,\n\t\t\t0x13: 0x800,\n\t\t\t0x14: 0x8000800,\n\t\t\t0x15: 0x8000020,\n\t\t\t0x16: 0x8020020,\n\t\t\t0x17: 0x20000,\n\t\t\t0x18: 0x0,\n\t\t\t0x19: 0x20020,\n\t\t\t0x1a: 0x8020000,\n\t\t\t0x1b: 0x8000820,\n\t\t\t0x1c: 0x8020820,\n\t\t\t0x1d: 0x20800,\n\t\t\t0x1e: 0x820,\n\t\t\t0x1f: 0x8000000,\n\t\t\t0x80000010: 0x20000,\n\t\t\t0x80000011: 0x800,\n\t\t\t0x80000012: 0x8020020,\n\t\t\t0x80000013: 0x20820,\n\t\t\t0x80000014: 0x20,\n\t\t\t0x80000015: 0x8020000,\n\t\t\t0x80000016: 0x8000000,\n\t\t\t0x80000017: 0x8000820,\n\t\t\t0x80000018: 0x8020820,\n\t\t\t0x80000019: 0x8000020,\n\t\t\t0x8000001a: 0x8000800,\n\t\t\t0x8000001b: 0x0,\n\t\t\t0x8000001c: 0x20800,\n\t\t\t0x8000001d: 0x820,\n\t\t\t0x8000001e: 0x20020,\n\t\t\t0x8000001f: 0x8020800\n\t\t}];\n\n\t\t// Masks that select the SBOX input\n\t\tvar SBOX_MASK = [0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000, 0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f];\n\n\t\t/**\n   * DES block cipher algorithm.\n   */\n\t\tvar DES = C_algo.DES = BlockCipher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar key = this._key;\n\t\t\t\tvar keyWords = key.words;\n\n\t\t\t\t// Select 56 bits according to PC1\n\t\t\t\tvar keyBits = [];\n\t\t\t\tfor (var i = 0; i < 56; i++) {\n\t\t\t\t\tvar keyBitPos = PC1[i] - 1;\n\t\t\t\t\tkeyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;\n\t\t\t\t}\n\n\t\t\t\t// Assemble 16 subkeys\n\t\t\t\tvar subKeys = this._subKeys = [];\n\t\t\t\tfor (var nSubKey = 0; nSubKey < 16; nSubKey++) {\n\t\t\t\t\t// Create subkey\n\t\t\t\t\tvar subKey = subKeys[nSubKey] = [];\n\n\t\t\t\t\t// Shortcut\n\t\t\t\t\tvar bitShift = BIT_SHIFTS[nSubKey];\n\n\t\t\t\t\t// Select 48 bits according to PC2\n\t\t\t\t\tfor (var i = 0; i < 24; i++) {\n\t\t\t\t\t\t// Select from the left 28 key bits\n\t\t\t\t\t\tsubKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;\n\n\t\t\t\t\t\t// Select from the right 28 key bits\n\t\t\t\t\t\tsubKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Since each subkey is applied to an expanded 32-bit input,\n\t\t\t\t\t// the subkey can be broken into 8 values scaled to 32-bits,\n\t\t\t\t\t// which allows the key to be used without expansion\n\t\t\t\t\tsubKey[0] = subKey[0] << 1 | subKey[0] >>> 31;\n\t\t\t\t\tfor (var i = 1; i < 7; i++) {\n\t\t\t\t\t\tsubKey[i] = subKey[i] >>> (i - 1) * 4 + 3;\n\t\t\t\t\t}\n\t\t\t\t\tsubKey[7] = subKey[7] << 5 | subKey[7] >>> 27;\n\t\t\t\t}\n\n\t\t\t\t// Compute inverse subkeys\n\t\t\t\tvar invSubKeys = this._invSubKeys = [];\n\t\t\t\tfor (var i = 0; i < 16; i++) {\n\t\t\t\t\tinvSubKeys[i] = subKeys[15 - i];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tencryptBlock: function (M, offset) {\n\t\t\t\tthis._doCryptBlock(M, offset, this._subKeys);\n\t\t\t},\n\n\t\t\tdecryptBlock: function (M, offset) {\n\t\t\t\tthis._doCryptBlock(M, offset, this._invSubKeys);\n\t\t\t},\n\n\t\t\t_doCryptBlock: function (M, offset, subKeys) {\n\t\t\t\t// Get input\n\t\t\t\tthis._lBlock = M[offset];\n\t\t\t\tthis._rBlock = M[offset + 1];\n\n\t\t\t\t// Initial permutation\n\t\t\t\texchangeLR.call(this, 4, 0x0f0f0f0f);\n\t\t\t\texchangeLR.call(this, 16, 0x0000ffff);\n\t\t\t\texchangeRL.call(this, 2, 0x33333333);\n\t\t\t\texchangeRL.call(this, 8, 0x00ff00ff);\n\t\t\t\texchangeLR.call(this, 1, 0x55555555);\n\n\t\t\t\t// Rounds\n\t\t\t\tfor (var round = 0; round < 16; round++) {\n\t\t\t\t\t// Shortcuts\n\t\t\t\t\tvar subKey = subKeys[round];\n\t\t\t\t\tvar lBlock = this._lBlock;\n\t\t\t\t\tvar rBlock = this._rBlock;\n\n\t\t\t\t\t// Feistel function\n\t\t\t\t\tvar f = 0;\n\t\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\t\tf |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n\t\t\t\t\t}\n\t\t\t\t\tthis._lBlock = rBlock;\n\t\t\t\t\tthis._rBlock = lBlock ^ f;\n\t\t\t\t}\n\n\t\t\t\t// Undo swap from last round\n\t\t\t\tvar t = this._lBlock;\n\t\t\t\tthis._lBlock = this._rBlock;\n\t\t\t\tthis._rBlock = t;\n\n\t\t\t\t// Final permutation\n\t\t\t\texchangeLR.call(this, 1, 0x55555555);\n\t\t\t\texchangeRL.call(this, 8, 0x00ff00ff);\n\t\t\t\texchangeRL.call(this, 2, 0x33333333);\n\t\t\t\texchangeLR.call(this, 16, 0x0000ffff);\n\t\t\t\texchangeLR.call(this, 4, 0x0f0f0f0f);\n\n\t\t\t\t// Set output\n\t\t\t\tM[offset] = this._lBlock;\n\t\t\t\tM[offset + 1] = this._rBlock;\n\t\t\t},\n\n\t\t\tkeySize: 64 / 32,\n\n\t\t\tivSize: 64 / 32,\n\n\t\t\tblockSize: 64 / 32\n\t\t});\n\n\t\t// Swap bits across the left and right words\n\t\tfunction exchangeLR(offset, mask) {\n\t\t\tvar t = (this._lBlock >>> offset ^ this._rBlock) & mask;\n\t\t\tthis._rBlock ^= t;\n\t\t\tthis._lBlock ^= t << offset;\n\t\t}\n\n\t\tfunction exchangeRL(offset, mask) {\n\t\t\tvar t = (this._rBlock >>> offset ^ this._lBlock) & mask;\n\t\t\tthis._lBlock ^= t;\n\t\t\tthis._rBlock ^= t << offset;\n\t\t}\n\n\t\t/**\n   * Shortcut functions to the cipher\'s object interface.\n   *\n   * @example\n   *\n   *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n   *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n   */\n\t\tC.DES = BlockCipher._createHelper(DES);\n\n\t\t/**\n   * Triple-DES block cipher algorithm.\n   */\n\t\tvar TripleDES = C_algo.TripleDES = BlockCipher.extend({\n\t\t\t_doReset: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar key = this._key;\n\t\t\t\tvar keyWords = key.words;\n\n\t\t\t\t// Create DES instances\n\t\t\t\tthis._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));\n\t\t\t\tthis._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));\n\t\t\t\tthis._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));\n\t\t\t},\n\n\t\t\tencryptBlock: function (M, offset) {\n\t\t\t\tthis._des1.encryptBlock(M, offset);\n\t\t\t\tthis._des2.decryptBlock(M, offset);\n\t\t\t\tthis._des3.encryptBlock(M, offset);\n\t\t\t},\n\n\t\t\tdecryptBlock: function (M, offset) {\n\t\t\t\tthis._des3.decryptBlock(M, offset);\n\t\t\t\tthis._des2.encryptBlock(M, offset);\n\t\t\t\tthis._des1.decryptBlock(M, offset);\n\t\t\t},\n\n\t\t\tkeySize: 192 / 32,\n\n\t\t\tivSize: 64 / 32,\n\n\t\t\tblockSize: 64 / 32\n\t\t});\n\n\t\t/**\n   * Shortcut functions to the cipher\'s object interface.\n   *\n   * @example\n   *\n   *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n   *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n   */\n\t\tC.TripleDES = BlockCipher._createHelper(TripleDES);\n\t})();\n\n\treturn CryptoJS.TripleDES;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/tripledes.js?'
                );
              },
            './node_modules/crypto-js/x64-core.js':
              /*!********************************************!*\
        !*** ./node_modules/crypto-js/x64-core.js ***!
        \********************************************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                eval(
                  ';(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));\n\t} else {}\n})(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t\t// Shortcuts\n\t\tvar C = CryptoJS;\n\t\tvar C_lib = C.lib;\n\t\tvar Base = C_lib.Base;\n\t\tvar X32WordArray = C_lib.WordArray;\n\n\t\t/**\n   * x64 namespace.\n   */\n\t\tvar C_x64 = C.x64 = {};\n\n\t\t/**\n   * A 64-bit word.\n   */\n\t\tvar X64Word = C_x64.Word = Base.extend({\n\t\t\t/**\n    * Initializes a newly created 64-bit word.\n    *\n    * @param {number} high The high 32 bits.\n    * @param {number} low The low 32 bits.\n    *\n    * @example\n    *\n    *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n    */\n\t\t\tinit: function (high, low) {\n\t\t\t\tthis.high = high;\n\t\t\t\tthis.low = low;\n\t\t\t}\n\n\t\t\t/**\n    * Bitwise NOTs this word.\n    *\n    * @return {X64Word} A new x64-Word object after negating.\n    *\n    * @example\n    *\n    *     var negated = x64Word.not();\n    */\n\t\t\t// not: function () {\n\t\t\t// var high = ~this.high;\n\t\t\t// var low = ~this.low;\n\n\t\t\t// return X64Word.create(high, low);\n\t\t\t// },\n\n\t\t\t/**\n    * Bitwise ANDs this word with the passed word.\n    *\n    * @param {X64Word} word The x64-Word to AND with this word.\n    *\n    * @return {X64Word} A new x64-Word object after ANDing.\n    *\n    * @example\n    *\n    *     var anded = x64Word.and(anotherX64Word);\n    */\n\t\t\t// and: function (word) {\n\t\t\t// var high = this.high & word.high;\n\t\t\t// var low = this.low & word.low;\n\n\t\t\t// return X64Word.create(high, low);\n\t\t\t// },\n\n\t\t\t/**\n    * Bitwise ORs this word with the passed word.\n    *\n    * @param {X64Word} word The x64-Word to OR with this word.\n    *\n    * @return {X64Word} A new x64-Word object after ORing.\n    *\n    * @example\n    *\n    *     var ored = x64Word.or(anotherX64Word);\n    */\n\t\t\t// or: function (word) {\n\t\t\t// var high = this.high | word.high;\n\t\t\t// var low = this.low | word.low;\n\n\t\t\t// return X64Word.create(high, low);\n\t\t\t// },\n\n\t\t\t/**\n    * Bitwise XORs this word with the passed word.\n    *\n    * @param {X64Word} word The x64-Word to XOR with this word.\n    *\n    * @return {X64Word} A new x64-Word object after XORing.\n    *\n    * @example\n    *\n    *     var xored = x64Word.xor(anotherX64Word);\n    */\n\t\t\t// xor: function (word) {\n\t\t\t// var high = this.high ^ word.high;\n\t\t\t// var low = this.low ^ word.low;\n\n\t\t\t// return X64Word.create(high, low);\n\t\t\t// },\n\n\t\t\t/**\n    * Shifts this word n bits to the left.\n    *\n    * @param {number} n The number of bits to shift.\n    *\n    * @return {X64Word} A new x64-Word object after shifting.\n    *\n    * @example\n    *\n    *     var shifted = x64Word.shiftL(25);\n    */\n\t\t\t// shiftL: function (n) {\n\t\t\t// if (n < 32) {\n\t\t\t// var high = (this.high << n) | (this.low >>> (32 - n));\n\t\t\t// var low = this.low << n;\n\t\t\t// } else {\n\t\t\t// var high = this.low << (n - 32);\n\t\t\t// var low = 0;\n\t\t\t// }\n\n\t\t\t// return X64Word.create(high, low);\n\t\t\t// },\n\n\t\t\t/**\n    * Shifts this word n bits to the right.\n    *\n    * @param {number} n The number of bits to shift.\n    *\n    * @return {X64Word} A new x64-Word object after shifting.\n    *\n    * @example\n    *\n    *     var shifted = x64Word.shiftR(7);\n    */\n\t\t\t// shiftR: function (n) {\n\t\t\t// if (n < 32) {\n\t\t\t// var low = (this.low >>> n) | (this.high << (32 - n));\n\t\t\t// var high = this.high >>> n;\n\t\t\t// } else {\n\t\t\t// var low = this.high >>> (n - 32);\n\t\t\t// var high = 0;\n\t\t\t// }\n\n\t\t\t// return X64Word.create(high, low);\n\t\t\t// },\n\n\t\t\t/**\n    * Rotates this word n bits to the left.\n    *\n    * @param {number} n The number of bits to rotate.\n    *\n    * @return {X64Word} A new x64-Word object after rotating.\n    *\n    * @example\n    *\n    *     var rotated = x64Word.rotL(25);\n    */\n\t\t\t// rotL: function (n) {\n\t\t\t// return this.shiftL(n).or(this.shiftR(64 - n));\n\t\t\t// },\n\n\t\t\t/**\n    * Rotates this word n bits to the right.\n    *\n    * @param {number} n The number of bits to rotate.\n    *\n    * @return {X64Word} A new x64-Word object after rotating.\n    *\n    * @example\n    *\n    *     var rotated = x64Word.rotR(7);\n    */\n\t\t\t// rotR: function (n) {\n\t\t\t// return this.shiftR(n).or(this.shiftL(64 - n));\n\t\t\t// },\n\n\t\t\t/**\n    * Adds this word with the passed word.\n    *\n    * @param {X64Word} word The x64-Word to add with this word.\n    *\n    * @return {X64Word} A new x64-Word object after adding.\n    *\n    * @example\n    *\n    *     var added = x64Word.add(anotherX64Word);\n    */\n\t\t\t// add: function (word) {\n\t\t\t// var low = (this.low + word.low) | 0;\n\t\t\t// var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;\n\t\t\t// var high = (this.high + word.high + carry) | 0;\n\n\t\t\t// return X64Word.create(high, low);\n\t\t\t// }\n\t\t});\n\n\t\t/**\n   * An array of 64-bit words.\n   *\n   * @property {Array} words The array of CryptoJS.x64.Word objects.\n   * @property {number} sigBytes The number of significant bytes in this word array.\n   */\n\t\tvar X64WordArray = C_x64.WordArray = Base.extend({\n\t\t\t/**\n    * Initializes a newly created word array.\n    *\n    * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n    * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n    *\n    * @example\n    *\n    *     var wordArray = CryptoJS.x64.WordArray.create();\n    *\n    *     var wordArray = CryptoJS.x64.WordArray.create([\n    *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n    *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n    *     ]);\n    *\n    *     var wordArray = CryptoJS.x64.WordArray.create([\n    *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n    *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n    *     ], 10);\n    */\n\t\t\tinit: function (words, sigBytes) {\n\t\t\t\twords = this.words = words || [];\n\n\t\t\t\tif (sigBytes != undefined) {\n\t\t\t\t\tthis.sigBytes = sigBytes;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sigBytes = words.length * 8;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n    * Converts this 64-bit word array to a 32-bit word array.\n    *\n    * @return {CryptoJS.lib.WordArray} This word array\'s data as a 32-bit word array.\n    *\n    * @example\n    *\n    *     var x32WordArray = x64WordArray.toX32();\n    */\n\t\t\ttoX32: function () {\n\t\t\t\t// Shortcuts\n\t\t\t\tvar x64Words = this.words;\n\t\t\t\tvar x64WordsLength = x64Words.length;\n\n\t\t\t\t// Convert\n\t\t\t\tvar x32Words = [];\n\t\t\t\tfor (var i = 0; i < x64WordsLength; i++) {\n\t\t\t\t\tvar x64Word = x64Words[i];\n\t\t\t\t\tx32Words.push(x64Word.high);\n\t\t\t\t\tx32Words.push(x64Word.low);\n\t\t\t\t}\n\n\t\t\t\treturn X32WordArray.create(x32Words, this.sigBytes);\n\t\t\t},\n\n\t\t\t/**\n    * Creates a copy of this word array.\n    *\n    * @return {X64WordArray} The clone.\n    *\n    * @example\n    *\n    *     var clone = x64WordArray.clone();\n    */\n\t\t\tclone: function () {\n\t\t\t\tvar clone = Base.clone.call(this);\n\n\t\t\t\t// Clone "words" array\n\t\t\t\tvar words = clone.words = this.words.slice(0);\n\n\t\t\t\t// Clone each X64Word object\n\t\t\t\tvar wordsLength = words.length;\n\t\t\t\tfor (var i = 0; i < wordsLength; i++) {\n\t\t\t\t\twords[i] = words[i].clone();\n\t\t\t\t}\n\n\t\t\t\treturn clone;\n\t\t\t}\n\t\t});\n\t})();\n\n\treturn CryptoJS;\n});\n\n//# sourceURL=webpack://BaseEncryption/./node_modules/crypto-js/x64-core.js?'
                );
              },
            './src/index.js':
              /*!**********************!*\
        !*** ./src/index.js ***!
        \**********************/
              /*! no static exports found */
              function (module, exports, __webpack_require__) {
                'use strict';
                eval(
                  "\n\nconst CryptoJS = __webpack_require__(/*! crypto-js */ \"./node_modules/crypto-js/index.js\");\nconst AES = __webpack_require__(/*! crypto-js/aes */ \"./node_modules/crypto-js/aes.js\");\n\nconst keySize = 256;\nconst ivSize = 128;\nconst iterations = 100;\nconst length = 32;\nconst ivSizeDivider = 8;\n\n// HELPERS\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\nfunction objToString(obj) {\n  if (isObject(obj)) {\n    obj = JSON.stringify(obj);\n  }\n  return obj;\n}\n\nconst oneWayEncryption = function (data) {\n  if (data) return CryptoJS.MD5(data).toString();\n  return data;\n};\n\nconst oneWayComparation = function (cypher, compare) {\n  if (cypher && compare) {\n    return cypher === CryptoJS.MD5(compare).toString();\n  }\n  return cypher;\n};\n\nconst twoWayEncryption = function (data, passphrase) {\n  if (!data) return data;\n  if (!passphrase) return passphrase;\n\n  if (isObject(data)) {\n    data = objToString(data);\n  }\n  const salt = CryptoJS.lib.WordArray.random(ivSize / ivSizeDivider);\n  const key = CryptoJS.PBKDF2(passphrase, salt, {\n    keySize: keySize / length,\n    iterations: iterations\n  });\n  const iv = CryptoJS.lib.WordArray.random(ivSize / ivSizeDivider);\n  const encrypted = CryptoJS.AES.encrypt(objToString(data), key, {\n    iv: iv,\n    padding: CryptoJS.pad.Pkcs7,\n    mode: CryptoJS.mode.CBC\n  });\n  // salt, initialization vector will be hex 32 in length\n  const cypher = salt.toString() + iv.toString() + encrypted.toString();\n  return cypher;\n};\n\nconst twoWayDecryption = function (cypher, passphrase) {\n\n  // console.log({\n  //   twd: 1,\n  //   cypher: cypher,\n  //   passphrase: passphrase\n  // });\n\n  if (!cypher) return cypher;\n\n  if (!passphrase) return passphrase;\n\n  const salt = CryptoJS.enc.Hex.parse(cypher.substr(0, length));\n  const iv = CryptoJS.enc.Hex.parse(cypher.substr(length, length));\n  const encrypted = cypher.substring(length * 2);\n  const key = CryptoJS.PBKDF2(passphrase, salt, {\n    keySize: keySize / length,\n    iterations: iterations\n  });\n  // console.log({\n  //   twd: 2,\n  //   salt: salt,\n  //   iv: iv,\n  //   encrypted: encrypted,\n  //   key: key\n  // });\n  let decrypted = CryptoJS.AES.decrypt(encrypted, key, {\n    iv: iv,\n    padding: CryptoJS.pad.Pkcs7,\n    mode: CryptoJS.mode.CBC\n  }).toString(CryptoJS.enc.Utf8);\n\n  // console.log({\n  //   twd: 3,\n  //   decrypted:decrypted\n  // })\n  // console.log('twDec4');\n  // console.log('DECRYPED',decrypted);\n  if (decrypted.charAt(0) === '\"' && decrypted.charAt(decrypted.length - 1) === '\"') {\n    decrypted = decrypted.substr(1, decrypted.length - 2);\n  }\n\n  // console.log('twDec5');\n  // console.log('DECRYPED',decrypted);\n  return decrypted;\n};\n\nconst BaseEncryption = {\n  oneWayEncrypt: oneWayEncryption,\n  oneWayCompare: oneWayComparation,\n  twoWayEncrypt: twoWayEncryption,\n  twoWayDecrypt: twoWayDecryption\n};\n\nmodule.exports = BaseEncryption;\n\n//# sourceURL=webpack://BaseEncryption/./src/index.js?"
                );
              },
          });
        }),
        (module.exports = factory());
    },
    function (t, n) {
      t.exports = !1;
    },
    function (t, n) {
      var e = 0,
        r = Math.random();
      t.exports = function (t) {
        return 'Symbol('.concat(
          void 0 === t ? '' : t,
          ')_',
          (++e + r).toString(36)
        );
      };
    },
    function (t, n, e) {
      var r = e(7).f,
        o = e(14),
        a = e(1)('toStringTag');
      t.exports = function (t, n, e) {
        t &&
          !o((t = e ? t : t.prototype), a) &&
          r(t, a, { configurable: !0, value: n });
      };
    },
    function (t, n) {
      var e = {}.toString;
      t.exports = function (t) {
        return e.call(t).slice(8, -1);
      };
    },
    function (t, n) {
      t.exports = {};
    },
    function (t, n) {
      var e = '[object AsyncFunction]',
        r = '[object Function]',
        o = '[object GeneratorFunction]',
        a = '[object Null]',
        i = '[object Proxy]',
        s = '[object Undefined]',
        c =
          'object' == typeof global &&
          global &&
          global.Object === Object &&
          global,
        u = 'object' == typeof self && self && self.Object === Object && self,
        f = c || u || Function('return this')(),
        d = Object.prototype,
        l = d.hasOwnProperty,
        h = d.toString,
        p = f.Symbol,
        y = p ? p.toStringTag : void 0;
      function v(t) {
        return null == t
          ? void 0 === t
            ? s
            : a
          : y && y in Object(t)
          ? (function (t) {
              var n = l.call(t, y),
                e = t[y];
              try {
                t[y] = void 0;
                var r = !0;
              } catch (t) {}
              var o = h.call(t);
              r && (n ? (t[y] = e) : delete t[y]);
              return o;
            })(t)
          : (function (t) {
              return h.call(t);
            })(t);
      }
      t.exports = function (t) {
        if (
          !(function (t) {
            var n = typeof t;
            return null != t && ('object' == n || 'function' == n);
          })(t)
        )
          return !1;
        var n = v(t);
        return n == r || n == o || n == e || n == i;
      };
    },
    function (t, n, e) {
      var r = e(13),
        o = e(0),
        a = o['__core-js_shared__'] || (o['__core-js_shared__'] = {});
      (t.exports = function (t, n) {
        return a[t] || (a[t] = void 0 !== n ? n : {});
      })('versions', []).push({
        version: r.version,
        mode: e(21) ? 'pure' : 'global',
        copyright: ' 2019 Denis Pushkarev (zloirock.ru)',
      });
    },
    function (t, n) {
      t.exports = function (t, n) {
        return {
          enumerable: !(1 & t),
          configurable: !(2 & t),
          writable: !(4 & t),
          value: n,
        };
      };
    },
    function (t, n) {
      n.f = {}.propertyIsEnumerable;
    },
    function (t, n, e) {
      var r = e(39);
      t.exports = function (t) {
        return Object(r(t));
      };
    },
    function (t, n, e) {
      var r = e(3),
        o = e(79),
        a = e(42),
        i = e(41)('IE_PROTO'),
        s = function () {},
        c = function () {
          var t,
            n = e(35)('iframe'),
            r = a.length;
          for (
            n.style.display = 'none',
              e(59).appendChild(n),
              n.src = 'javascript:',
              (t = n.contentWindow.document).open(),
              t.write('<script>document.F=Object</script>'),
              t.close(),
              c = t.F;
            r--;

          )
            delete c.prototype[a[r]];
          return c();
        };
      t.exports =
        Object.create ||
        function (t, n) {
          var e;
          return (
            null !== t
              ? ((s.prototype = r(t)),
                (e = new s()),
                (s.prototype = null),
                (e[i] = t))
              : (e = c()),
            void 0 === n ? e : o(e, n)
          );
        };
    },
    function (t, n, e) {
      'use strict';
      var r = e(96),
        o = e(69),
        a = e(25),
        i = e(19);
      (t.exports = e(52)(
        Array,
        'Array',
        function (t, n) {
          (this._t = i(t)), (this._i = 0), (this._k = n);
        },
        function () {
          var t = this._t,
            n = this._k,
            e = this._i++;
          return !t || e >= t.length
            ? ((this._t = void 0), o(1))
            : o(0, 'keys' == n ? e : 'values' == n ? t[e] : [e, t[e]]);
        },
        'values'
      )),
        (a.Arguments = a.Array),
        r('keys'),
        r('values'),
        r('entries');
    },
    function (t, n) {
      t.exports = function (t) {
        var n = typeof t;
        return !!t && ('object' == n || 'function' == n);
      };
    },
    function (t, n, e) {
      e(53)('asyncIterator');
    },
    function (t, n, e) {
      var r = e(2),
        o = e(0).document,
        a = r(o) && r(o.createElement);
      t.exports = function (t) {
        return a ? o.createElement(t) : {};
      };
    },
    function (t, n, e) {
      var r = e(2);
      t.exports = function (t, n) {
        if (!r(t)) return t;
        var e, o;
        if (n && 'function' == typeof (e = t.toString) && !r((o = e.call(t))))
          return o;
        if ('function' == typeof (e = t.valueOf) && !r((o = e.call(t))))
          return o;
        if (!n && 'function' == typeof (e = t.toString) && !r((o = e.call(t))))
          return o;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    function (t, n, e) {
      'use strict';
      var r = e(0),
        o = e(14),
        a = e(5),
        i = e(10),
        s = e(11),
        c = e(38).KEY,
        u = e(8),
        f = e(27),
        d = e(23),
        l = e(22),
        h = e(1),
        p = e(54),
        y = e(53),
        v = e(75),
        x = e(78),
        m = e(3),
        _ = e(2),
        b = e(30),
        g = e(19),
        S = e(36),
        w = e(28),
        C = e(31),
        k = e(80),
        A = e(61),
        E = e(43),
        T = e(7),
        O = e(18),
        j = A.f,
        B = T.f,
        R = k.f,
        I = r.Symbol,
        W = r.JSON,
        M = W && W.stringify,
        P = h('_hidden'),
        H = h('toPrimitive'),
        L = {}.propertyIsEnumerable,
        N = f('symbol-registry'),
        D = f('symbols'),
        F = f('op-symbols'),
        X = Object.prototype,
        J = 'function' == typeof I && !!E.f,
        z = r.QObject,
        U = !z || !z.prototype || !z.prototype.findChild,
        K =
          a &&
          u(function () {
            return (
              7 !=
              C(
                B({}, 'a', {
                  get: function () {
                    return B(this, 'a', { value: 7 }).a;
                  },
                })
              ).a
            );
          })
            ? function (t, n, e) {
                var r = j(X, n);
                r && delete X[n], B(t, n, e), r && t !== X && B(X, n, r);
              }
            : B,
        G = function (t) {
          var n = (D[t] = C(I.prototype));
          return (n._k = t), n;
        },
        q =
          J && 'symbol' == typeof I.iterator
            ? function (t) {
                return 'symbol' == typeof t;
              }
            : function (t) {
                return t instanceof I;
              },
        V = function (t, n, e) {
          return (
            t === X && V(F, n, e),
            m(t),
            (n = S(n, !0)),
            m(e),
            o(D, n)
              ? (e.enumerable
                  ? (o(t, P) && t[P][n] && (t[P][n] = !1),
                    (e = C(e, { enumerable: w(0, !1) })))
                  : (o(t, P) || B(t, P, w(1, {})), (t[P][n] = !0)),
                K(t, n, e))
              : B(t, n, e)
          );
        },
        Y = function (t, n) {
          m(t);
          for (var e, r = v((n = g(n))), o = 0, a = r.length; a > o; )
            V(t, (e = r[o++]), n[e]);
          return t;
        },
        $ = function (t) {
          var n = L.call(this, (t = S(t, !0)));
          return (
            !(this === X && o(D, t) && !o(F, t)) &&
            (!(n || !o(this, t) || !o(D, t) || (o(this, P) && this[P][t])) || n)
          );
        },
        Q = function (t, n) {
          if (((t = g(t)), (n = S(n, !0)), t !== X || !o(D, n) || o(F, n))) {
            var e = j(t, n);
            return (
              !e || !o(D, n) || (o(t, P) && t[P][n]) || (e.enumerable = !0), e
            );
          }
        },
        Z = function (t) {
          for (var n, e = R(g(t)), r = [], a = 0; e.length > a; )
            o(D, (n = e[a++])) || n == P || n == c || r.push(n);
          return r;
        },
        tt = function (t) {
          for (
            var n, e = t === X, r = R(e ? F : g(t)), a = [], i = 0;
            r.length > i;

          )
            !o(D, (n = r[i++])) || (e && !o(X, n)) || a.push(D[n]);
          return a;
        };
      J ||
        (s(
          (I = function () {
            if (this instanceof I)
              throw TypeError('Symbol is not a constructor!');
            var t = l(arguments.length > 0 ? arguments[0] : void 0),
              n = function (e) {
                this === X && n.call(F, e),
                  o(this, P) && o(this[P], t) && (this[P][t] = !1),
                  K(this, t, w(1, e));
              };
            return a && U && K(X, t, { configurable: !0, set: n }), G(t);
          }).prototype,
          'toString',
          function () {
            return this._k;
          }
        ),
        (A.f = Q),
        (T.f = V),
        (e(60).f = k.f = Z),
        (e(29).f = $),
        (E.f = tt),
        a && !e(21) && s(X, 'propertyIsEnumerable', $, !0),
        (p.f = function (t) {
          return G(h(t));
        })),
        i(i.G + i.W + i.F * !J, { Symbol: I });
      for (
        var nt =
            'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(
              ','
            ),
          et = 0;
        nt.length > et;

      )
        h(nt[et++]);
      for (var rt = O(h.store), ot = 0; rt.length > ot; ) y(rt[ot++]);
      i(i.S + i.F * !J, 'Symbol', {
        for: function (t) {
          return o(N, (t += '')) ? N[t] : (N[t] = I(t));
        },
        keyFor: function (t) {
          if (!q(t)) throw TypeError(t + ' is not a symbol!');
          for (var n in N) if (N[n] === t) return n;
        },
        useSetter: function () {
          U = !0;
        },
        useSimple: function () {
          U = !1;
        },
      }),
        i(i.S + i.F * !J, 'Object', {
          create: function (t, n) {
            return void 0 === n ? C(t) : Y(C(t), n);
          },
          defineProperty: V,
          defineProperties: Y,
          getOwnPropertyDescriptor: Q,
          getOwnPropertyNames: Z,
          getOwnPropertySymbols: tt,
        });
      var at = u(function () {
        E.f(1);
      });
      i(i.S + i.F * at, 'Object', {
        getOwnPropertySymbols: function (t) {
          return E.f(b(t));
        },
      }),
        W &&
          i(
            i.S +
              i.F *
                (!J ||
                  u(function () {
                    var t = I();
                    return (
                      '[null]' != M([t]) ||
                      '{}' != M({ a: t }) ||
                      '{}' != M(Object(t))
                    );
                  })),
            'JSON',
            {
              stringify: function (t) {
                for (var n, e, r = [t], o = 1; arguments.length > o; )
                  r.push(arguments[o++]);
                if (((e = n = r[1]), (_(n) || void 0 !== t) && !q(t)))
                  return (
                    x(n) ||
                      (n = function (t, n) {
                        if (
                          ('function' == typeof e && (n = e.call(this, t, n)),
                          !q(n))
                        )
                          return n;
                      }),
                    (r[1] = n),
                    M.apply(W, r)
                  );
              },
            }
          ),
        I.prototype[H] || e(15)(I.prototype, H, I.prototype.valueOf),
        d(I, 'Symbol'),
        d(Math, 'Math', !0),
        d(r.JSON, 'JSON', !0);
    },
    function (t, n, e) {
      var r = e(22)('meta'),
        o = e(2),
        a = e(14),
        i = e(7).f,
        s = 0,
        c =
          Object.isExtensible ||
          function () {
            return !0;
          },
        u = !e(8)(function () {
          return c(Object.preventExtensions({}));
        }),
        f = function (t) {
          i(t, r, { value: { i: 'O' + ++s, w: {} } });
        },
        d = (t.exports = {
          KEY: r,
          NEED: !1,
          fastKey: function (t, n) {
            if (!o(t))
              return 'symbol' == typeof t
                ? t
                : ('string' == typeof t ? 'S' : 'P') + t;
            if (!a(t, r)) {
              if (!c(t)) return 'F';
              if (!n) return 'E';
              f(t);
            }
            return t[r].i;
          },
          getWeak: function (t, n) {
            if (!a(t, r)) {
              if (!c(t)) return !0;
              if (!n) return !1;
              f(t);
            }
            return t[r].w;
          },
          onFreeze: function (t) {
            return u && d.NEED && c(t) && !a(t, r) && f(t), t;
          },
        });
    },
    function (t, n) {
      t.exports = function (t) {
        if (null == t) throw TypeError("Can't call method on  " + t);
        return t;
      };
    },
    function (t, n) {
      var e = Math.ceil,
        r = Math.floor;
      t.exports = function (t) {
        return isNaN((t = +t)) ? 0 : (t > 0 ? r : e)(t);
      };
    },
    function (t, n, e) {
      var r = e(27)('keys'),
        o = e(22);
      t.exports = function (t) {
        return r[t] || (r[t] = o(t));
      };
    },
    function (t, n) {
      t.exports =
        'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(
          ','
        );
    },
    function (t, n) {
      n.f = Object.getOwnPropertySymbols;
    },
    function (t, n, e) {
      'use strict';
      e(81);
      var r = e(3),
        o = e(62),
        a = e(5),
        i = /./.toString,
        s = function (t) {
          e(11)(RegExp.prototype, 'toString', t, !0);
        };
      e(8)(function () {
        return '/a/b' != i.call({ source: 'a', flags: 'b' });
      })
        ? s(function () {
            var t = r(this);
            return '/'.concat(
              t.source,
              '/',
              'flags' in t
                ? t.flags
                : !a && t instanceof RegExp
                ? o.call(t)
                : void 0
            );
          })
        : 'toString' != i.name &&
          s(function () {
            return i.call(this);
          });
    },
    function (t, n, e) {
      var r = e(10),
        o = e(31),
        a = e(17),
        i = e(3),
        s = e(2),
        c = e(8),
        u = e(82),
        f = (e(0).Reflect || {}).construct,
        d = c(function () {
          function t() {}
          return !(f(function () {}, [], t) instanceof t);
        }),
        l = !c(function () {
          f(function () {});
        });
      r(r.S + r.F * (d || l), 'Reflect', {
        construct: function (t, n) {
          a(t), i(n);
          var e = arguments.length < 3 ? t : a(arguments[2]);
          if (l && !d) return f(t, n, e);
          if (t == e) {
            switch (n.length) {
              case 0:
                return new t();
              case 1:
                return new t(n[0]);
              case 2:
                return new t(n[0], n[1]);
              case 3:
                return new t(n[0], n[1], n[2]);
              case 4:
                return new t(n[0], n[1], n[2], n[3]);
            }
            var r = [null];
            return r.push.apply(r, n), new (u.apply(t, r))();
          }
          var c = e.prototype,
            h = o(s(c) ? c : Object.prototype),
            p = Function.apply.call(t, h, n);
          return s(p) ? p : h;
        },
      });
    },
    function (t, n, e) {
      var r = e(10);
      r(r.S, 'Object', { setPrototypeOf: e(64).set });
    },
    function (t, n, e) {
      var r = e(24),
        o = e(1)('toStringTag'),
        a =
          'Arguments' ==
          r(
            (function () {
              return arguments;
            })()
          );
      t.exports = function (t) {
        var n, e, i;
        return void 0 === t
          ? 'Undefined'
          : null === t
          ? 'Null'
          : 'string' ==
            typeof (e = (function (t, n) {
              try {
                return t[n];
              } catch (t) {}
            })((n = Object(t)), o))
          ? e
          : a
          ? r(n)
          : 'Object' == (i = r(n)) && 'function' == typeof n.callee
          ? 'Arguments'
          : i;
      };
    },
    function (t, n) {
      t.exports = function (t, n, e, r) {
        if (!(t instanceof n) || (void 0 !== r && r in t))
          throw TypeError(e + ': incorrect invocation!');
        return t;
      };
    },
    function (t, n, e) {
      var r = e(16),
        o = e(83),
        a = e(84),
        i = e(3),
        s = e(58),
        c = e(85),
        u = {},
        f = {};
      ((n = t.exports =
        function (t, n, e, d, l) {
          var h,
            p,
            y,
            v,
            x = l
              ? function () {
                  return t;
                }
              : c(t),
            m = r(e, d, n ? 2 : 1),
            _ = 0;
          if ('function' != typeof x) throw TypeError(t + ' is not iterable!');
          if (a(x)) {
            for (h = s(t.length); h > _; _++)
              if (
                (v = n ? m(i((p = t[_]))[0], p[1]) : m(t[_])) === u ||
                v === f
              )
                return v;
          } else
            for (y = x.call(t); !(p = y.next()).done; )
              if ((v = o(y, m, p.value, n)) === u || v === f) return v;
        }).BREAK = u),
        (n.RETURN = f);
    },
    function (t, n, e) {
      var r = e(11);
      t.exports = function (t, n, e) {
        for (var o in n) r(t, o, n[o], e);
        return t;
      };
    },
    function (t, n, e) {
      for (
        var r = e(32),
          o = e(18),
          a = e(11),
          i = e(0),
          s = e(15),
          c = e(25),
          u = e(1),
          f = u('iterator'),
          d = u('toStringTag'),
          l = c.Array,
          h = {
            CSSRuleList: !0,
            CSSStyleDeclaration: !1,
            CSSValueList: !1,
            ClientRectList: !1,
            DOMRectList: !1,
            DOMStringList: !1,
            DOMTokenList: !0,
            DataTransferItemList: !1,
            FileList: !1,
            HTMLAllCollection: !1,
            HTMLCollection: !1,
            HTMLFormElement: !1,
            HTMLSelectElement: !1,
            MediaList: !0,
            MimeTypeArray: !1,
            NamedNodeMap: !1,
            NodeList: !0,
            PaintRequestList: !1,
            Plugin: !1,
            PluginArray: !1,
            SVGLengthList: !1,
            SVGNumberList: !1,
            SVGPathSegList: !1,
            SVGPointList: !1,
            SVGStringList: !1,
            SVGTransformList: !1,
            SourceBufferList: !1,
            StyleSheetList: !0,
            TextTrackCueList: !1,
            TextTrackList: !1,
            TouchList: !1,
          },
          p = o(h),
          y = 0;
        y < p.length;
        y++
      ) {
        var v,
          x = p[y],
          m = h[x],
          _ = i[x],
          b = _ && _.prototype;
        if (b && (b[f] || s(b, f, l), b[d] || s(b, d, x), (c[x] = l), m))
          for (v in r) b[v] || a(b, v, r[v], !0);
      }
    },
    function (t, n, e) {
      'use strict';
      var r = e(21),
        o = e(10),
        a = e(11),
        i = e(15),
        s = e(25),
        c = e(97),
        u = e(23),
        f = e(98),
        d = e(1)('iterator'),
        l = !([].keys && 'next' in [].keys()),
        h = function () {
          return this;
        };
      t.exports = function (t, n, e, p, y, v, x) {
        c(e, n, p);
        var m,
          _,
          b,
          g = function (t) {
            if (!l && t in k) return k[t];
            switch (t) {
              case 'keys':
              case 'values':
                return function () {
                  return new e(this, t);
                };
            }
            return function () {
              return new e(this, t);
            };
          },
          S = n + ' Iterator',
          w = 'values' == y,
          C = !1,
          k = t.prototype,
          A = k[d] || k['@@iterator'] || (y && k[y]),
          E = A || g(y),
          T = y ? (w ? g('entries') : E) : void 0,
          O = ('Array' == n && k.entries) || A;
        if (
          (O &&
            (b = f(O.call(new t()))) !== Object.prototype &&
            b.next &&
            (u(b, S, !0), r || 'function' == typeof b[d] || i(b, d, h)),
          w &&
            A &&
            'values' !== A.name &&
            ((C = !0),
            (E = function () {
              return A.call(this);
            })),
          (r && !x) || (!l && !C && k[d]) || i(k, d, E),
          (s[n] = E),
          (s[S] = h),
          y)
        )
          if (
            ((m = {
              values: w ? E : g('values'),
              keys: v ? E : g('keys'),
              entries: T,
            }),
            x)
          )
            for (_ in m) _ in k || a(k, _, m[_]);
          else o(o.P + o.F * (l || C), n, m);
        return m;
      };
    },
    function (t, n, e) {
      var r = e(0),
        o = e(13),
        a = e(21),
        i = e(54),
        s = e(7).f;
      t.exports = function (t) {
        var n = o.Symbol || (o.Symbol = a ? {} : r.Symbol || {});
        '_' == t.charAt(0) || t in n || s(n, t, { value: i.f(t) });
      };
    },
    function (t, n, e) {
      n.f = e(1);
    },
    function (t, n, e) {
      t.exports =
        !e(5) &&
        !e(8)(function () {
          return (
            7 !=
            Object.defineProperty(e(35)('div'), 'a', {
              get: function () {
                return 7;
              },
            }).a
          );
        });
    },
    function (t, n, e) {
      var r = e(14),
        o = e(19),
        a = e(76)(!1),
        i = e(41)('IE_PROTO');
      t.exports = function (t, n) {
        var e,
          s = o(t),
          c = 0,
          u = [];
        for (e in s) e != i && r(s, e) && u.push(e);
        for (; n.length > c; ) r(s, (e = n[c++])) && (~a(u, e) || u.push(e));
        return u;
      };
    },
    function (t, n, e) {
      var r = e(24);
      t.exports = Object('z').propertyIsEnumerable(0)
        ? Object
        : function (t) {
            return 'String' == r(t) ? t.split('') : Object(t);
          };
    },
    function (t, n, e) {
      var r = e(40),
        o = Math.min;
      t.exports = function (t) {
        return t > 0 ? o(r(t), 9007199254740991) : 0;
      };
    },
    function (t, n, e) {
      var r = e(0).document;
      t.exports = r && r.documentElement;
    },
    function (t, n, e) {
      var r = e(56),
        o = e(42).concat('length', 'prototype');
      n.f =
        Object.getOwnPropertyNames ||
        function (t) {
          return r(t, o);
        };
    },
    function (t, n, e) {
      var r = e(29),
        o = e(28),
        a = e(19),
        i = e(36),
        s = e(14),
        c = e(55),
        u = Object.getOwnPropertyDescriptor;
      n.f = e(5)
        ? u
        : function (t, n) {
            if (((t = a(t)), (n = i(n, !0)), c))
              try {
                return u(t, n);
              } catch (t) {}
            if (s(t, n)) return o(!r.f.call(t, n), t[n]);
          };
    },
    function (t, n, e) {
      'use strict';
      var r = e(3);
      t.exports = function () {
        var t = r(this),
          n = '';
        return (
          t.global && (n += 'g'),
          t.ignoreCase && (n += 'i'),
          t.multiline && (n += 'm'),
          t.unicode && (n += 'u'),
          t.sticky && (n += 'y'),
          n
        );
      };
    },
    function (t, n) {
      t.exports = function (t, n, e) {
        var r = void 0 === e;
        switch (n.length) {
          case 0:
            return r ? t() : t.call(e);
          case 1:
            return r ? t(n[0]) : t.call(e, n[0]);
          case 2:
            return r ? t(n[0], n[1]) : t.call(e, n[0], n[1]);
          case 3:
            return r ? t(n[0], n[1], n[2]) : t.call(e, n[0], n[1], n[2]);
          case 4:
            return r
              ? t(n[0], n[1], n[2], n[3])
              : t.call(e, n[0], n[1], n[2], n[3]);
        }
        return t.apply(e, n);
      };
    },
    function (t, n, e) {
      var r = e(2),
        o = e(3),
        a = function (t, n) {
          if ((o(t), !r(n) && null !== n))
            throw TypeError(n + ": can't set as prototype!");
        };
      t.exports = {
        set:
          Object.setPrototypeOf ||
          ('__proto__' in {}
            ? (function (t, n, r) {
                try {
                  (r = e(16)(
                    Function.call,
                    e(61).f(Object.prototype, '__proto__').set,
                    2
                  ))(t, []),
                    (n = !(t instanceof Array));
                } catch (t) {
                  n = !0;
                }
                return function (t, e) {
                  return a(t, e), n ? (t.__proto__ = e) : r(t, e), t;
                };
              })({}, !1)
            : void 0),
        check: a,
      };
    },
    function (t, n, e) {
      var r,
        o,
        a,
        i = e(16),
        s = e(63),
        c = e(59),
        u = e(35),
        f = e(0),
        d = f.process,
        l = f.setImmediate,
        h = f.clearImmediate,
        p = f.MessageChannel,
        y = f.Dispatch,
        v = 0,
        x = {},
        m = function () {
          var t = +this;
          if (x.hasOwnProperty(t)) {
            var n = x[t];
            delete x[t], n();
          }
        },
        _ = function (t) {
          m.call(t.data);
        };
      (l && h) ||
        ((l = function (t) {
          for (var n = [], e = 1; arguments.length > e; )
            n.push(arguments[e++]);
          return (
            (x[++v] = function () {
              s('function' == typeof t ? t : Function(t), n);
            }),
            r(v),
            v
          );
        }),
        (h = function (t) {
          delete x[t];
        }),
        'process' == e(24)(d)
          ? (r = function (t) {
              d.nextTick(i(m, t, 1));
            })
          : y && y.now
          ? (r = function (t) {
              y.now(i(m, t, 1));
            })
          : p
          ? ((a = (o = new p()).port2),
            (o.port1.onmessage = _),
            (r = i(a.postMessage, a, 1)))
          : f.addEventListener &&
            'function' == typeof postMessage &&
            !f.importScripts
          ? ((r = function (t) {
              f.postMessage(t + '', '*');
            }),
            f.addEventListener('message', _, !1))
          : (r =
              'onreadystatechange' in u('script')
                ? function (t) {
                    c.appendChild(u('script')).onreadystatechange =
                      function () {
                        c.removeChild(this), m.call(t);
                      };
                  }
                : function (t) {
                    setTimeout(i(m, t, 1), 0);
                  })),
        (t.exports = { set: l, clear: h });
    },
    function (t, n, e) {
      'use strict';
      var r = e(17);
      function o(t) {
        var n, e;
        (this.promise = new t(function (t, r) {
          if (void 0 !== n || void 0 !== e)
            throw TypeError('Bad Promise constructor');
          (n = t), (e = r);
        })),
          (this.resolve = r(n)),
          (this.reject = r(e));
      }
      t.exports.f = function (t) {
        return new o(t);
      };
    },
    function (t, n, e) {
      'use strict';
      var r = e(0),
        o = e(7),
        a = e(5),
        i = e(1)('species');
      t.exports = function (t) {
        var n = r[t];
        a &&
          n &&
          !n[i] &&
          o.f(n, i, {
            configurable: !0,
            get: function () {
              return this;
            },
          });
      };
    },
    function (t, n, e) {
      var r = e(1)('iterator'),
        o = !1;
      try {
        var a = [7][r]();
        (a.return = function () {
          o = !0;
        }),
          Array.from(a, function () {
            throw 2;
          });
      } catch (t) {}
      t.exports = function (t, n) {
        if (!n && !o) return !1;
        var e = !1;
        try {
          var a = [7],
            i = a[r]();
          (i.next = function () {
            return { done: (e = !0) };
          }),
            (a[r] = function () {
              return i;
            }),
            t(a);
        } catch (t) {}
        return e;
      };
    },
    function (t, n) {
      t.exports = function (t, n) {
        return { value: n, done: !!t };
      };
    },
    function (t, n, e) {
      var r = e(30),
        o = e(18);
      e(99)('keys', function () {
        return function (t) {
          return o(r(t));
        };
      });
    },
    function (t, n, e) {
      var r = e(2);
      t.exports = function (t, n) {
        if (!r(t) || t._t !== n)
          throw TypeError('Incompatible receiver, ' + n + ' required!');
        return t;
      };
    },
    function (t, n, e) {
      var r = e(10);
      r(r.S + r.F, 'Object', { assign: e(106) });
    },
    function (t, n, e) {
      (function (t) {
        var e = 9007199254740991,
          r = '[object Arguments]',
          o = '[object Function]',
          a = '[object GeneratorFunction]',
          i = '[object Map]',
          s = '[object Set]',
          c = /^\[object .+?Constructor\]$/,
          u =
            'object' == typeof global &&
            global &&
            global.Object === Object &&
            global,
          f = 'object' == typeof self && self && self.Object === Object && self,
          d = u || f || Function('return this')(),
          l = n && !n.nodeType && n,
          h = l && 'object' == typeof t && t && !t.nodeType && t,
          p = h && h.exports === l;
        var y,
          v,
          x,
          m = Function.prototype,
          _ = Object.prototype,
          b = d['__core-js_shared__'],
          g = (y = /[^.]+$/.exec((b && b.keys && b.keys.IE_PROTO) || ''))
            ? 'Symbol(src)_1.' + y
            : '',
          S = m.toString,
          w = _.hasOwnProperty,
          C = _.toString,
          k = RegExp(
            '^' +
              S.call(w)
                .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  '$1.*?'
                ) +
              '$'
          ),
          A = p ? d.Buffer : void 0,
          E = _.propertyIsEnumerable,
          T = A ? A.isBuffer : void 0,
          O =
            ((v = Object.keys),
            (x = Object),
            function (t) {
              return v(x(t));
            }),
          j = X(d, 'DataView'),
          B = X(d, 'Map'),
          R = X(d, 'Promise'),
          I = X(d, 'Set'),
          W = X(d, 'WeakMap'),
          M = !E.call({ valueOf: 1 }, 'valueOf'),
          P = z(j),
          H = z(B),
          L = z(R),
          N = z(I),
          D = z(W);
        function F(t) {
          return (
            !(
              !Y(t) ||
              (function (t) {
                return !!g && g in t;
              })(t)
            ) &&
            (V(t) ||
            (function (t) {
              var n = !1;
              if (null != t && 'function' != typeof t.toString)
                try {
                  n = !!(t + '');
                } catch (t) {}
              return n;
            })(t)
              ? k
              : c
            ).test(z(t))
          );
        }
        function X(t, n) {
          var e = (function (t, n) {
            return null == t ? void 0 : t[n];
          })(t, n);
          return F(e) ? e : void 0;
        }
        var J = function (t) {
          return C.call(t);
        };
        function z(t) {
          if (null != t) {
            try {
              return S.call(t);
            } catch (t) {}
            try {
              return t + '';
            } catch (t) {}
          }
          return '';
        }
        function U(t) {
          return (
            (function (t) {
              return (
                (function (t) {
                  return !!t && 'object' == typeof t;
                })(t) && G(t)
              );
            })(t) &&
            w.call(t, 'callee') &&
            (!E.call(t, 'callee') || C.call(t) == r)
          );
        }
        ((j && '[object DataView]' != J(new j(new ArrayBuffer(1)))) ||
          (B && J(new B()) != i) ||
          (R && '[object Promise]' != J(R.resolve())) ||
          (I && J(new I()) != s) ||
          (W && '[object WeakMap]' != J(new W()))) &&
          (J = function (t) {
            var n = C.call(t),
              e = '[object Object]' == n ? t.constructor : void 0,
              r = e ? z(e) : void 0;
            if (r)
              switch (r) {
                case P:
                  return '[object DataView]';
                case H:
                  return i;
                case L:
                  return '[object Promise]';
                case N:
                  return s;
                case D:
                  return '[object WeakMap]';
              }
            return n;
          });
        var K = Array.isArray;
        function G(t) {
          return (
            null != t &&
            (function (t) {
              return 'number' == typeof t && t > -1 && t % 1 == 0 && t <= e;
            })(t.length) &&
            !V(t)
          );
        }
        var q =
          T ||
          function () {
            return !1;
          };
        function V(t) {
          var n = Y(t) ? C.call(t) : '';
          return n == o || n == a;
        }
        function Y(t) {
          var n = typeof t;
          return !!t && ('object' == n || 'function' == n);
        }
        t.exports = function (t) {
          if (
            G(t) &&
            (K(t) ||
              'string' == typeof t ||
              'function' == typeof t.splice ||
              q(t) ||
              U(t))
          )
            return !t.length;
          var n = J(t);
          if (n == i || n == s) return !t.size;
          if (
            M ||
            (function (t) {
              var n = t && t.constructor;
              return t === (('function' == typeof n && n.prototype) || _);
            })(t)
          )
            return !O(t).length;
          for (var e in t) if (w.call(t, e)) return !1;
          return !0;
        };
      }).call(this, e(91)(t));
    },
    function (t, n, e) {
      t.exports = e(27)('native-function-to-string', Function.toString);
    },
    function (t, n, e) {
      var r = e(18),
        o = e(43),
        a = e(29);
      t.exports = function (t) {
        var n = r(t),
          e = o.f;
        if (e)
          for (var i, s = e(t), c = a.f, u = 0; s.length > u; )
            c.call(t, (i = s[u++])) && n.push(i);
        return n;
      };
    },
    function (t, n, e) {
      var r = e(19),
        o = e(58),
        a = e(77);
      t.exports = function (t) {
        return function (n, e, i) {
          var s,
            c = r(n),
            u = o(c.length),
            f = a(i, u);
          if (t && e != e) {
            for (; u > f; ) if ((s = c[f++]) != s) return !0;
          } else
            for (; u > f; f++)
              if ((t || f in c) && c[f] === e) return t || f || 0;
          return !t && -1;
        };
      };
    },
    function (t, n, e) {
      var r = e(40),
        o = Math.max,
        a = Math.min;
      t.exports = function (t, n) {
        return (t = r(t)) < 0 ? o(t + n, 0) : a(t, n);
      };
    },
    function (t, n, e) {
      var r = e(24);
      t.exports =
        Array.isArray ||
        function (t) {
          return 'Array' == r(t);
        };
    },
    function (t, n, e) {
      var r = e(7),
        o = e(3),
        a = e(18);
      t.exports = e(5)
        ? Object.defineProperties
        : function (t, n) {
            o(t);
            for (var e, i = a(n), s = i.length, c = 0; s > c; )
              r.f(t, (e = i[c++]), n[e]);
            return t;
          };
    },
    function (t, n, e) {
      var r = e(19),
        o = e(60).f,
        a = {}.toString,
        i =
          'object' == typeof window && window && Object.getOwnPropertyNames
            ? Object.getOwnPropertyNames(window)
            : [];
      t.exports.f = function (t) {
        return i && '[object Window]' == a.call(t)
          ? (function (t) {
              try {
                return o(t);
              } catch (t) {
                return i.slice();
              }
            })(t)
          : o(r(t));
      };
    },
    function (t, n, e) {
      e(5) &&
        'g' != /./g.flags &&
        e(7).f(RegExp.prototype, 'flags', { configurable: !0, get: e(62) });
    },
    function (t, n, e) {
      'use strict';
      var r = e(17),
        o = e(2),
        a = e(63),
        i = [].slice,
        s = {},
        c = function (t, n, e) {
          if (!(n in s)) {
            for (var r = [], o = 0; o < n; o++) r[o] = 'a[' + o + ']';
            s[n] = Function('F,a', 'return new F(' + r.join(',') + ')');
          }
          return s[n](t, e);
        };
      t.exports =
        Function.bind ||
        function (t) {
          var n = r(this),
            e = i.call(arguments, 1),
            s = function () {
              var r = e.concat(i.call(arguments));
              return this instanceof s ? c(n, r.length, r) : a(n, r, t);
            };
          return o(n.prototype) && (s.prototype = n.prototype), s;
        };
    },
    function (t, n, e) {
      var r = e(3);
      t.exports = function (t, n, e, o) {
        try {
          return o ? n(r(e)[0], e[1]) : n(e);
        } catch (n) {
          var a = t.return;
          throw (void 0 !== a && r(a.call(t)), n);
        }
      };
    },
    function (t, n, e) {
      var r = e(25),
        o = e(1)('iterator'),
        a = Array.prototype;
      t.exports = function (t) {
        return void 0 !== t && (r.Array === t || a[o] === t);
      };
    },
    function (t, n, e) {
      var r = e(47),
        o = e(1)('iterator'),
        a = e(25);
      t.exports = e(13).getIteratorMethod = function (t) {
        if (null != t) return t[o] || t['@@iterator'] || a[r(t)];
      };
    },
    function (t, n, e) {
      var r = e(3),
        o = e(17),
        a = e(1)('species');
      t.exports = function (t, n) {
        var e,
          i = r(t).constructor;
        return void 0 === i || null == (e = r(i)[a]) ? n : o(e);
      };
    },
    function (t, n, e) {
      var r = e(0),
        o = e(65).set,
        a = r.MutationObserver || r.WebKitMutationObserver,
        i = r.process,
        s = r.Promise,
        c = 'process' == e(24)(i);
      t.exports = function () {
        var t,
          n,
          e,
          u = function () {
            var r, o;
            for (c && (r = i.domain) && r.exit(); t; ) {
              (o = t.fn), (t = t.next);
              try {
                o();
              } catch (r) {
                throw (t ? e() : (n = void 0), r);
              }
            }
            (n = void 0), r && r.enter();
          };
        if (c)
          e = function () {
            i.nextTick(u);
          };
        else if (!a || (r.navigator && r.navigator.standalone))
          if (s && s.resolve) {
            var f = s.resolve(void 0);
            e = function () {
              f.then(u);
            };
          } else
            e = function () {
              o.call(r, u);
            };
        else {
          var d = !0,
            l = document.createTextNode('');
          new a(u).observe(l, { characterData: !0 }),
            (e = function () {
              l.data = d = !d;
            });
        }
        return function (r) {
          var o = { fn: r, next: void 0 };
          n && (n.next = o), t || ((t = o), e()), (n = o);
        };
      };
    },
    function (t, n) {
      t.exports = function (t) {
        try {
          return { e: !1, v: t() };
        } catch (t) {
          return { e: !0, v: t };
        }
      };
    },
    function (t, n, e) {
      var r = e(0).navigator;
      t.exports = (r && r.userAgent) || '';
    },
    function (t, n, e) {
      var r = e(3),
        o = e(2),
        a = e(66);
      t.exports = function (t, n) {
        if ((r(t), o(n) && n.constructor === t)) return n;
        var e = a.f(t);
        return (0, e.resolve)(n), e.promise;
      };
    },
    function (t, n) {
      t.exports = function (t) {
        return (
          t.webpackPolyfill ||
            ((t.deprecate = function () {}),
            (t.paths = []),
            t.children || (t.children = []),
            Object.defineProperty(t, 'loaded', {
              enumerable: !0,
              get: function () {
                return t.l;
              },
            }),
            Object.defineProperty(t, 'id', {
              enumerable: !0,
              get: function () {
                return t.i;
              },
            }),
            (t.webpackPolyfill = 1)),
          t
        );
      };
    },
    function (t, n, e) {
      'use strict';
      var r = (function () {
        if ('undefined' != typeof self) return self;
        if ('undefined' != typeof window) return window;
        if (void 0 !== r) return r;
        throw new Error('unable to locate global object');
      })();
      (t.exports = n = r.fetch),
        (n.default = r.fetch.bind(r)),
        (n.Headers = r.Headers),
        (n.Request = r.Request),
        (n.Response = r.Response);
    },
    function (t, n, e) {
      var r = e(94),
        o = e(95);
      t.exports = function (t, n, e) {
        var a = (n && e) || 0;
        'string' == typeof t &&
          ((n = 'binary' === t ? new Array(16) : null), (t = null));
        var i = (t = t || {}).random || (t.rng || r)();
        if (((i[6] = (15 & i[6]) | 64), (i[8] = (63 & i[8]) | 128), n))
          for (var s = 0; s < 16; ++s) n[a + s] = i[s];
        return n || o(i);
      };
    },
    function (t, n) {
      var e =
        ('undefined' != typeof crypto &&
          crypto.getRandomValues &&
          crypto.getRandomValues.bind(crypto)) ||
        ('undefined' != typeof msCrypto &&
          'function' == typeof window.msCrypto.getRandomValues &&
          msCrypto.getRandomValues.bind(msCrypto));
      if (e) {
        var r = new Uint8Array(16);
        t.exports = function () {
          return e(r), r;
        };
      } else {
        var o = new Array(16);
        t.exports = function () {
          for (var t, n = 0; n < 16; n++)
            0 == (3 & n) && (t = 4294967296 * Math.random()),
              (o[n] = (t >>> ((3 & n) << 3)) & 255);
          return o;
        };
      }
    },
    function (t, n) {
      for (var e = [], r = 0; r < 256; ++r)
        e[r] = (r + 256).toString(16).substr(1);
      t.exports = function (t, n) {
        var r = n || 0,
          o = e;
        return [
          o[t[r++]],
          o[t[r++]],
          o[t[r++]],
          o[t[r++]],
          '-',
          o[t[r++]],
          o[t[r++]],
          '-',
          o[t[r++]],
          o[t[r++]],
          '-',
          o[t[r++]],
          o[t[r++]],
          '-',
          o[t[r++]],
          o[t[r++]],
          o[t[r++]],
          o[t[r++]],
          o[t[r++]],
          o[t[r++]],
        ].join('');
      };
    },
    function (t, n, e) {
      var r = e(1)('unscopables'),
        o = Array.prototype;
      null == o[r] && e(15)(o, r, {}),
        (t.exports = function (t) {
          o[r][t] = !0;
        });
    },
    function (t, n, e) {
      'use strict';
      var r = e(31),
        o = e(28),
        a = e(23),
        i = {};
      e(15)(i, e(1)('iterator'), function () {
        return this;
      }),
        (t.exports = function (t, n, e) {
          (t.prototype = r(i, { next: o(1, e) })), a(t, n + ' Iterator');
        });
    },
    function (t, n, e) {
      var r = e(14),
        o = e(30),
        a = e(41)('IE_PROTO'),
        i = Object.prototype;
      t.exports =
        Object.getPrototypeOf ||
        function (t) {
          return (
            (t = o(t)),
            r(t, a)
              ? t[a]
              : 'function' == typeof t.constructor && t instanceof t.constructor
              ? t.constructor.prototype
              : t instanceof Object
              ? i
              : null
          );
        };
    },
    function (t, n, e) {
      var r = e(10),
        o = e(13),
        a = e(8);
      t.exports = function (t, n) {
        var e = (o.Object || {})[t] || Object[t],
          i = {};
        (i[t] = n(e)),
          r(
            r.S +
              r.F *
                a(function () {
                  e(1);
                }),
            'Object',
            i
          );
      };
    },
    function (t, n, e) {
      'use strict';
      var r = e(101)(!0);
      e(52)(
        String,
        'String',
        function (t) {
          (this._t = String(t)), (this._i = 0);
        },
        function () {
          var t,
            n = this._t,
            e = this._i;
          return e >= n.length
            ? { value: void 0, done: !0 }
            : ((t = r(n, e)), (this._i += t.length), { value: t, done: !1 });
        }
      );
    },
    function (t, n, e) {
      var r = e(40),
        o = e(39);
      t.exports = function (t) {
        return function (n, e) {
          var a,
            i,
            s = String(o(n)),
            c = r(e),
            u = s.length;
          return c < 0 || c >= u
            ? t
              ? ''
              : void 0
            : (a = s.charCodeAt(c)) < 55296 ||
              a > 56319 ||
              c + 1 === u ||
              (i = s.charCodeAt(c + 1)) < 56320 ||
              i > 57343
            ? t
              ? s.charAt(c)
              : a
            : t
            ? s.slice(c, c + 2)
            : i - 56320 + ((a - 55296) << 10) + 65536;
        };
      };
    },
    function (t, n, e) {
      'use strict';
      var r = e(103),
        o = e(71);
      t.exports = e(104)(
        'Map',
        function (t) {
          return function () {
            return t(this, arguments.length > 0 ? arguments[0] : void 0);
          };
        },
        {
          get: function (t) {
            var n = r.getEntry(o(this, 'Map'), t);
            return n && n.v;
          },
          set: function (t, n) {
            return r.def(o(this, 'Map'), 0 === t ? 0 : t, n);
          },
        },
        r,
        !0
      );
    },
    function (t, n, e) {
      'use strict';
      var r = e(7).f,
        o = e(31),
        a = e(50),
        i = e(16),
        s = e(48),
        c = e(49),
        u = e(52),
        f = e(69),
        d = e(67),
        l = e(5),
        h = e(38).fastKey,
        p = e(71),
        y = l ? '_s' : 'size',
        v = function (t, n) {
          var e,
            r = h(n);
          if ('F' !== r) return t._i[r];
          for (e = t._f; e; e = e.n) if (e.k == n) return e;
        };
      t.exports = {
        getConstructor: function (t, n, e, u) {
          var f = t(function (t, r) {
            s(t, f, n, '_i'),
              (t._t = n),
              (t._i = o(null)),
              (t._f = void 0),
              (t._l = void 0),
              (t[y] = 0),
              null != r && c(r, e, t[u], t);
          });
          return (
            a(f.prototype, {
              clear: function () {
                for (var t = p(this, n), e = t._i, r = t._f; r; r = r.n)
                  (r.r = !0), r.p && (r.p = r.p.n = void 0), delete e[r.i];
                (t._f = t._l = void 0), (t[y] = 0);
              },
              delete: function (t) {
                var e = p(this, n),
                  r = v(e, t);
                if (r) {
                  var o = r.n,
                    a = r.p;
                  delete e._i[r.i],
                    (r.r = !0),
                    a && (a.n = o),
                    o && (o.p = a),
                    e._f == r && (e._f = o),
                    e._l == r && (e._l = a),
                    e[y]--;
                }
                return !!r;
              },
              forEach: function (t) {
                p(this, n);
                for (
                  var e,
                    r = i(t, arguments.length > 1 ? arguments[1] : void 0, 3);
                  (e = e ? e.n : this._f);

                )
                  for (r(e.v, e.k, this); e && e.r; ) e = e.p;
              },
              has: function (t) {
                return !!v(p(this, n), t);
              },
            }),
            l &&
              r(f.prototype, 'size', {
                get: function () {
                  return p(this, n)[y];
                },
              }),
            f
          );
        },
        def: function (t, n, e) {
          var r,
            o,
            a = v(t, n);
          return (
            a
              ? (a.v = e)
              : ((t._l = a =
                  {
                    i: (o = h(n, !0)),
                    k: n,
                    v: e,
                    p: (r = t._l),
                    n: void 0,
                    r: !1,
                  }),
                t._f || (t._f = a),
                r && (r.n = a),
                t[y]++,
                'F' !== o && (t._i[o] = a)),
            t
          );
        },
        getEntry: v,
        setStrong: function (t, n, e) {
          u(
            t,
            n,
            function (t, e) {
              (this._t = p(t, n)), (this._k = e), (this._l = void 0);
            },
            function () {
              for (var t = this._k, n = this._l; n && n.r; ) n = n.p;
              return this._t && (this._l = n = n ? n.n : this._t._f)
                ? f(0, 'keys' == t ? n.k : 'values' == t ? n.v : [n.k, n.v])
                : ((this._t = void 0), f(1));
            },
            e ? 'entries' : 'values',
            !e,
            !0
          ),
            d(n);
        },
      };
    },
    function (t, n, e) {
      'use strict';
      var r = e(0),
        o = e(10),
        a = e(11),
        i = e(50),
        s = e(38),
        c = e(49),
        u = e(48),
        f = e(2),
        d = e(8),
        l = e(68),
        h = e(23),
        p = e(105);
      t.exports = function (t, n, e, y, v, x) {
        var m = r[t],
          _ = m,
          b = v ? 'set' : 'add',
          g = _ && _.prototype,
          S = {},
          w = function (t) {
            var n = g[t];
            a(
              g,
              t,
              'delete' == t
                ? function (t) {
                    return !(x && !f(t)) && n.call(this, 0 === t ? 0 : t);
                  }
                : 'has' == t
                ? function (t) {
                    return !(x && !f(t)) && n.call(this, 0 === t ? 0 : t);
                  }
                : 'get' == t
                ? function (t) {
                    return x && !f(t) ? void 0 : n.call(this, 0 === t ? 0 : t);
                  }
                : 'add' == t
                ? function (t) {
                    return n.call(this, 0 === t ? 0 : t), this;
                  }
                : function (t, e) {
                    return n.call(this, 0 === t ? 0 : t, e), this;
                  }
            );
          };
        if (
          'function' == typeof _ &&
          (x ||
            (g.forEach &&
              !d(function () {
                new _().entries().next();
              })))
        ) {
          var C = new _(),
            k = C[b](x ? {} : -0, 1) != C,
            A = d(function () {
              C.has(1);
            }),
            E = l(function (t) {
              new _(t);
            }),
            T =
              !x &&
              d(function () {
                for (var t = new _(), n = 5; n--; ) t[b](n, n);
                return !t.has(-0);
              });
          E ||
            (((_ = n(function (n, e) {
              u(n, _, t);
              var r = p(new m(), n, _);
              return null != e && c(e, v, r[b], r), r;
            })).prototype = g),
            (g.constructor = _)),
            (A || T) && (w('delete'), w('has'), v && w('get')),
            (T || k) && w(b),
            x && g.clear && delete g.clear;
        } else
          (_ = y.getConstructor(n, t, v, b)), i(_.prototype, e), (s.NEED = !0);
        return (
          h(_, t),
          (S[t] = _),
          o(o.G + o.W + o.F * (_ != m), S),
          x || y.setStrong(_, t, v),
          _
        );
      };
    },
    function (t, n, e) {
      var r = e(2),
        o = e(64).set;
      t.exports = function (t, n, e) {
        var a,
          i = n.constructor;
        return (
          i !== e &&
            'function' == typeof i &&
            (a = i.prototype) !== e.prototype &&
            r(a) &&
            o &&
            o(t, a),
          t
        );
      };
    },
    function (t, n, e) {
      'use strict';
      var r = e(5),
        o = e(18),
        a = e(43),
        i = e(29),
        s = e(30),
        c = e(57),
        u = Object.assign;
      t.exports =
        !u ||
        e(8)(function () {
          var t = {},
            n = {},
            e = Symbol(),
            r = 'abcdefghijklmnopqrst';
          return (
            (t[e] = 7),
            r.split('').forEach(function (t) {
              n[t] = t;
            }),
            7 != u({}, t)[e] || Object.keys(u({}, n)).join('') != r
          );
        })
          ? function (t, n) {
              for (
                var e = s(t), u = arguments.length, f = 1, d = a.f, l = i.f;
                u > f;

              )
                for (
                  var h,
                    p = c(arguments[f++]),
                    y = d ? o(p).concat(d(p)) : o(p),
                    v = y.length,
                    x = 0;
                  v > x;

                )
                  (h = y[x++]), (r && !l.call(p, h)) || (e[h] = p[h]);
              return e;
            }
          : u;
    },
    function (t, n, e) {
      'use strict';
      e.r(n);
      var r = {};
      e.r(r),
        e.d(r, 'default', function () {
          return q;
        });
      var o = {};
      e.r(o),
        e.d(o, 'default', function () {
          return at;
        });
      var a = {};
      e.r(a),
        e.d(a, 'default', function () {
          return st;
        });
      e(34), e(37), e(44), e(45), e(46), e(6), e(4), e(9);
      var i = {
          VERSION: '2.0.5',
          DEFAULTS: {
            LANGUAGE: 'en_EN',
            ENCRYPTION: !0,
            ENVIRONMENT: 'production',
            IFRAME_CSS: {
              position: 'fixed',
              bottom: '16px',
              right: '16px',
              height: '55px',
              width: '55px',
              border: 'none',
            },
          },
          ENVIRONMENTS: ['development', 'staging', 'production', 'local'],
          ENVIRONMENT_SHORT_NAMES: {
            development: 'dev',
            staging: 'staging',
            production: 'prod',
            local: 'dev',
          },
          ENVIRONMENT_IDS: { development: 3, staging: 4, production: 5 },
          ENCRYPTED_ENVIRONMENTS: ['staging', 'production'],
          LANGUAGES: ['en_EN'],
          LOGIN_TYPES: ['API', 'KEY_TOKEN'],
          URLS: {
            IFRAME: [
              'https://bluedarwin-chatbot-iframe',
              '.eu-de.mybluemix.net/',
            ],
            API: [
              'https://openwhisk.eu-de.bluemix.net/api/v1/web/bluedarwin_',
              '/default/api',
            ],
          },
          EVENTS: {
            API_READY: 'api:ready',
            API_FAIL: 'api:fail',
            LOGGED_IN: 'login:success',
            LOGGED_OUT: 'logout:success',
            LOGIN_FAIL: 'login:fail',
            CONVERSATION_REPLY_FAIL: 'conversation-reply:fail',
            CONVERSATION_UPDATE: 'conversation:updated',
            TOKEN_NEGOTIATION_REQUIRED: 'x-access-token:negotiation-required',
            IFRAME_LOADED: 'iframe:loaded',
          },
          STATES: {
            API_READY: 'api-ready',
            ENVIRONMENT: 'environment',
            MODEL_MODULE: 'model-am-module',
            MODEL_CHANNELS: 'modal-am-module-channels',
            MODEL_INTENT: 'modal-am-module-intent',
            MODEL_SESSION: 'modal-session',
            URL_API: 'url-api',
            URL_IFRAME: 'url-iframe',
            IS_ENCRYPTED: 'is-encrypted',
            IS_LOGGED_IN: 'is-logged-in',
            IS_INITIALIZED: 'is-initialized',
            HAS_MODULE: 'has-module',
            HAS_CHATBOT_USER: 'has-chatbot-user',
            HAS_CLIENT_USER_ID: 'has-client-user-id',
            HAS_USER: 'has-user',
            HAS_TOKEN: 'has-token',
            HAS_PROJECT: 'has-project',
            HAS_KEY: 'has-key',
            LOGIN_METHOD: 'login-method',
            ELEMENT_IFRAME: 'element-iframe',
            IS_IFRAME_IN_DEBUG_MODE: 'is-iframe-in-debug-mode',
            CONVERSATION: 'conversation',
            CHANNEL_TOKEN: 'channel-token',
          },
          STORAGE: {
            USER: 'user',
            KEY: 'key',
            TOKEN: 'token',
            OLD_KEY: 'old-key',
            OLD_TOKEN: 'old-token',
          },
        },
        s = {
          original: { environment: 'production', language: 'en_EN' },
          possible: {
            environment: ['development', 'staging', 'production', 'local'],
            language: ['en_EN'],
          },
        };
      var c = function (t, n) {
        t.forEach((t) => {
          let e;
          try {
            e = new t();
          } catch (n) {
            e = t;
          }
          let r = e.constructor.name;
          'Object' === e.constructor.name &&
            ((n.Configuration = e), (r = 'Configuration')),
            (n[r] = e);
        });
      };
      const u = {};
      class f {
        constructor() {
          const t = this.constructor.name;
          return (
            u[t] ||
              ((u[t] = this),
              c([...arguments], u[t]),
              u.Configuration &&
                !u.Configuration.environment &&
                u[t].Configuration &&
                (u.Configuration = u[t].Configuration)),
            u[t]
          );
        }
      }
      const d = {
        environment: s.original.environment,
        url: { api: '', iframe: '' },
        encryption: !0,
        language: s.original.language,
      };
      let l;
      class h extends f {
        constructor(t = {}) {
          if ((super(...arguments), !l)) {
            switch (
              (Object.keys(t).forEach((n) => {
                const e = s.original[n],
                  r = s.possible[n];
                e && r.indexOf(t[n]) > -1 && (d[n] = t[n]);
              }),
              d.environment)
            ) {
              case 'development':
                (d.encryption = !1),
                  (d.url.api =
                    'https://openwhisk.eu-de.bluemix.net/api/v1/web/bluedarwin_dev/default/api'),
                  (d.url.iframe =
                    'https://bluedarwin-chatbot-dev.eu-de.mybluemix.net/');
                break;
              case 'local':
                (d.encryption = !1),
                  (d.url.api =
                    'https://openwhisk.eu-de.bluemix.net/api/v1/web/bluedarwin_dev/default/api'),
                  (d.url.iframe = 'http://localhost:4201');
                break;
              case 'staging':
                (d.encryption = !0),
                  (d.url.api =
                    'https://openwhisk.eu-de.bluemix.net/api/v1/web/bluedarwin_staging/default/api'),
                  (d.url.iframe =
                    'https://bluedarwin-chatbot-staging.eu-de.mybluemix.net/');
                break;
              case 'production':
                (d.encryption = !0),
                  (d.url.api =
                    'https://openwhisk.eu-de.bluemix.net/api/v1/web/bluedarwin_prod/default/api'),
                  (d.url.iframe =
                    'https://bluedarwin-chatbot.eu-de.mybluemix.net/');
            }
            (l = d), Object.freeze(d), Object.freeze(l);
          }
          return l;
        }
      }
      var p = function (t, n = new h()) {
          return `${n.url.api}/${t
            .split('/')
            .filter((t) => '' !== t)
            .join('/')}`;
        },
        y = e(20),
        v = e.n(y);
      var x = function (t = !1) {
        return t;
      };
      var m = function (t, n) {
        return x(n) ? v.a.oneWayEncrypt(t) : t;
      };
      var _ = {
          DEFAULTS: {
            LANGUAGE: 'en_EN',
            ENCRYPTION: !0,
            ENVIRONMENT: 'production',
            IFRAME_CSS: {
              position: 'absolute',
              bottom: 0,
              right: '5px',
              height: '550px',
              width: '330px',
              border: 'none',
            },
            URL_API:
              'https://openwhisk.eu-de.bluemix.net/api/v1/web/bluedarwin_prod/default/api',
            URL_IFRAME: 'https://bluedarwin-chatbot.eu-de.mybluemix.net/',
          },
          ENVIRONMENTS: ['development', 'staging', 'production', 'local'],
          ENVIRONMENT_SHORT_NAMES: {
            development: 'dev',
            staging: 'staging',
            production: 'prod',
          },
          ENVIRONMENT_IDS: { development: 3, staging: 4, production: 5 },
          ENCRYPTED_ENVIRONMENTS: ['staging', 'production'],
          LANGUAGES: ['en_EN'],
          LOGIN_TYPES: ['API', 'KEY_TOKEN'],
          URLS: {
            IFRAME: ['https://cognus-chatbot', '.eu-de.mybluemix.net/'],
            API: [
              'https://openwhisk.eu-de.bluemix.net/api/v1/web/bluedarwin_',
              '/default/api',
            ],
          },
          EVENTS: {
            API_READY: 'api:ready',
            API_FAIL: 'api:fail',
            LOGGED_IN: 'login:success',
            LOGGED_OUT: 'logout:success',
            LOGIN_FAIL: 'login:fail',
            CONVERSATION_REPLY_FAIL: 'conversation-reply:fail',
            CONVERSATION_UPDATE: 'conversation:updated',
            TOKEN_NEGOTIATION_REQUIRED: 'x-access-token:negotiation-required',
          },
          STATES: {
            API_READY: 'api-ready',
            ENVIRONMENT: 'environment',
            MODEL_MODULE: 'model-am-module',
            MODEL_CHANNELS: 'modal-am-module-channels',
            MODEL_INTENT: 'modal-am-module-intent',
            MODEL_SESSION: 'modal-session',
            URL_API: 'url-api',
            URL_IFRAME: 'url-iframe',
            IS_ENCRYPTED: 'is-encrypted',
            IS_LOGGED_IN: 'is-logged-in',
            IS_INITIALIZED: 'is-initialized',
            HAS_MODULE: 'has-module',
            HAS_CHATBOT_USER: 'has-chatbot-user',
            HAS_CLIENT_USER_ID: 'has-client-user-id',
            HAS_USER: 'has-user',
            HAS_TOKEN: 'has-token',
            HAS_PROJECT: 'has-project',
            HAS_KEY: 'has-key',
            LOGIN_METHOD: 'login-method',
            ELEMENT_IFRAME: 'element-iframe',
            IS_IFRAME_IN_DEBUG_MODE: 'is-iframe-in-debug-mode',
            CONVERSATION: 'conversation',
            CHANNEL_TOKEN: 'channel-token',
          },
          STORAGE: {
            USER: 'user',
            KEY: 'key',
            TOKEN: 'token',
            OLD_KEY: 'old-key',
            OLD_TOKEN: 'old-token',
          },
        },
        b = e(12),
        g = e.n(b);
      class S extends f {
        constructor(
          t = {
            options: {
              driver: void 0,
              name: void 0,
              size: void 0,
              storeName: void 0,
            },
          }
        ) {
          switch (t.driver) {
            case 'localstorage':
              t.driver = g.a.LOCALSTORAGE;
          }
          g.a.config(t), g.a.ready().catch((t) => {}), super();
        }
        get(t) {
          return g.a.getItem(t).catch((t) => {});
        }
        set(t, n) {
          g.a.setItem(t, n).catch((t) => {});
        }
        delete(t) {
          g.a.removeItem(t).catch((t) => {});
        }
        clear() {
          g.a.clear().catch((t) => {});
        }
      }
      var w = function (t, n = { key: '', oldKey: '' }, e = new S()) {
        (n.oldKey = n.key),
          (n.key = t),
          e.set(_.STORAGE.OLD_KEY, n.oldKey),
          e.set(_.STORAGE.KEY, n.key);
      };
      var C = function (t, n, e) {
          return x(e) ? { cognus: v.a.twoWayEncrypt(t, n) } : t;
        },
        k = e(33),
        A = e.n(k);
      function E(t, n) {
        const e = v.a.twoWayDecrypt(t.cognus || t.data || t.error || t, n);
        return JSON.parse(e);
      }
      var T = function (t, n = '', e = '', r, o) {
        if (!x(r)) return t;
        if (!A()(t) || (!t.cognus && !t.error && !t.data))
          throw { message: 'ERROR.INVALID_COGNUS_RESPONSE_OBJECT' };
        if (t.error) return t;
        try {
          return E(t, o || n);
        } catch (n) {
          try {
            return E(t, o || e);
          } catch (t) {
            throw { data: t, message: 'ERROR.FAILED_TO_DECRYPT' };
          }
        }
      };
      let O = { key: '', oldKey: '' };
      class j extends f {
        constructor() {
          super(h, S);
        }
        encryptString(t) {
          return m(t, this.Configuration.encryption);
        }
        encryptPayload(t) {
          return C(t, O.key, this.Configuration.encryption);
        }
        decryptPayload(t, n) {
          return T(t, O.key, O.oldKey, this.Configuration.encryption, n);
        }
        updateKey(t) {
          w(t, (O = O), this.Storage);
        }
      }
      var B = function (t, n = { token: '' }, e = new S()) {
          (n.token = t), e.set(_.STORAGE.TOKEN, t);
        },
        R = e(73),
        I = e.n(R),
        W = e(26),
        M = e.n(W);
      var P = function (t) {
        return t.split(')').splice(1).join(')');
      };
      var H = function (t, n) {
        return !(!M()(t) || !M()(n)) && P(t.toString()) === P(n.toString());
      };
      var L = function (t, n) {
        if (!Array.isArray(t)) return !1;
        for (let e = 0; e < t.length; e++) if (H(t[e], n)) return !0;
        return !1;
      };
      class N extends f {
        constructor() {
          super();
        }
        getFunctionContent(t) {
          return P(t);
        }
        isEmpty(t) {
          return I()(t);
        }
        isFunction(t) {
          return M()(t);
        }
        isEqualFunction(t, n) {
          return H(t, n);
        }
        containsFunction(t, n) {
          return L(t, n);
        }
      }
      var D = function (
        t,
        n = { token: '' },
        e = new N(),
        r = new j(),
        o = new S()
      ) {
        const a = t.token,
          i = t.key;
        a && e.isFunction(B) && B(a, n, o), i && r.updateKey(i);
      };
      const F = {};
      class X extends f {
        constructor() {
          super(N);
        }
        on(t = '*', n) {
          !this.Validator.isFunction(n) ||
            (F[t] && this.Validator.containsFunction(F[t], n)) ||
            ((F[t] = F[t] || this.reset(t)), F[t].push(n));
        }
        off(t = '*', n) {
          if (F[t] && Array.isArray(F[t]))
            for (let e = 0; e < F[t].length; e++)
              if (F[t][e] === n) {
                F[t].splice(e, 1);
                break;
              }
        }
        emit(t = '*', n) {
          F[t] &&
            F[t].forEach((t) => {
              t(n);
            });
        }
        reset(t = '*') {
          let n = [];
          return (F[t] = n), n;
        }
        getEvents() {
          return F;
        }
      }
      var J = function (t = new X()) {
        t.emit(_.EVENTS.TOKEN_NEGOTIATION_REQUIRED);
      };
      let z;
      if (!z)
        try {
          z = fetch;
        } catch (t) {
          try {
            z = e(92);
          } catch (t) {}
        }
      var U = async function (t, n) {
        let e = await z(t, n);
        const r = await e.json();
        return { response: e, data: r };
      };
      const K = { loginDecryption: !1, getFullResponse: !1 };
      var G = async function (
          t,
          n,
          e = K,
          r = { token: '' },
          o = new j(),
          a = new N(),
          i = new S(),
          s = new X()
        ) {
          try {
            if (
              ((n = e.loginDecryption
                ? o.decryptPayload(n, e.loginDecryption)
                : o.decryptPayload(n)),
              D(n, r, a, o, i),
              (n = e.getFullResponse ? n : n.data || n.error || n),
              200 === t.status)
            )
              return n;
            throw (
              ((401 !== t.status && 403 !== t.status) || J(s),
              t.status,
              n.cognus ? o.decryptPayload(n) : n)
            );
          } catch (t) {
            throw t;
          }
        },
        q = { data: !1, message: !1 };
      const V = { returnType: 'PATH' };
      var Y = function (t = {}, n = '', e = V) {
        const r = n.split('.');
        let o = t;
        for (let t = 0; t < r.length; t++) {
          const e = o[r[t]];
          if (!e) return 'PATH' === V.returnType ? n : void 0;
          o = e;
        }
        return o;
      };
      let $;
      class Q extends f {
        constructor(t = {}) {
          super(h), this.setLanguage(t || this.Configuration.language);
        }
        setLanguage(t = {}) {
          $ = t;
        }
        instant(t = '') {
          return 'string' == typeof t && t.trim().length > 0 ? Y($, t) : t;
        }
      }
      const Z = ['OK', 'WARN', 'FAIL'],
        tt = function (t, n, e) {
          return { status: Z[t], data: n.data, message: e.instant(n.message) };
        };
      class nt extends f {
        constructor() {
          super(Q);
        }
        ok(t = r) {
          return tt(0, t, this.Translate);
        }
        warn(t = r) {
          return tt(1, t, this.Translate);
        }
        error(t = r) {
          return tt(2, t, this.Translate);
        }
      }
      var et = function (t, n = new nt(), e = new j()) {
        try {
          const r = e.decryptPayload(t);
          return n.error({ data: r, message: 'ERROR.HTTP_REQUEST_FAIL' });
        } catch (t) {
          return n.error({ data: t, message: 'ERROR.FAILED_TO_DECRYPT' });
        }
      };
      var rt = function (t = { token: '' }) {
        return {
          'Content-Type': 'application/json',
          'x-access-token': t.token,
        };
      };
      var ot = async function (
          t,
          n,
          e = { token: '' },
          r = new h(),
          o = new j(),
          a = new nt(),
          i = new N(),
          s = new S(),
          c = new X()
        ) {
          try {
            let a = p(t, r),
              u = { method: 'GET', headers: rt(e) },
              { response: f, data: d } = await U(a, u);
            return G(f, d, n, e, o, i, s, c);
          } catch (t) {
            throw et(t, a, o);
          }
        },
        at = { skipEncryption: !1 };
      var it = function (t = {}, n = o, e = new j()) {
          return (
            n.skipEncryption || (t = e.encryptPayload(t)), JSON.stringify(t)
          );
        },
        st = { skipEncryption: !1, loginDecryption: !1, getFullResponse: !1 };
      var ct = async function (
        t,
        n,
        e = a,
        r,
        o = new h(),
        i = new j(),
        s = new nt(),
        c = new N(),
        u = new S(),
        f = new X()
      ) {
        try {
          let a = p(t, o),
            s = { method: 'POST', headers: rt(r), body: it(n, e, i) },
            { response: d, data: l } = await U(a, s);
          return G(d, l, e, r, i, c, u, f);
        } catch (t) {
          throw et(t, s, i);
        }
      };
      const ut = { token: '' };
      class ft extends f {
        constructor() {
          super(h, j);
        }
        get(t = '', n = a) {
          return ot(
            t,
            n,
            ut,
            this.Configuration,
            this.Encryption,
            this.Response,
            this.Validator,
            this.Storage,
            this.PubSub
          );
        }
        post(t = '', n = {}, e = a) {
          return ct(
            t,
            n,
            e,
            ut,
            this.Configuration,
            this.Encryption,
            this.Response,
            this.Validator,
            this.Storage,
            this.PubSub
          );
        }
        updateToken(t = '') {
          return B(t, ut, this.Storage);
        }
      }
      var dt = function () {
        var t =
          arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : new ft();
        return t.get('am_modules');
      };
      let lt = {};
      class ht extends f {
        constructor() {
          super();
        }
        set(t, n) {
          return (lt[t] = n);
        }
        get(t) {
          return lt[t];
        }
        list() {
          return lt;
        }
        delete(t) {
          lt[t] = void 0;
        }
        clear() {
          lt = {};
        }
      }
      var pt = function (t) {
        var n =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : new ft(),
          e =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : new ht();
        return n.get('am_modules/'.concat(t || e.get(_.STATES.HAS_MODULE)));
      };
      var yt = e(93);
      var vt = function (t = new ht()) {
          const n = t.get(_.STATES.HAS_USER).id;
          let e = t.get(_.STATES.HAS_CLIENT_USER_ID);
          if (!n) throw 'To get a chatbot user, you need a valid user with id';
          return (
            e || ((e = yt()), t.set(_.STATES.HAS_CLIENT_USER_ID, e)),
            `cb_${n}-${e}`
          );
        },
        xt = function (t) {
          var n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : new ft(),
            e =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : new ht();
          return n.get('am_client_users?client_user_id='.concat(vt(e)));
        };
      const mt = function (t, n = {}, e = new ht()) {
        const r = {
          auth: {
            channel_token: e.get(_.STATES.CHANNEL_TOKEN),
            client_user_id: vt(e),
            stage: _.ENVIRONMENT_IDS[e.get(_.STATES.ENVIRONMENT)],
          },
          context_variables: {
            extracted_entities: [],
            actions: { close_session: { enabled: !1 } },
          },
          input: t,
        };
        return (
          n.logout && (r.context_variables.actions.close_session.enabled = !0),
          r
        );
      };
      var _t = {
          v3: {
            text: function (t, n = new ht()) {
              return mt({ text: t }, {}, n);
            },
            voice: function (t, n = new ht()) {
              return mt({ voice: t }, {}, n);
            },
            postBack: function (t, n = new ht()) {
              return (
                A()(t) ||
                  (t = {
                    name: null,
                    label: null,
                    type: null,
                    value: null,
                    argType: null,
                  }),
                (t.type = t.argType),
                delete t.argType,
                mt({ postback: t }, {}, n)
              );
            },
            logout: function (t = new ht()) {
              return mt({}, { logout: !0 }, t);
            },
          },
        },
        bt = function (t) {
          var n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : new ft(),
            e =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : new ht();
          return n.post('orchestrator_v3', _t.v3.logout(e));
        },
        gt = {
          ERROR: {
            MODULE_NOT_FOUND: "The following module wan't found",
            SESSION_CREATE_WITHOUT_LOGIN_OR_INIT:
              'To create a session you need a loaded module and user, please run login and init.',
            GET_OR_CREATE_SESSION: 'Error at getOrCreateSession()',
            LOGIN_FAIL: 'Login Failed',
            ENCRYPTION_NOT_INITIALIZED: 'Encryption not initialized',
            INVALID_COGNUS_RESPONSE_OBJECT:
              'To decrypt a payload you must send a valid CognusResponseObject',
            FAILED_TO_DECRYPT: 'Failed to decrypt',
            HTTP_REQUEST_FAIL: 'Http request failed',
          },
          WARN: {
            ALREADY_INSTANCIATED: 'Already instanciated',
            NO_IFRAME_ELEMENT_FOUND:
              "Can't send postback events if no element is found",
          },
        };
      var St = function (
        t,
        n = new ft(),
        e = new j(),
        r = new ht(),
        o = new S(),
        a = new nt()
      ) {
        const i = (t = t.data || t).token,
          s = t.key,
          c = t.user || {};
        return (
          e.updateKey(s),
          n.updateToken(i),
          r.set(_.STATES.HAS_USER, c),
          r.set(_.STATES.HAS_TOKEN, i),
          r.set(_.STATES.HAS_KEY, s),
          o.set(_.STORAGE.USER, c),
          Promise.resolve(a.ok({ token: i, key: s, user: c }))
        );
      };
      var wt = function (t = new ht()) {
        t.set(_.STATES.IS_LOGGED_IN, !0);
      };
      var Ct = async function (
        t,
        n = new ft(),
        e = new j(),
        r = new X(),
        o = new nt(),
        a = new S(),
        i = new ht()
      ) {
        try {
          let s;
          const c = t[0],
            u = t[1];
          return (
            (s =
              (s = await n.post(
                'letmein',
                { email: c, password: e.encryptString(u) },
                { skipEncryption: !0, loginDecryption: u, getFullResponse: !0 }
              )).data || s),
            await St(s, n, e, i, a, o),
            wt(i),
            r.emit(_.EVENTS.LOGGED_IN),
            o.ok({ data: { id: s.user.id, key: s.key, token: s.token } })
          );
        } catch (t) {
          throw (
            (r.emit(_.EVENTS.LOGIN_FAIL),
            o.error({ data: t, message: 'ERROR.LOGIN_FAIL' }))
          );
        }
      };
      const kt = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      var At = function (t) {
        return kt.test(t);
      };
      var Et = function (t, n = new ht()) {
        let e = _.LOGIN_TYPES[1];
        return (
          ('cognus' === t || At(t)) && (e = _.LOGIN_TYPES[0]),
          n.set(_.STATES.LOGIN_METHOD, e),
          e
        );
      };
      var Tt = function (
          t,
          n = new ht(),
          e = new ft(),
          r = new j(),
          o = new X(),
          a = new nt(),
          i = new S()
        ) {
          const s = Et(t[0], n);
          return (
            n.set(_.STATES.LOGIN_METHOD, s),
            s === _.LOGIN_TYPES[0]
              ? Ct(t, e, r, o, a, i, n)
              : St(t, e, r, n, i, a)
          );
        },
        Ot = new RegExp(
          '^.*(' +
            [
              '\\+https:\\/\\/developers.google.com\\/\\+\\/web\\/snippet\\/',
              'googlebot',
              'baiduspider',
              'gurujibot',
              'yandexbot',
              'slurp',
              'msnbot',
              'bingbot',
              'facebookexternalhit',
              'linkedinbot',
              'twitterbot',
              'slackbot',
              'telegrambot',
              'applebot',
              'pingdom',
              'tumblr ',
              'Embedly',
              'spbot',
            ].join('|') +
            ').*$'
        ),
        jt = function (t) {
          t = t || {};
          var n = {
            version: !1,
            language: !1,
            platform: !0,
            os: !0,
            pixelDepth: !0,
            colorDepth: !0,
            resolution: !1,
            isAuthoritative: !0,
            silkAccelerated: !0,
            isKindleFire: !0,
            isDesktop: !0,
            isMobile: !0,
            isTablet: !0,
            isWindows: !0,
            isLinux: !0,
            isLinux64: !0,
            isChromeOS: !0,
            isMac: !0,
            isiPad: !0,
            isiPhone: !0,
            isiPod: !0,
            isAndroid: !0,
            isSamsung: !0,
            isSmartTV: !0,
            isRaspberry: !0,
            isBlackberry: !0,
            isTouchScreen: !0,
            isOpera: !1,
            isIE: !1,
            isEdge: !1,
            isIECompatibilityMode: !1,
            isSafari: !1,
            isFirefox: !1,
            isWebkit: !1,
            isChrome: !1,
            isKonqueror: !1,
            isOmniWeb: !1,
            isSeaMonkey: !1,
            isFlock: !1,
            isAmaya: !1,
            isPhantomJS: !1,
            isEpiphany: !1,
            source: !1,
            cpuCores: !1,
          };
          for (var e in t)
            t.hasOwnProperty(e) && void 0 !== n[e] && (n[e] = t[e]);
          return (
            (this.options = n),
            (this.version = '1.0.0'),
            (this._Versions = {
              Edge: /Edge\/([\d\w\.\-]+)/i,
              Firefox: /firefox\/([\d\w\.\-]+)/i,
              IE: /msie\s([\d\.]+[\d])|trident\/\d+\.\d+;.*[rv:]+(\d+\.\d)/i,
              Chrome: /chrome\/([\d\w\.\-]+)/i,
              Chromium: /(?:chromium|crios)\/([\d\w\.\-]+)/i,
              Safari: /version\/([\d\w\.\-]+)/i,
              Opera: /version\/([\d\w\.\-]+)|OPR\/([\d\w\.\-]+)/i,
              Ps3: /([\d\w\.\-]+)\)\s*$/i,
              Psp: /([\d\w\.\-]+)\)?\s*$/i,
              Amaya: /amaya\/([\d\w\.\-]+)/i,
              SeaMonkey: /seamonkey\/([\d\w\.\-]+)/i,
              OmniWeb: /omniweb\/v([\d\w\.\-]+)/i,
              Flock: /flock\/([\d\w\.\-]+)/i,
              Epiphany: /epiphany\/([\d\w\.\-]+)/i,
              WinJs: /msapphost\/([\d\w\.\-]+)/i,
              PhantomJS: /phantomjs\/([\d\w\.\-]+)/i,
              UC: /UCBrowser\/([\d\w\.]+)/i,
            }),
            (this._Browsers = {
              Edge: /edge/i,
              Amaya: /amaya/i,
              Konqueror: /konqueror/i,
              Epiphany: /epiphany/i,
              SeaMonkey: /seamonkey/i,
              Flock: /flock/i,
              OmniWeb: /omniweb/i,
              Chromium: /chromium|crios/i,
              Chrome: /chrome/i,
              Safari: /safari/i,
              IE: /msie|trident/i,
              Opera: /opera|OPR/i,
              PS3: /playstation 3/i,
              PSP: /playstation portable/i,
              Firefox: /firefox/i,
              WinJs: /msapphost/i,
              PhantomJS: /phantomjs/i,
              UC: /UCBrowser/i,
            }),
            (this._OS = {
              Windows10: /windows nt 10\.0/i,
              Windows81: /windows nt 6\.3/i,
              Windows8: /windows nt 6\.2/i,
              Windows7: /windows nt 6\.1/i,
              UnknownWindows: /windows nt 6\.\d+/i,
              WindowsVista: /windows nt 6\.0/i,
              Windows2003: /windows nt 5\.2/i,
              WindowsXP: /windows nt 5\.1/i,
              Windows2000: /windows nt 5\.0/i,
              WindowsPhone8: /windows phone 8\./,
              OSXCheetah: /os x 10[._]0/i,
              OSXPuma: /os x 10[._]1(\D|$)/i,
              OSXJaguar: /os x 10[._]2/i,
              OSXPanther: /os x 10[._]3/i,
              OSXTiger: /os x 10[._]4/i,
              OSXLeopard: /os x 10[._]5/i,
              OSXSnowLeopard: /os x 10[._]6/i,
              OSXLion: /os x 10[._]7/i,
              OSXMountainLion: /os x 10[._]8/i,
              OSXMavericks: /os x 10[._]9/i,
              OSXYosemite: /os x 10[._]10/i,
              OSXElCapitan: /os x 10[._]11/i,
              OSXSierra: /os x 10[._]12/i,
              Mac: /os x/i,
              Linux: /linux/i,
              Linux64: /linux x86_64/i,
              ChromeOS: /cros/i,
              Wii: /wii/i,
              PS3: /playstation 3/i,
              PSP: /playstation portable/i,
              iPad: /\(iPad.*os (\d+)[._](\d+)/i,
              iPhone: /\(iPhone.*os (\d+)[._](\d+)/i,
              Bada: /Bada\/(\d+)\.(\d+)/i,
              Curl: /curl\/(\d+)\.(\d+)\.(\d+)/i,
            }),
            (this._Platform = {
              Windows: /windows nt/i,
              WindowsPhone: /windows phone/i,
              Mac: /macintosh/i,
              Linux: /linux/i,
              Wii: /wii/i,
              Playstation: /playstation/i,
              iPad: /ipad/i,
              iPod: /ipod/i,
              iPhone: /iphone/i,
              Android: /android/i,
              Blackberry: /blackberry/i,
              Samsung: /samsung/i,
              Curl: /curl/i,
            }),
            (this.DefaultAgent = {
              isAuthoritative: !0,
              isMobile: !1,
              isTablet: !1,
              isiPad: !1,
              isiPod: !1,
              isiPhone: !1,
              isAndroid: !1,
              isBlackberry: !1,
              isOpera: !1,
              isIE: !1,
              isEdge: !1,
              isIECompatibilityMode: !1,
              isSafari: !1,
              isFirefox: !1,
              isWebkit: !1,
              isChrome: !1,
              isKonqueror: !1,
              isOmniWeb: !1,
              isSeaMonkey: !1,
              isFlock: !1,
              isAmaya: !1,
              isPhantomJS: !1,
              isEpiphany: !1,
              isDesktop: !1,
              isWindows: !1,
              isLinux: !1,
              isLinux64: !1,
              isMac: !1,
              isChromeOS: !1,
              isBada: !1,
              isSamsung: !1,
              isRaspberry: !1,
              isBot: !1,
              isCurl: !1,
              isAndroidTablet: !1,
              isWinJs: !1,
              isKindleFire: !1,
              isSilk: !1,
              isCaptive: !1,
              isSmartTV: !1,
              isUC: !1,
              isTouchScreen: !1,
              silkAccelerated: !1,
              colorDepth: -1,
              pixelDepth: -1,
              resolution: [],
              cpuCores: -1,
              language: 'unknown',
              browser: 'unknown',
              version: 'unknown',
              os: 'unknown',
              platform: 'unknown',
              geoIp: {},
              source: '',
              hashInt: function (t) {
                var n,
                  e,
                  r = 0;
                if (0 === t.length) return r;
                for (n = 0, e = t.length; n < e; n++)
                  (r = (r << 5) - r + t.charCodeAt(n)), (r |= 0);
                return r;
              },
              hashMD5: function (t) {
                function n(t, n) {
                  return (t << n) | (t >>> (32 - n));
                }
                function e(t, n) {
                  var e, r, o, a, i;
                  return (
                    (o = 2147483648 & t),
                    (a = 2147483648 & n),
                    (i = (1073741823 & t) + (1073741823 & n)),
                    (e = 1073741824 & t) & (r = 1073741824 & n)
                      ? 2147483648 ^ i ^ o ^ a
                      : e | r
                      ? 1073741824 & i
                        ? 3221225472 ^ i ^ o ^ a
                        : 1073741824 ^ i ^ o ^ a
                      : i ^ o ^ a
                  );
                }
                function r(t, r, o, a, i, s, c) {
                  return (
                    (t = e(
                      t,
                      e(
                        e(
                          (function (t, n, e) {
                            return (t & n) | (~t & e);
                          })(r, o, a),
                          i
                        ),
                        c
                      )
                    )),
                    e(n(t, s), r)
                  );
                }
                function o(t, r, o, a, i, s, c) {
                  return (
                    (t = e(
                      t,
                      e(
                        e(
                          (function (t, n, e) {
                            return (t & e) | (n & ~e);
                          })(r, o, a),
                          i
                        ),
                        c
                      )
                    )),
                    e(n(t, s), r)
                  );
                }
                function a(t, r, o, a, i, s, c) {
                  return (
                    (t = e(
                      t,
                      e(
                        e(
                          (function (t, n, e) {
                            return t ^ n ^ e;
                          })(r, o, a),
                          i
                        ),
                        c
                      )
                    )),
                    e(n(t, s), r)
                  );
                }
                function i(t, r, o, a, i, s, c) {
                  return (
                    (t = e(
                      t,
                      e(
                        e(
                          (function (t, n, e) {
                            return n ^ (t | ~e);
                          })(r, o, a),
                          i
                        ),
                        c
                      )
                    )),
                    e(n(t, s), r)
                  );
                }
                function s(t) {
                  var n,
                    e = '',
                    r = '';
                  for (n = 0; n <= 3; n++)
                    e += (r =
                      '0' + ((t >>> (8 * n)) & 255).toString(16)).substr(
                      r.length - 2,
                      2
                    );
                  return e;
                }
                var c, u, f, d, l, h, p, y, v, x;
                for (
                  c = (function (t) {
                    for (
                      var n,
                        e = t.length,
                        r = e + 8,
                        o = 16 * ((r - (r % 64)) / 64 + 1),
                        a = new Array(o - 1),
                        i = 0,
                        s = 0;
                      s < e;

                    )
                      (i = (s % 4) * 8),
                        (a[(n = (s - (s % 4)) / 4)] =
                          a[n] | (t.charCodeAt(s) << i)),
                        s++;
                    return (
                      (i = (s % 4) * 8),
                      (a[(n = (s - (s % 4)) / 4)] = a[n] | (128 << i)),
                      (a[o - 2] = e << 3),
                      (a[o - 1] = e >>> 29),
                      a
                    );
                  })(
                    (t = (function (t) {
                      t = t.replace(/\r\n/g, '\n');
                      for (var n = '', e = 0; e < t.length; e++) {
                        var r = t.charCodeAt(e);
                        r < 128
                          ? (n += String.fromCharCode(r))
                          : r > 127 && r < 2048
                          ? ((n += String.fromCharCode((r >> 6) | 192)),
                            (n += String.fromCharCode((63 & r) | 128)))
                          : ((n += String.fromCharCode((r >> 12) | 224)),
                            (n += String.fromCharCode(((r >> 6) & 63) | 128)),
                            (n += String.fromCharCode((63 & r) | 128)));
                      }
                      return n;
                    })(t))
                  ),
                    p = 1732584193,
                    y = 4023233417,
                    v = 2562383102,
                    x = 271733878,
                    u = 0;
                  u < c.length;
                  u += 16
                )
                  (f = p),
                    (d = y),
                    (l = v),
                    (h = x),
                    (p = r(p, y, v, x, c[u + 0], 7, 3614090360)),
                    (x = r(x, p, y, v, c[u + 1], 12, 3905402710)),
                    (v = r(v, x, p, y, c[u + 2], 17, 606105819)),
                    (y = r(y, v, x, p, c[u + 3], 22, 3250441966)),
                    (p = r(p, y, v, x, c[u + 4], 7, 4118548399)),
                    (x = r(x, p, y, v, c[u + 5], 12, 1200080426)),
                    (v = r(v, x, p, y, c[u + 6], 17, 2821735955)),
                    (y = r(y, v, x, p, c[u + 7], 22, 4249261313)),
                    (p = r(p, y, v, x, c[u + 8], 7, 1770035416)),
                    (x = r(x, p, y, v, c[u + 9], 12, 2336552879)),
                    (v = r(v, x, p, y, c[u + 10], 17, 4294925233)),
                    (y = r(y, v, x, p, c[u + 11], 22, 2304563134)),
                    (p = r(p, y, v, x, c[u + 12], 7, 1804603682)),
                    (x = r(x, p, y, v, c[u + 13], 12, 4254626195)),
                    (v = r(v, x, p, y, c[u + 14], 17, 2792965006)),
                    (p = o(
                      p,
                      (y = r(y, v, x, p, c[u + 15], 22, 1236535329)),
                      v,
                      x,
                      c[u + 1],
                      5,
                      4129170786
                    )),
                    (x = o(x, p, y, v, c[u + 6], 9, 3225465664)),
                    (v = o(v, x, p, y, c[u + 11], 14, 643717713)),
                    (y = o(y, v, x, p, c[u + 0], 20, 3921069994)),
                    (p = o(p, y, v, x, c[u + 5], 5, 3593408605)),
                    (x = o(x, p, y, v, c[u + 10], 9, 38016083)),
                    (v = o(v, x, p, y, c[u + 15], 14, 3634488961)),
                    (y = o(y, v, x, p, c[u + 4], 20, 3889429448)),
                    (p = o(p, y, v, x, c[u + 9], 5, 568446438)),
                    (x = o(x, p, y, v, c[u + 14], 9, 3275163606)),
                    (v = o(v, x, p, y, c[u + 3], 14, 4107603335)),
                    (y = o(y, v, x, p, c[u + 8], 20, 1163531501)),
                    (p = o(p, y, v, x, c[u + 13], 5, 2850285829)),
                    (x = o(x, p, y, v, c[u + 2], 9, 4243563512)),
                    (v = o(v, x, p, y, c[u + 7], 14, 1735328473)),
                    (p = a(
                      p,
                      (y = o(y, v, x, p, c[u + 12], 20, 2368359562)),
                      v,
                      x,
                      c[u + 5],
                      4,
                      4294588738
                    )),
                    (x = a(x, p, y, v, c[u + 8], 11, 2272392833)),
                    (v = a(v, x, p, y, c[u + 11], 16, 1839030562)),
                    (y = a(y, v, x, p, c[u + 14], 23, 4259657740)),
                    (p = a(p, y, v, x, c[u + 1], 4, 2763975236)),
                    (x = a(x, p, y, v, c[u + 4], 11, 1272893353)),
                    (v = a(v, x, p, y, c[u + 7], 16, 4139469664)),
                    (y = a(y, v, x, p, c[u + 10], 23, 3200236656)),
                    (p = a(p, y, v, x, c[u + 13], 4, 681279174)),
                    (x = a(x, p, y, v, c[u + 0], 11, 3936430074)),
                    (v = a(v, x, p, y, c[u + 3], 16, 3572445317)),
                    (y = a(y, v, x, p, c[u + 6], 23, 76029189)),
                    (p = a(p, y, v, x, c[u + 9], 4, 3654602809)),
                    (x = a(x, p, y, v, c[u + 12], 11, 3873151461)),
                    (v = a(v, x, p, y, c[u + 15], 16, 530742520)),
                    (p = i(
                      p,
                      (y = a(y, v, x, p, c[u + 2], 23, 3299628645)),
                      v,
                      x,
                      c[u + 0],
                      6,
                      4096336452
                    )),
                    (x = i(x, p, y, v, c[u + 7], 10, 1126891415)),
                    (v = i(v, x, p, y, c[u + 14], 15, 2878612391)),
                    (y = i(y, v, x, p, c[u + 5], 21, 4237533241)),
                    (p = i(p, y, v, x, c[u + 12], 6, 1700485571)),
                    (x = i(x, p, y, v, c[u + 3], 10, 2399980690)),
                    (v = i(v, x, p, y, c[u + 10], 15, 4293915773)),
                    (y = i(y, v, x, p, c[u + 1], 21, 2240044497)),
                    (p = i(p, y, v, x, c[u + 8], 6, 1873313359)),
                    (x = i(x, p, y, v, c[u + 15], 10, 4264355552)),
                    (v = i(v, x, p, y, c[u + 6], 15, 2734768916)),
                    (y = i(y, v, x, p, c[u + 13], 21, 1309151649)),
                    (p = i(p, y, v, x, c[u + 4], 6, 4149444226)),
                    (x = i(x, p, y, v, c[u + 11], 10, 3174756917)),
                    (v = i(v, x, p, y, c[u + 2], 15, 718787259)),
                    (y = i(y, v, x, p, c[u + 9], 21, 3951481745)),
                    (p = e(p, f)),
                    (y = e(y, d)),
                    (v = e(v, l)),
                    (x = e(x, h));
                return (s(p) + s(y) + s(v) + s(x)).toLowerCase();
              },
            }),
            (this.Agent = {}),
            (this.getBrowser = function (t) {
              switch (!0) {
                case this._Browsers.Edge.test(t):
                  return (this.Agent.isEdge = !0), 'Edge';
                case this._Browsers.PhantomJS.test(t):
                  return (this.Agent.isPhantomJS = !0), 'PhantomJS';
                case this._Browsers.Konqueror.test(t):
                  return (this.Agent.isKonqueror = !0), 'Konqueror';
                case this._Browsers.Amaya.test(t):
                  return (this.Agent.isAmaya = !0), 'Amaya';
                case this._Browsers.Epiphany.test(t):
                  return (this.Agent.isEpiphany = !0), 'Epiphany';
                case this._Browsers.SeaMonkey.test(t):
                  return (this.Agent.isSeaMonkey = !0), 'SeaMonkey';
                case this._Browsers.Flock.test(t):
                  return (this.Agent.isFlock = !0), 'Flock';
                case this._Browsers.OmniWeb.test(t):
                  return (this.Agent.isOmniWeb = !0), 'OmniWeb';
                case this._Browsers.Opera.test(t):
                  return (this.Agent.isOpera = !0), 'Opera';
                case this._Browsers.Chromium.test(t):
                  return (this.Agent.isChrome = !0), 'Chromium';
                case this._Browsers.Chrome.test(t):
                  return (this.Agent.isChrome = !0), 'Chrome';
                case this._Browsers.Safari.test(t):
                  return (this.Agent.isSafari = !0), 'Safari';
                case this._Browsers.WinJs.test(t):
                  return (this.Agent.isWinJs = !0), 'WinJs';
                case this._Browsers.IE.test(t):
                  return (this.Agent.isIE = !0), 'IE';
                case this._Browsers.PS3.test(t):
                  return 'ps3';
                case this._Browsers.PSP.test(t):
                  return 'psp';
                case this._Browsers.Firefox.test(t):
                  return (this.Agent.isFirefox = !0), 'Firefox';
                case this._Browsers.UC.test(t):
                  return (this.Agent.isUC = !0), 'UCBrowser';
                default:
                  return 0 !== t.indexOf('Mozilla') &&
                    /^([\d\w\-\.]+)\/[\d\w\.\-]+/i.test(t)
                    ? ((this.Agent.isAuthoritative = !1), RegExp.$1)
                    : 'unknown';
              }
            }),
            (this.getBrowserVersion = function (t) {
              switch (this.Agent.browser) {
                case 'Edge':
                  if (this._Versions.Edge.test(t)) return RegExp.$1;
                  break;
                case 'PhantomJS':
                  if (this._Versions.PhantomJS.test(t)) return RegExp.$1;
                  break;
                case 'Chrome':
                  if (this._Versions.Chrome.test(t)) return RegExp.$1;
                  break;
                case 'Chromium':
                  if (this._Versions.Chromium.test(t)) return RegExp.$1;
                  break;
                case 'Safari':
                  if (this._Versions.Safari.test(t)) return RegExp.$1;
                  break;
                case 'Opera':
                  if (this._Versions.Opera.test(t))
                    return RegExp.$1 ? RegExp.$1 : RegExp.$2;
                  break;
                case 'Firefox':
                  if (this._Versions.Firefox.test(t)) return RegExp.$1;
                  break;
                case 'WinJs':
                  if (this._Versions.WinJs.test(t)) return RegExp.$1;
                  break;
                case 'IE':
                  if (this._Versions.IE.test(t))
                    return RegExp.$2 ? RegExp.$2 : RegExp.$1;
                  break;
                case 'ps3':
                  if (this._Versions.Ps3.test(t)) return RegExp.$1;
                  break;
                case 'psp':
                  if (this._Versions.Psp.test(t)) return RegExp.$1;
                  break;
                case 'Amaya':
                  if (this._Versions.Amaya.test(t)) return RegExp.$1;
                  break;
                case 'Epiphany':
                  if (this._Versions.Epiphany.test(t)) return RegExp.$1;
                  break;
                case 'SeaMonkey':
                  if (this._Versions.SeaMonkey.test(t)) return RegExp.$1;
                  break;
                case 'Flock':
                  if (this._Versions.Flock.test(t)) return RegExp.$1;
                  break;
                case 'OmniWeb':
                  if (this._Versions.OmniWeb.test(t)) return RegExp.$1;
                  break;
                case 'UCBrowser':
                  if (this._Versions.UC.test(t)) return RegExp.$1;
                  break;
                default:
                  if (
                    'unknown' !== this.Agent.browser &&
                    new RegExp(
                      this.Agent.browser + '[\\/ ]([\\d\\w\\.\\-]+)',
                      'i'
                    ).test(t)
                  )
                    return RegExp.$1;
              }
            }),
            (this.getOS = function (t) {
              switch (!0) {
                case this._OS.WindowsVista.test(t):
                  return (this.Agent.isWindows = !0), 'Windows Vista';
                case this._OS.Windows7.test(t):
                  return (this.Agent.isWindows = !0), 'Windows 7';
                case this._OS.Windows8.test(t):
                  return (this.Agent.isWindows = !0), 'Windows 8';
                case this._OS.Windows81.test(t):
                  return (this.Agent.isWindows = !0), 'Windows 8.1';
                case this._OS.Windows10.test(t):
                  return (this.Agent.isWindows = !0), 'Windows 10.0';
                case this._OS.Windows2003.test(t):
                  return (this.Agent.isWindows = !0), 'Windows 2003';
                case this._OS.WindowsXP.test(t):
                  return (this.Agent.isWindows = !0), 'Windows XP';
                case this._OS.Windows2000.test(t):
                  return (this.Agent.isWindows = !0), 'Windows 2000';
                case this._OS.WindowsPhone8.test(t):
                  return 'Windows Phone 8';
                case this._OS.Linux64.test(t):
                  return (
                    (this.Agent.isLinux = !0),
                    (this.Agent.isLinux64 = !0),
                    'Linux 64'
                  );
                case this._OS.Linux.test(t):
                  return (this.Agent.isLinux = !0), 'Linux';
                case this._OS.ChromeOS.test(t):
                  return (this.Agent.isChromeOS = !0), 'Chrome OS';
                case this._OS.Wii.test(t):
                  return 'Wii';
                case this._OS.PS3.test(t):
                case this._OS.PSP.test(t):
                  return 'Playstation';
                case this._OS.OSXCheetah.test(t):
                  return (this.Agent.isMac = !0), 'OS X Cheetah';
                case this._OS.OSXPuma.test(t):
                  return (this.Agent.isMac = !0), 'OS X Puma';
                case this._OS.OSXJaguar.test(t):
                  return (this.Agent.isMac = !0), 'OS X Jaguar';
                case this._OS.OSXPanther.test(t):
                  return (this.Agent.isMac = !0), 'OS X Panther';
                case this._OS.OSXTiger.test(t):
                  return (this.Agent.isMac = !0), 'OS X Tiger';
                case this._OS.OSXLeopard.test(t):
                  return (this.Agent.isMac = !0), 'OS X Leopard';
                case this._OS.OSXSnowLeopard.test(t):
                  return (this.Agent.isMac = !0), 'OS X Snow Leopard';
                case this._OS.OSXLion.test(t):
                  return (this.Agent.isMac = !0), 'OS X Lion';
                case this._OS.OSXMountainLion.test(t):
                  return (this.Agent.isMac = !0), 'OS X Mountain Lion';
                case this._OS.OSXMavericks.test(t):
                  return (this.Agent.isMac = !0), 'OS X Mavericks';
                case this._OS.OSXYosemite.test(t):
                  return (this.Agent.isMac = !0), 'OS X Yosemite';
                case this._OS.OSXElCapitan.test(t):
                  return (this.Agent.isMac = !0), 'OS X El Capitan';
                case this._OS.OSXSierra.test(t):
                  return (this.Agent.isMac = !0), 'macOS Sierra';
                case this._OS.Mac.test(t):
                  return (this.Agent.isMac = !0), 'OS X';
                case this._OS.iPad.test(t):
                  return (
                    (this.Agent.isiPad = !0),
                    t.match(this._OS.iPad)[0].replace('_', '.')
                  );
                case this._OS.iPhone.test(t):
                  return (
                    (this.Agent.isiPhone = !0),
                    t.match(this._OS.iPhone)[0].replace('_', '.')
                  );
                case this._OS.Bada.test(t):
                  return (this.Agent.isBada = !0), 'Bada';
                case this._OS.Curl.test(t):
                  return (this.Agent.isCurl = !0), 'Curl';
                default:
                  return 'unknown';
              }
            }),
            (this.getPlatform = function (t) {
              switch (!0) {
                case this._Platform.Windows.test(t):
                  return 'Microsoft Windows';
                case this._Platform.WindowsPhone.test(t):
                  return (
                    (this.Agent.isWindowsPhone = !0), 'Microsoft Windows Phone'
                  );
                case this._Platform.Mac.test(t):
                  return 'Apple Mac';
                case this._Platform.Curl.test(t):
                  return 'Curl';
                case this._Platform.Android.test(t):
                  return (this.Agent.isAndroid = !0), 'Android';
                case this._Platform.Blackberry.test(t):
                  return (this.Agent.isBlackberry = !0), 'Blackberry';
                case this._Platform.Linux.test(t):
                  return 'Linux';
                case this._Platform.Wii.test(t):
                  return 'Wii';
                case this._Platform.Playstation.test(t):
                  return 'Playstation';
                case this._Platform.iPad.test(t):
                  return (this.Agent.isiPad = !0), 'iPad';
                case this._Platform.iPod.test(t):
                  return (this.Agent.isiPod = !0), 'iPod';
                case this._Platform.iPhone.test(t):
                  return (this.Agent.isiPhone = !0), 'iPhone';
                case this._Platform.Samsung.test(t):
                  return (this.Agent.isiSamsung = !0), 'Samsung';
                default:
                  return 'unknown';
              }
            }),
            (this.testCompatibilityMode = function () {
              var t = this;
              if (this.Agent.isIE && /Trident\/(\d)\.0/i.test(t.Agent.source)) {
                var n = parseInt(RegExp.$1, 10),
                  e = parseInt(t.Agent.version, 10);
                7 === e &&
                  7 === n &&
                  ((t.Agent.isIECompatibilityMode = !0),
                  (t.Agent.version = 11)),
                  7 === e &&
                    6 === n &&
                    ((t.Agent.isIECompatibilityMode = !0),
                    (t.Agent.version = 10)),
                  7 === e &&
                    5 === n &&
                    ((t.Agent.isIECompatibilityMode = !0),
                    (t.Agent.version = 9)),
                  7 === e &&
                    4 === n &&
                    ((t.Agent.isIECompatibilityMode = !0),
                    (t.Agent.version = 8));
              }
            }),
            (this.testSilk = function () {
              switch (!0) {
                case new RegExp('silk', 'gi').test(this.Agent.source):
                  this.Agent.isSilk = !0;
              }
              return (
                /Silk-Accelerated=true/gi.test(this.Agent.source) &&
                  (this.Agent.SilkAccelerated = !0),
                !!this.Agent.isSilk && 'Silk'
              );
            }),
            (this.testKindleFire = function () {
              var t = this;
              switch (!0) {
                case /KFOT/gi.test(t.Agent.source):
                  return (this.Agent.isKindleFire = !0), 'Kindle Fire';
                case /KFTT/gi.test(t.Agent.source):
                  return (this.Agent.isKindleFire = !0), 'Kindle Fire HD';
                case /KFJWI/gi.test(t.Agent.source):
                  return (this.Agent.isKindleFire = !0), 'Kindle Fire HD 8.9';
                case /KFJWA/gi.test(t.Agent.source):
                  return (
                    (this.Agent.isKindleFire = !0), 'Kindle Fire HD 8.9 4G'
                  );
                case /KFSOWI/gi.test(t.Agent.source):
                  return (this.Agent.isKindleFire = !0), 'Kindle Fire HD 7';
                case /KFTHWI/gi.test(t.Agent.source):
                  return (this.Agent.isKindleFire = !0), 'Kindle Fire HDX 7';
                case /KFTHWA/gi.test(t.Agent.source):
                  return (this.Agent.isKindleFire = !0), 'Kindle Fire HDX 7 4G';
                case /KFAPWI/gi.test(t.Agent.source):
                  return (this.Agent.isKindleFire = !0), 'Kindle Fire HDX 8.9';
                case /KFAPWA/gi.test(t.Agent.source):
                  return (
                    (this.Agent.isKindleFire = !0), 'Kindle Fire HDX 8.9 4G'
                  );
                default:
                  return !1;
              }
            }),
            (this.testCaptiveNetwork = function () {
              switch (!0) {
                case /CaptiveNetwork/gi.test(this.Agent.source):
                  return (
                    (this.Agent.isCaptive = !0),
                    (this.Agent.isMac = !0),
                    (this.Agent.platform = 'Apple Mac'),
                    'CaptiveNetwork'
                  );
                default:
                  return !1;
              }
            }),
            (this.testMobile = function () {
              var t = this;
              switch (!0) {
                case t.Agent.isWindows:
                case t.Agent.isLinux:
                case t.Agent.isMac:
                case t.Agent.isChromeOS:
                  t.Agent.isDesktop = !0;
                  break;
                case t.Agent.isAndroid:
                case t.Agent.isSamsung:
                  (t.Agent.isMobile = !0), (t.Agent.isDesktop = !1);
              }
              switch (!0) {
                case t.Agent.isiPad:
                case t.Agent.isiPod:
                case t.Agent.isiPhone:
                case t.Agent.isBada:
                case t.Agent.isBlackberry:
                case t.Agent.isAndroid:
                case t.Agent.isWindowsPhone:
                  (t.Agent.isMobile = !0), (t.Agent.isDesktop = !1);
              }
              /mobile/i.test(t.Agent.source) &&
                ((t.Agent.isMobile = !0), (t.Agent.isDesktop = !1));
            }),
            (this.testTablet = function () {
              var t = this;
              switch (!0) {
                case t.Agent.isiPad:
                case t.Agent.isAndroidTablet:
                case t.Agent.isKindleFire:
                  t.Agent.isTablet = !0;
              }
              /tablet/i.test(t.Agent.source) && (t.Agent.isTablet = !0);
            }),
            (this.testNginxGeoIP = function (t) {
              var n = this;
              Object.keys(t).forEach(function (e) {
                /^GEOIP/i.test(e) && (n.Agent.geoIp[e] = t[e]);
              });
            }),
            (this.testBot = function () {
              var t = this,
                n = Ot.exec(t.Agent.source.toLowerCase());
              n
                ? (t.Agent.isBot = n[1])
                : t.Agent.isAuthoritative ||
                  (t.Agent.isBot = /bot/i.test(t.Agent.source));
            }),
            (this.testSmartTV = function () {
              var t = new RegExp(
                'smart-tv|smarttv|googletv|appletv|hbbtv|pov_tv|netcast.tv',
                'gi'
              ).exec(this.Agent.source.toLowerCase());
              t && (this.Agent.isSmartTV = t[1]);
            }),
            (this.testAndroidTablet = function () {
              this.Agent.isAndroid &&
                !/mobile/i.test(this.Agent.source) &&
                (this.Agent.isAndroidTablet = !0);
            }),
            (this.testTouchSupport = function () {
              this.Agent.isTouchScreen =
                'ontouchstart' in window ||
                navigator.maxTouchPoints > 0 ||
                navigator.msMaxTouchPoints > 0;
            }),
            (this.getLaguage = function () {
              this.Agent.language = (
                navigator.language ||
                navigator.userLanguage ||
                navigator.browserLanguage ||
                navigator.systemLanguage ||
                ''
              ).toLowerCase();
            }),
            (this.getColorDepth = function () {
              this.Agent.colorDepth = screen.colorDepth || -1;
            }),
            (this.getScreenResolution = function () {
              this.Agent.resolution = [screen.availWidth, screen.availHeight];
            }),
            (this.getPixelDepth = function () {
              this.Agent.pixelDepth = screen.pixelDepth || -1;
            }),
            (this.getCPU = function () {
              this.Agent.cpuCores = navigator.hardwareConcurrency || -1;
            }),
            (this.reset = function () {
              var t = this;
              for (var n in t.DefaultAgent)
                t.DefaultAgent.hasOwnProperty(n) &&
                  (t.Agent[n] = t.DefaultAgent[n]);
              return t;
            }),
            (this.parse = function (t) {
              t = t || navigator.userAgent;
              var n = new jt();
              return (
                (n.Agent.source = t.replace(/^\s*/, '').replace(/\s*$/, '')),
                (n.Agent.os = n.getOS(n.Agent.source)),
                (n.Agent.platform = n.getPlatform(n.Agent.source)),
                (n.Agent.browser = n.getBrowser(n.Agent.source)),
                (n.Agent.version = n.getBrowserVersion(n.Agent.source)),
                n.testBot(),
                n.testSmartTV(),
                n.testMobile(),
                n.testAndroidTablet(),
                n.testTablet(),
                n.testCompatibilityMode(),
                n.testSilk(),
                n.testKindleFire(),
                n.testCaptiveNetwork(),
                n.testTouchSupport(),
                n.getLaguage(),
                n.getColorDepth(),
                n.getPixelDepth(),
                n.getScreenResolution(),
                n.getCPU(),
                n.Agent
              );
            }),
            (this.get = function (t) {
              var n = this.parse(),
                e = [];
              for (var r in this.options)
                this.options.hasOwnProperty(r) &&
                  !0 === this.options[r] &&
                  e.push(n[r]);
              t && e.push(t),
                !this.options.resolution && n.isMobile && e.push(n.resolution);
              var o = n.hashMD5(e.join(':'));
              return [
                o.slice(0, 8),
                o.slice(8, 12),
                '4' + o.slice(12, 15),
                'b' + o.slice(15, 18),
                o.slice(20),
              ].join('-');
            }),
            (this.Agent = this.DefaultAgent),
            this
          );
        };
      var Bt = {
        info: () => new jt().parse(),
        machine() {
          var t = localStorage.getItem('bluedarwin-chatbot__machine_uuid');
          return (
            t ||
            ((t =
              new jt().get() +
              '_' +
              new Date().getTime() +
              '_' +
              'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
                /[xy]/g,
                function (t) {
                  var n = (16 * Math.random()) | 0;
                  return ('x' == t ? n : (3 & n) | 8).toString(16);
                }
              )),
            localStorage.setItem('bluedarwin-chatbot__machine_uuid', t),
            t)
          );
        },
      };
      var Rt = async function (
        t,
        n = new ht(),
        e = new ft(),
        r = new j(),
        o = new X(),
        a = new nt(),
        i = new S()
      ) {
        try {
          let s;
          const c = t[0],
            u = t[1];
          let f = localStorage.getItem('bluedarwin-chatbot__machine_uuid');
          return (
            f ||
              ((f = Bt.machine() + Math.random().toString(36).substring(10)),
              localStorage.setItem('bluedarwin-chatbot__machine_uuid', f)),
            (s =
              (s = await e.post(
                'let-the-chatbot-in-v2',
                { channelToken: c, apiKey: u, machineUuid: f },
                {
                  skipEncryption: !0,
                  loginDecryption: t[1],
                  getFullResponse: !0,
                }
              )).data || s),
            await St(s, e, r, n, i, a),
            wt(n),
            o.emit(_.EVENTS.LOGGED_IN),
            a.ok({
              data: {
                module: s.module,
                key: s.key,
                token: s.token,
                user: s.user,
              },
            })
          );
        } catch (t) {
          throw (
            (o.emit(_.EVENTS.LOGIN_FAIL),
            a.error({ data: t, message: 'ERROR.LOGIN_FAIL' }))
          );
        }
      };
      var It = function (t = new ht(), n = new X(), e = new S()) {
        return (
          t.delete(_.STATES.IS_LOGGED_IN),
          t.delete(_.STATES.LOGIN_METHOD),
          t.delete(_.STATES.HAS_USER),
          t.delete(_.STATES.HAS_TOKEN),
          t.delete(_.STATES.HAS_KEY),
          t.delete(_.STATES.MODEL_INTENT),
          t.delete(_.STATES.MODEL_MODULE),
          t.delete(_.STATES.MODEL_CHANNELS),
          t.delete(_.STATES.MODEL_SESSION),
          e.delete(_.STORAGE.TOKEN),
          e.delete(_.STORAGE.KEY),
          e.delete(_.STORAGE.OLD_KEY),
          e.delete(_.STORAGE.USER),
          n.emit(_.EVENTS.LOGGED_OUT),
          Promise.resolve()
        );
      };
      class Wt extends f {
        constructor() {
          super(ht, ft, j, ft, X, nt, S);
        }
        login(t = []) {
          return Tt(
            t,
            this.State,
            this.Http,
            this.Encryption,
            this.PubSub,
            this.Response,
            this.Storage
          );
        }
        loginChatbot(t = []) {
          return Rt(
            t,
            this.State,
            this.Http,
            this.Encryption,
            this.PubSub,
            this.Response,
            this.Storage
          );
        }
        logout() {
          return It(this.State, this.PubSub, this.Storage);
        }
      }
      function Mt(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      function Pt(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function Ht(t, n, e) {
        return n && Pt(t.prototype, n), e && Pt(t, e), t;
      }
      function Lt(t, n) {
        if (!Object.prototype.hasOwnProperty.call(t, n))
          throw new TypeError('attempted to use private field on non-instance');
        return t;
      }
      var Nt = 0;
      function Dt(t) {
        return '__private_' + Nt++ + '_' + t;
      }
      var Ft = (function () {
          function t() {
            !(function (t, n) {
              if (!(t instanceof n))
                throw new TypeError('Cannot call a class as a function');
            })(this, t),
              Object.defineProperty(this, Xt, { writable: !0, value: null }),
              Object.defineProperty(this, Jt, { writable: !0, value: [] }),
              (this.module = void 0),
              (this.chatbotUser = void 0),
              this.whisper();
            var n = Array.prototype.slice.call(arguments),
              e = n[2] || {},
              r = n.slice(0, 2);
            (this.config = new h(e)),
              c([j, ft, Wt, Q, ht, X, nt], this),
              this.Translate.setLanguage(gt),
              (Lt(this, Jt)[Jt] = r),
              (this.chatbotUser = e.chatbotUser),
              this.State.set(i.STATES.HAS_CLIENT_USER_ID, this.chatbotUser),
              this.State.set(i.STATES.ENVIRONMENT, this.config.environment);
          }
          var n, e;
          return (
            Ht(t, [
              {
                key: 'config',
                get: function () {
                  return Lt(this, Xt)[Xt];
                },
                set: function (t) {
                  null === Lt(this, Xt)[Xt] && (Lt(this, Xt)[Xt] = t);
                },
              },
            ]),
            Ht(t, [
              {
                key: 'whisper',
                value: function () {
                  console.log(
                    '%c Cognus Chatbot        : '.concat(i.VERSION),
                    'color: transparent'
                  );
                },
              },
              {
                key: 'getModules',
                value: function () {
                  return dt(this.Http);
                },
              },
              {
                key: 'getModule',
                value: function (t) {
                  return pt(t, this.Http);
                },
              },
              {
                key: 'getChatbotUser',
                value: function (t) {
                  return xt(t, this.Http);
                },
              },
              { key: 'createChatbotUser', value: function (t) {} },
              {
                key: 'setup',
                value: function () {
                  return this.login();
                },
              },
              {
                key: 'login',
                value: function (t, n) {
                  var e = this;
                  return (
                    t && n && (Lt(this, Jt)[Jt] = [t, n]),
                    new Promise(function (t, n) {
                      e.Auth.loginChatbot(
                        Lt(e, Jt)[Jt],
                        e.State,
                        e.Http,
                        e.Encryption,
                        e.PubSub,
                        e.Response,
                        e.Storage
                      )
                        .then(function (n) {
                          e.State.set(i.STATES.HAS_MODULE, n.data.module);
                          try {
                            e.State.set(
                              i.STATES.HAS_CLIENT_USER_ID,
                              n.data.user.id
                            );
                          } catch (t) {
                            console.warn(t);
                          }
                          (Lt(e, Jt)[Jt] = {}), t(n);
                        })
                        .catch(function (t) {
                          console.warn(t), n(t);
                        });
                    })
                  );
                },
              },
              {
                key: 'closeSession',
                value:
                  ((n = regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(
                      function (t) {
                        for (;;)
                          switch ((t.prev = t.next)) {
                            case 0:
                              return (t.next = 2), bt();
                            case 2:
                              this.PubSub.emit('LOGOUT');
                            case 3:
                            case 'end':
                              return t.stop();
                          }
                      },
                      t,
                      this
                    );
                  })),
                  (e = function () {
                    var t = this,
                      e = arguments;
                    return new Promise(function (r, o) {
                      var a = n.apply(t, e);
                      function i(t) {
                        Mt(a, r, o, i, s, 'next', t);
                      }
                      function s(t) {
                        Mt(a, r, o, i, s, 'throw', t);
                      }
                      i(void 0);
                    });
                  }),
                  function () {
                    return e.apply(this, arguments);
                  }),
              },
            ]),
            t
          );
        })(),
        Xt = Dt('config'),
        Jt = Dt('tmpLoginParams'),
        zt = Ft;
      e(51), e(32), e(70);
      var Ut = {
        send: function (t = '', n = {}, e = new ht(), r = new nt()) {
          const o = e.get(_.STATES.ELEMENT_IFRAME);
          if (!o)
            return console.warn(
              r.ok({
                message: "Can't send postback events if no element is found",
              })
            );
          o.contentWindow.postMessage(
            JSON.parse(JSON.stringify({ cognusEvent: { event: t, data: n } })),
            '*'
          );
        },
        recieve: function () {},
      };
      var Kt = function (t, n) {
        const e = {};
        return (
          Object.keys(t).forEach((r) => {
            e[r] = n[r] || t[r];
          }),
          e
        );
      };
      const Gt = {
        token: 'login.token',
        userId: 'login.user.id',
        key: 'login.key',
        user: 'JSON.stringify(login.user)',
      };
      var qt = function (t = new ht()) {
        const n = {
          token: t.get(_.STATES.HAS_TOKEN),
          userId: t.get(_.STATES.HAS_USER).id,
          key: t.get(_.STATES.HAS_KEY),
          user: JSON.stringify(t.get(_.STATES.HAS_USER) || {}),
        };
        Ut.send('setupClient', Kt(Gt, n));
      };
      var Vt = function (t = new ht()) {
        const n = t.get(_.STATES.HAS_CLIENT_USER_ID);
        Ut.send('setupUser', { id: n });
      };
      var Yt = function (t = new ht()) {
        Ut.send('setModuleById', t.get(_.STATES.HAS_MODULE));
      };
      function $t(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      function Qt(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function Zt(t, n) {
        if (!Object.prototype.hasOwnProperty.call(t, n))
          throw new TypeError('attempted to use private field on non-instance');
        return t;
      }
      var tn,
        nn = 0;
      function en(t) {
        return '__private_' + nn++ + '_' + t;
      }
      var rn = (function () {
          function t() {
            !(function (t, n) {
              if (!(t instanceof n))
                throw new TypeError('Cannot call a class as a function');
            })(this, t),
              Object.defineProperty(this, sn, { value: fn }),
              Object.defineProperty(this, an, { value: un }),
              Object.defineProperty(this, on, { value: cn }),
              c([h, ht, nt, X], this);
          }
          var n, e, r, o, a;
          return (
            (n = t),
            (e = [
              {
                key: 'render',
                value:
                  ((o = regeneratorRuntime.mark(function t() {
                    var n,
                      e = arguments;
                    return regeneratorRuntime.wrap(
                      function (t) {
                        for (;;)
                          switch ((t.prev = t.next)) {
                            case 0:
                              if (
                                ((n =
                                  e.length > 0 && void 0 !== e[0] ? e[0] : {}),
                                (t.prev = 1),
                                tn)
                              ) {
                                t.next = 6;
                                break;
                              }
                              return (t.next = 5), Zt(this, an)[an](n);
                            case 5:
                              tn = !0;
                            case 6:
                              return (
                                Zt(this, sn)[sn](),
                                t.abrupt(
                                  'return',
                                  this.Response.ok({
                                    message: 'IFRAME_RENDER_SUCCESS',
                                  })
                                )
                              );
                            case 10:
                              throw (
                                ((t.prev = 10),
                                (t.t0 = t.catch(1)),
                                this.Response.error({
                                  message: 'IFRAME_RENDER_FAIL',
                                  data: t.t0,
                                }))
                              );
                            case 13:
                            case 'end':
                              return t.stop();
                          }
                      },
                      t,
                      this,
                      [[1, 10]]
                    );
                  })),
                  (a = function () {
                    var t = this,
                      n = arguments;
                    return new Promise(function (e, r) {
                      var a = o.apply(t, n);
                      function i(t) {
                        $t(a, e, r, i, s, 'next', t);
                      }
                      function s(t) {
                        $t(a, e, r, i, s, 'throw', t);
                      }
                      i(void 0);
                    });
                  }),
                  function () {
                    return a.apply(this, arguments);
                  }),
              },
            ]) && Qt(n.prototype, e),
            r && Qt(n, r),
            t
          );
        })(),
        on = en('parseIframeStyles'),
        an = en('addIframeToDocument'),
        sn = en('sendPostbackEventsToIframe'),
        cn = function () {
          arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          var t = i.DEFAULTS.IFRAME_CSS;
          return t;
        },
        un = function () {
          var t = this,
            n =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
          return new Promise(function (e, r) {
            t.State.get(i.STATES.ELEMENT_IFRAME);
            var o = document.createElement('cognus-chatbot-button'),
              a = Zt(t, on)[on](n);
            if (
              ((o.src = t.Configuration.url.iframe),
              (o.allow = 'microphone'),
              Object.keys(a).forEach(function (t) {
                o.style[t] = a[t];
              }),
              !o)
            )
              return console.warn(
                t.Response.error({
                  message:
                    "Can't add a iframe to document because there's no element",
                })
              );
            document.body.appendChild(o),
              document
                .querySelector('cognus-chatbot-button')
                .shadowRoot.querySelector('#cognus-chatbot__button')
                .dispatchEvent(new Event('mousedown')),
              t.PubSub.on(i.EVENTS.IFRAME_LOADED, function () {
                t.State.set(i.STATES.ELEMENT_IFRAME, o.$iframe), e();
              });
          });
        },
        fn = function () {
          qt(this.State), Vt(this.State), Yt(this.State);
        },
        dn = rn,
        ln = (e(100), e(102), document.createElement('template'));
      ln.innerHTML =
        '\n<style>\n/*! CSS Used from: https://fonts.googleapis.com/icon?family=Material+Icons */.material-icons{font-family:\'Material Icons\';font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:\'liga\';-webkit-font-smoothing:antialiased}/*! CSS Used from: https://bluedarwin-chatbot-iframe.eu-de.mybluemix.net/assets/chatbot-ui.css */#open-chat-button{background:url(https://bluedarwin-chatbot-iframeprod.eu-de.mybluemix.net/assets/images/line-in-motion.svg),#166be9;background:url(https://bluedarwin-chatbot-iframeprod.eu-de.mybluemix.net/assets/images/line-in-motion.svg),-moz-linear-gradient(-45deg,#166be9 1%,#004ab5 77%,#004ab5 77%);background:url(https://bluedarwin-chatbot-iframeprod.eu-de.mybluemix.net/assets/images/line-in-motion.svg),-webkit-linear-gradient(-45deg,#166be9 1%,#004ab5 77%,#004ab5 77%);background:url(https://bluedarwin-chatbot-iframeprod.eu-de.mybluemix.net/assets/images/line-in-motion.svg),linear-gradient(135deg,#166be9 1%,#004ab5 77%,#004ab5 77%);margin-top:8px}.mdl-button--fab.mdl-button--colored{background:linear-gradient(135deg,#166be9 1%,#004ab5 77%,#004ab5 77%);color:#fff;background:url(https://bluedarwin-chatbot-iframeprod.eu-de.mybluemix.net/assets/images/line-in-motion.svg),#166be9;background:url(https://bluedarwin-chatbot-iframeprod.eu-de.mybluemix.net/assets/images/line-in-motion.svg),-moz-linear-gradient(-45deg,#166be9 1%,#004ab5 77%,#004ab5 77%);background:url(https://bluedarwin-chatbot-iframeprod.eu-de.mybluemix.net/assets/images/line-in-motion.svg),-webkit-linear-gradient(-45deg,#166be9 1%,#004ab5 77%,#004ab5 77%);background:url(https://bluedarwin-chatbot-iframeprod.eu-de.mybluemix.net/assets/images/line-in-motion.svg),linear-gradient(135deg,#166be9 1%,#004ab5 77%,#004ab5 77%)}.snippet-open-chat-button{float:right;margin-right:10px;margin-top:10px}button{text-transform:initial!important}/*! CSS Used from: https://bluedarwin-chatbot-iframe.eu-de.mybluemix.net/material.min.css */::-moz-selection{background:#b3d4fc;text-shadow:none}::selection{background:#b3d4fc;text-shadow:none}@media print{*,:after,:before,:first-letter{background:0 0!important;color:#000!important;box-shadow:none!important}}.mdl-button{-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:rgba(255,255,255,0)}.material-icons{font-family:\'Material Icons\';font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;word-wrap:normal;-moz-font-feature-settings:\'liga\';font-feature-settings:\'liga\';-webkit-font-feature-settings:\'liga\';-webkit-font-smoothing:antialiased}.mdl-button{background:0 0;border:none;border-radius:2px;color:#000;position:relative;height:36px;margin:0;min-width:64px;padding:0 16px;display:inline-block;font-family:Roboto,Helvetica,Arial,sans-serif;font-size:14px;font-weight:500;text-transform:uppercase;letter-spacing:0;overflow:hidden;will-change:box-shadow;transition:box-shadow .2s cubic-bezier(.4,0,1,1),background-color .2s cubic-bezier(.4,0,.2,1),color .2s cubic-bezier(.4,0,.2,1);outline:0;cursor:pointer;text-decoration:none;text-align:center;line-height:36px;vertical-align:middle}.mdl-button::-moz-focus-inner{border:0}.mdl-button:hover{background-color:rgba(158,158,158,.2)}.mdl-button:active{background-color:rgba(158,158,158,.4)}.mdl-button.mdl-button--colored{color:#3f51b5}.mdl-button--fab{border-radius:50%;font-size:24px;height:56px;margin:auto;min-width:56px;width:56px;padding:0;overflow:hidden;background:rgba(158,158,158,.2);box-shadow:0 1px 1.5px 0 rgba(0,0,0,.12),0 1px 1px 0 rgba(0,0,0,.24);position:relative;line-height:normal}.mdl-button--fab .material-icons{position:absolute;top:50%;left:50%;-webkit-transform:translate(-12px,-12px);transform:translate(-12px,-12px);line-height:24px;width:24px}.mdl-button--fab:active{box-shadow:0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12),0 2px 4px -1px rgba(0,0,0,.2);background-color:rgba(158,158,158,.4)}.mdl-button .material-icons{vertical-align:middle}/*! CSS Used from: https://bluedarwin-chatbot-iframe.eu-de.mybluemix.net/fonts.css */.material-icons{font-family:\'Material Icons\';font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:\'liga\';-webkit-font-smoothing:antialiased}\n\niframe{display:none; border: none;width: 350px;height: 690px; max-height: 100%;  position:absolute; right:4px; bottom: 0;}\n.mdl-button.mdl-js-button.mdl-button--fab.mdl-button--colored.snippet-open-chat-button{box-shadow: 0 3px 10px rgba(0,0,0,0.15)}\n#cognus-chatbot__container{\n    position: relative;\n    height: 0;\n    width: 0;\n    float: right;\n}\n\ncognus-chatbot-button{\n  width: 0px;\n  height: 0px;\n}\n\n</style>\n<div id="cognus-chatbot__container">\n<iframe class="closed" id="cognus-chatbot__iframe" allow="microphone"></iframe>\n<button id="cognus-chatbot__button"  class="mdl-button mdl-js-button\n              mdl-button--fab\n              mdl-button--colored\n              snippet-open-chat-button"  data-upgraded=",MaterialButton">\n\n<i id="cognus-chatbot__icon-close" class="material-icons">\n  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path fill="none" d="M0 0h24v24H0V0z"/>\n    <path fill="white" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>\n</i>\n<i id="cognus-chatbot__icon-open" class="material-icons">\n    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path fill="none" d="M0 0h24v24H0V0z"/>\n    <path fill="white" d="M22 2H2v20l4-4h16V2z"/></svg>\n</i>\n</button>\n</div>\n';
      var hn = ln;
      var pn = function (t, n) {
          return (
            Object.keys(n).forEach((e) => {
              t[e] || (t[e] = n[e]);
            }),
            t
          );
        },
        yn = { display: 'block', time: '0.4s', delay: 0 };
      function vn(t) {
        var n =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return (
          (n = pn(n, yn)),
          new Promise(function (e, r) {
            try {
              setTimeout(function () {
                (t.style.opacity = 0),
                  (t.style.display = n.display),
                  (t.style.WebkitTransition = 'opacity '.concat(n.time)),
                  (t.style.MozTransition = 'opacity '.concat(n.time)),
                  requestAnimationFrame(function () {
                    return (t.style.opacity = 1);
                  }),
                  e();
              }, n.delay);
            } catch (t) {
              r(t);
            }
          })
        );
      }
      var xn = { time: '0.4s', delay: 0 };
      function mn(t) {
        var n =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return (
          (n = pn(n, xn)),
          new Promise(function (e, r) {
            setTimeout(function () {
              try {
                (t.style.opacity = 1),
                  (t.style.WebkitTransition = 'opacity '.concat(n.time)),
                  (t.style.MozTransition = 'opacity '.concat(n.time)),
                  requestAnimationFrame(function () {
                    return (t.style.opacity = 0);
                  }),
                  e();
              } catch (t) {
                r(t);
              }
            }, n.delay);
          })
        );
      }
      function _n(t) {
        return (_n =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  'function' == typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      function bn(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      function gn(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function Sn(t, n) {
        return !n || ('object' !== _n(n) && 'function' != typeof n) ? wn(t) : n;
      }
      function wn(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function Cn(t) {
        var n = 'function' == typeof Map ? new Map() : void 0;
        return (Cn = function (t) {
          if (
            null === t ||
            ((e = t), -1 === Function.toString.call(e).indexOf('[native code]'))
          )
            return t;
          var e;
          if ('function' != typeof t)
            throw new TypeError(
              'Super expression must either be null or a function'
            );
          if (void 0 !== n) {
            if (n.has(t)) return n.get(t);
            n.set(t, r);
          }
          function r() {
            return kn(t, arguments, En(this).constructor);
          }
          return (
            (r.prototype = Object.create(t.prototype, {
              constructor: {
                value: r,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })),
            An(r, t)
          );
        })(t);
      }
      function kn(t, n, e) {
        return (kn = (function () {
          if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ('function' == typeof Proxy) return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (t) {
            return !1;
          }
        })()
          ? Reflect.construct
          : function (t, n, e) {
              var r = [null];
              r.push.apply(r, n);
              var o = new (Function.bind.apply(t, r))();
              return e && An(o, e.prototype), o;
            }).apply(null, arguments);
      }
      function An(t, n) {
        return (An =
          Object.setPrototypeOf ||
          function (t, n) {
            return (t.__proto__ = n), t;
          })(t, n);
      }
      function En(t) {
        return (En = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function (t) {
              return t.__proto__ || Object.getPrototypeOf(t);
            })(t);
      }
      var Tn,
        On = [
          { id: '$button', action: 'startButtonPress', type: 'mousedown' },
          { id: '$button', action: 'endButtonPress', type: 'mouseup' },
          { id: '$iframe', action: 'broadcastIframeLoaded', type: 'load' },
        ],
        jn = 0,
        Bn = 0,
        Rn = 0,
        In = 0,
        Wn = (function (t) {
          !(function (t, n) {
            if ('function' != typeof n && null !== n)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (t.prototype = Object.create(n && n.prototype, {
              constructor: { value: t, writable: !0, configurable: !0 },
            })),
              n && An(t, n);
          })(c, t);
          var n,
            e,
            r,
            o,
            a,
            s = (function (t) {
              function n() {
                if ('undefined' == typeof Reflect || !Reflect.construct)
                  return !1;
                if (Reflect.construct.sham) return !1;
                if ('function' == typeof Proxy) return !0;
                try {
                  return (
                    Date.prototype.toString.call(
                      Reflect.construct(Date, [], function () {})
                    ),
                    !0
                  );
                } catch (t) {
                  return !1;
                }
              }
              return function () {
                var e,
                  r = En(t);
                if (n()) {
                  var o = En(this).constructor;
                  e = Reflect.construct(r, arguments, o);
                } else e = r.apply(this, arguments);
                return Sn(this, e);
              };
            })(c);
          function c() {
            var t;
            return (
              (function (t, n) {
                if (!(t instanceof n))
                  throw new TypeError('Cannot call a class as a function');
              })(this, c),
              ((t = s.call(this)).isLocked = !1),
              (t.isChatbotWindowOpen = !1),
              (t.delay = 0),
              (t.isButtonPressed = !1),
              (t._shadowRoot = t.attachShadow({ mode: 'open' })),
              t._shadowRoot.appendChild(hn.content.cloneNode(!0)),
              (t.handleClick = t.handleClick.bind(wn(t))),
              (t.startButtonPress = t.startButtonPress.bind(wn(t))),
              (t.endButtonPress = t.endButtonPress.bind(wn(t))),
              (t.$container = t._shadowRoot.getElementById(
                'cognus-chatbot__container'
              )),
              (t.$button = t._shadowRoot.getElementById(
                'cognus-chatbot__button'
              )),
              (t.$iframe = t._shadowRoot.getElementById(
                'cognus-chatbot__iframe'
              )),
              (t.$iconClose = t._shadowRoot.getElementById(
                'cognus-chatbot__icon-close'
              )),
              (t.$iconOpen = t._shadowRoot.getElementById(
                'cognus-chatbot__icon-open'
              )),
              (Tn = new X()),
              t.addEventListeners(),
              t
            );
          }
          return (
            (n = c),
            (e = [
              {
                key: 'handleClick',
                value:
                  ((o = regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(
                      function (t) {
                        for (;;)
                          switch ((t.prev = t.next)) {
                            case 0:
                              if (((t.prev = 0), !this.isLocked)) {
                                t.next = 3;
                                break;
                              }
                              return t.abrupt('return');
                            case 3:
                              if (
                                ((this.isLocked = !0),
                                !this.isChatbotWindowOpen)
                              ) {
                                t.next = 9;
                                break;
                              }
                              return (t.next = 7), this.closeChatbotWindow();
                            case 7:
                              t.next = 11;
                              break;
                            case 9:
                              return (t.next = 11), this.openChatbotWindow();
                            case 11:
                              (this.isLocked = !1), (t.next = 18);
                              break;
                            case 14:
                              (t.prev = 14),
                                (t.t0 = t.catch(0)),
                                console.warn(t.t0),
                                (this.isLocked = !1);
                            case 18:
                            case 'end':
                              return t.stop();
                          }
                      },
                      t,
                      this,
                      [[0, 14]]
                    );
                  })),
                  (a = function () {
                    var t = this,
                      n = arguments;
                    return new Promise(function (e, r) {
                      var a = o.apply(t, n);
                      function i(t) {
                        bn(a, e, r, i, s, 'next', t);
                      }
                      function s(t) {
                        bn(a, e, r, i, s, 'throw', t);
                      }
                      i(void 0);
                    });
                  }),
                  function () {
                    return a.apply(this, arguments);
                  }),
              },
              {
                key: 'closeChatbotWindow',
                value: function () {
                  var t = this;
                  return new Promise(function (n, e) {
                    Ut.send('closeChatbotWindow'),
                      setTimeout(function () {
                        (t.isChatbotWindowOpen = !1), n();
                      }, Rn),
                      setTimeout(function () {
                        t.$iframe.style.display = 'none';
                      }, Bn),
                      vn(t.$iconOpen, { delay: In }),
                      mn(t.$iconClose);
                  });
                },
              },
              {
                key: 'openChatbotWindow',
                value: function () {
                  var t = this;
                  return new Promise(function (n, e) {
                    (t.$iframe.style.display = 'block'),
                      Ut.send('openChatbotWindow'),
                      setTimeout(function () {
                        (t.isChatbotWindowOpen = !0), n();
                      }, Rn),
                      setTimeout(function () {
                        (t.isChatbotWindowOpen = !0), n();
                      }, jn),
                      vn(t.$iconClose, { delay: In }),
                      mn(t.$iconOpen);
                  });
                },
              },
              {
                key: 'broadcastIframeLoaded',
                value: function () {
                  Tn.emit(i.EVENTS.IFRAME_LOADED);
                },
              },
              {
                key: 'attributeChangedCallback',
                value: function (t, n, e) {
                  switch (t) {
                    case 'src':
                      this.$iframe.src = e;
                  }
                },
              },
              {
                key: 'startButtonPress',
                value: function () {
                  this.handleClick();
                },
              },
              {
                key: 'endButtonPress',
                value: function (t) {
                  this.isButtonPressed = !1;
                },
              },
              {
                key: 'addEventListeners',
                value: function () {
                  var t = this;
                  On.forEach(function (n) {
                    t[n.id].addEventListener(n.type, t[n.action]);
                  });
                },
              },
              {
                key: 'src',
                get: function () {
                  return this.getAttribute('src');
                },
                set: function (t) {
                  this.setAttribute('src', t);
                },
              },
            ]),
            (r = [
              {
                key: 'observedAttributes',
                get: function () {
                  return ['src'];
                },
              },
            ]),
            e && gn(n.prototype, e),
            r && gn(n, r),
            c
          );
        })(Cn(HTMLElement));
      window.customElements.define('cognus-chatbot-button', Wn);
      function Mn(t) {
        return (Mn =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  'function' == typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      function Pn(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      function Hn(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function Ln(t, n) {
        return !n || ('object' !== Mn(n) && 'function' != typeof n) ? Nn(t) : n;
      }
      function Nn(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function Dn(t) {
        return (Dn = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function (t) {
              return t.__proto__ || Object.getPrototypeOf(t);
            })(t);
      }
      function Fn(t, n) {
        return (Fn =
          Object.setPrototypeOf ||
          function (t, n) {
            return (t.__proto__ = n), t;
          })(t, n);
      }
      function Xn(t, n) {
        if (!Object.prototype.hasOwnProperty.call(t, n))
          throw new TypeError('attempted to use private field on non-instance');
        return t;
      }
      var Jn = 0;
      var zn = (function (t) {
          !(function (t, n) {
            if ('function' != typeof n && null !== n)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (t.prototype = Object.create(n && n.prototype, {
              constructor: { value: t, writable: !0, configurable: !0 },
            })),
              n && Fn(t, n);
          })(c, t);
          var n,
            e,
            r,
            o,
            a,
            s = (function (t) {
              function n() {
                if ('undefined' == typeof Reflect || !Reflect.construct)
                  return !1;
                if (Reflect.construct.sham) return !1;
                if ('function' == typeof Proxy) return !0;
                try {
                  return (
                    Date.prototype.toString.call(
                      Reflect.construct(Date, [], function () {})
                    ),
                    !0
                  );
                } catch (t) {
                  return !1;
                }
              }
              return function () {
                var e,
                  r = Dn(t);
                if (n()) {
                  var o = Dn(this).constructor;
                  e = Reflect.construct(r, arguments, o);
                } else e = r.apply(this, arguments);
                return Ln(this, e);
              };
            })(c);
          function c(t, n, e) {
            var r;
            arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            return (
              (function (t, n) {
                if (!(t instanceof n))
                  throw new TypeError('Cannot call a class as a function');
              })(this, c),
              (r = s.apply(this, arguments)),
              Object.defineProperty(Nn(r), Un, { writable: !0, value: {} }),
              (r.events = { on: Ut.recieve, emit: Ut.send }),
              r
            );
          }
          return (
            (n = c),
            (e = [
              {
                key: 'render',
                value:
                  ((o = regeneratorRuntime.mark(function t() {
                    var n,
                      e,
                      r = arguments;
                    return regeneratorRuntime.wrap(
                      function (t) {
                        for (;;)
                          switch ((t.prev = t.next)) {
                            case 0:
                              return (
                                (n =
                                  r.length > 0 && void 0 !== r[0] ? r[0] : {}),
                                (t.prev = 1),
                                (t.next = 4),
                                this.setup()
                              );
                            case 4:
                              if (
                                ((Xn(this, Un)[Un] = Xn(this, Un)[Un] || n),
                                this.State.set(i.STATES.IS_INITIALIZED, !0),
                                this.State.get(i.STATES.IS_LOGGED_IN))
                              ) {
                                t.next = 9;
                                break;
                              }
                              return (
                                (e = this.Response.ok({
                                  message:
                                    'Chatbot iframe init: Waiting for login',
                                })),
                                t.abrupt('return', Promise.reject(e))
                              );
                            case 9:
                              return (
                                new dn(this.config).render(n),
                                t.abrupt('return', Promise.resolve())
                              );
                            case 13:
                              return (
                                (t.prev = 13),
                                (t.t0 = t.catch(1)),
                                t.abrupt(
                                  'return',
                                  Promise.reject(
                                    this.Response.error({ data: t.t0 })
                                  )
                                )
                              );
                            case 16:
                            case 'end':
                              return t.stop();
                          }
                      },
                      t,
                      this,
                      [[1, 13]]
                    );
                  })),
                  (a = function () {
                    var t = this,
                      n = arguments;
                    return new Promise(function (e, r) {
                      var a = o.apply(t, n);
                      function i(t) {
                        Pn(a, e, r, i, s, 'next', t);
                      }
                      function s(t) {
                        Pn(a, e, r, i, s, 'throw', t);
                      }
                      i(void 0);
                    });
                  }),
                  function () {
                    return a.apply(this, arguments);
                  }),
              },
              {
                key: 'listDefaultStyles',
                value: function () {
                  return i.DEFAULTS.IFRAME_CSS;
                },
              },
              {
                key: 'getIframeElement',
                value: function () {
                  return this.State.get(i.STATES.ELEMENT_IFRAME);
                },
              },
            ]) && Hn(n.prototype, e),
            r && Hn(n, r),
            c
          );
        })(zt),
        Un = '__private_' + Jn++ + '_' + 'options',
        Kn = zn,
        Gn =
          (e(72),
          function () {
            var t = { avatar: void 0, name: void 0 };
            return Object.assign({}, t);
          }),
        qn = function (t, n) {
          var e =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : new ft();
          return e.post('am_client_users/'.concat(t), {
            user_settings: { username: n },
          });
        },
        Vn = function (t, n) {
          var e =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : new ft();
          return e.post('am_client_users/'.concat(t), {
            user_settings: { avatar: avatar },
          });
        };
      function Yn(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      function $n(t) {
        return function () {
          var n = this,
            e = arguments;
          return new Promise(function (r, o) {
            var a = t.apply(n, e);
            function i(t) {
              Yn(a, r, o, i, s, 'next', t);
            }
            function s(t) {
              Yn(a, r, o, i, s, 'throw', t);
            }
            i(void 0);
          });
        };
      }
      function Qn(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function Zn(t, n) {
        if (!Object.prototype.hasOwnProperty.call(t, n))
          throw new TypeError('attempted to use private field on non-instance');
        return t;
      }
      var te = 0;
      var ne = Gn();
      ne.id = !1;
      var ee = (function () {
          function t(n) {
            !(function (t, n) {
              if (!(t instanceof n))
                throw new TypeError('Cannot call a class as a function');
            })(this, t),
              Object.defineProperty(this, re, { writable: !0, value: ne }),
              (Zn(this, re)[re] = n),
              c([ft], this);
          }
          var n, e, r, o, a;
          return (
            (n = t),
            (e = [
              {
                key: 'setName',
                value:
                  ((a = $n(
                    regeneratorRuntime.mark(function t(n) {
                      var e;
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (
                                  (e = Zn(this, re)[re].user_settings.username),
                                  (t.prev = 1),
                                  (Zn(this, re)[re].user_settings.username = n),
                                  (t.next = 5),
                                  qn(Zn(this, re)[re].id, n, this.Http)
                                );
                              case 5:
                                return t.abrupt('return', Promise.resolve(n));
                              case 8:
                                return (
                                  (t.prev = 8),
                                  (t.t0 = t.catch(1)),
                                  (Zn(this, re)[re].user_settings.username = e),
                                  t.abrupt('return', Promise.reject(e))
                                );
                              case 12:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this,
                        [[1, 8]]
                      );
                    })
                  )),
                  function (t) {
                    return a.apply(this, arguments);
                  }),
              },
              {
                key: 'setAvatar',
                value:
                  ((o = $n(
                    regeneratorRuntime.mark(function t(n) {
                      var e;
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (
                                  (e = Zn(this, re)[re].user_settings.avatar),
                                  (t.prev = 1),
                                  (Zn(this, re)[re].user_settings.avatar = n),
                                  (t.next = 5),
                                  Vn(Zn(this, re)[re].id, n, this.Http)
                                );
                              case 5:
                                return t.abrupt('return', Promise.resolve(n));
                              case 8:
                                return (
                                  (t.prev = 8),
                                  (t.t0 = t.catch(1)),
                                  (Zn(this, re)[re].user_settings.avatar = e),
                                  t.abrupt('return', Promise.reject(e))
                                );
                              case 12:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this,
                        [[1, 8]]
                      );
                    })
                  )),
                  function (t) {
                    return o.apply(this, arguments);
                  }),
              },
              {
                key: 'id',
                get: function () {
                  return Zn(this, re)[re].id;
                },
              },
              {
                key: 'name',
                get: function () {
                  return Zn(this, re)[re].user_settings.username;
                },
              },
              {
                key: 'avatar',
                get: function () {
                  return Zn(this, re)[re].user_settings.avatar;
                },
              },
            ]) && Qn(n.prototype, e),
            r && Qn(n, r),
            t
          );
        })(),
        re = (function (t) {
          return '__private_' + te++ + '_' + t;
        })('meta'),
        oe = ee,
        ae = function () {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new ht(),
            n = '',
            e = {
              am_user: 12323,
              stage: i.ENVIRONMENT_IDS[t.get(i.STATES.ENVIRONMENT)],
              project: t.get(i.STATES.HAS_PROJECT),
              status: 'open',
            };
          return (
            Object.keys(e).forEach(function (t) {
              e[t] && (n += '&'.concat(t, '=').concat(e[t]));
            }),
            (n = (n = n.substr(1)).length > 0 ? '?'.concat(n) : n)
          );
        },
        ie = function () {
          var t =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : new ft();
          return t.get('am_sessions'.concat(ae()));
        };
      function se(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      var ce = (function () {
          var t,
            n =
              ((t = regeneratorRuntime.mark(function t() {
                var n,
                  e = arguments;
                return regeneratorRuntime.wrap(
                  function (t) {
                    for (;;)
                      switch ((t.prev = t.next)) {
                        case 0:
                          return (
                            e.length > 0 && void 0 !== e[0] ? e[0] : new nt(),
                            (t.prev = 1),
                            (t.next = 4),
                            ie()
                          );
                        case 4:
                          return (
                            ((n = t.sent) && 0 !== n.length) || (n = !1),
                            t.abrupt('return', n[0])
                          );
                        case 9:
                          throw (
                            ((t.prev = 9),
                            (t.t0 = t.catch(1)),
                            nt.error({
                              message: 'ERROR.GET_OR_CREATE_SESSION',
                              data: t.t0,
                            }))
                          );
                        case 12:
                        case 'end':
                          return t.stop();
                      }
                  },
                  t,
                  null,
                  [[1, 9]]
                );
              })),
              function () {
                var n = this,
                  e = arguments;
                return new Promise(function (r, o) {
                  var a = t.apply(n, e);
                  function i(t) {
                    se(a, r, o, i, s, 'next', t);
                  }
                  function s(t) {
                    se(a, r, o, i, s, 'throw', t);
                  }
                  i(void 0);
                });
              });
          return function () {
            return n.apply(this, arguments);
          };
        })(),
        ue = function (t) {
          var n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : new ft(),
            e =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : new ht();
          return n.post('orchestrator_v3', _t.v3.text(t, e));
        },
        fe = function (t) {
          var n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : new ft(),
            e =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : new ht();
          return n.post('orchestrator_v3', _t.v3.voice(t, e));
        },
        de = function (t) {
          var n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : new ft(),
            e =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : new ht();
          return n.post('orchestrator_v3', _t.v3.postBack(t, e));
        },
        le = function () {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new ft(),
            n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : new ht(),
            e = _t.v3.text('ol', n);
          return (
            (e.context_variables = e.context_variables || {}),
            (e.context_variables.actions = e.context_variables.actions || {}),
            (e.context_variables.actions.close_session =
              e.context_variables.actions.close_session || {}),
            (e.context_variables.actions.close_session.enabled = !0),
            delete e.input,
            delete e.auth.stage,
            delete e.context_variables.extracted_entities,
            t.post('orchestrator_v3', e)
          );
        },
        he = function () {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new ft(),
            n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : new ht(),
            e = _t.v3.text('start', n);
          return (e.input = null), t.post('orchestrator_v3', e);
        };
      function pe(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      function ye(t) {
        return function () {
          var n = this,
            e = arguments;
          return new Promise(function (r, o) {
            var a = t.apply(n, e);
            function i(t) {
              pe(a, r, o, i, s, 'next', t);
            }
            function s(t) {
              pe(a, r, o, i, s, 'throw', t);
            }
            i(void 0);
          });
        };
      }
      function ve(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function xe(t, n) {
        if (!Object.prototype.hasOwnProperty.call(t, n))
          throw new TypeError('attempted to use private field on non-instance');
        return t;
      }
      var me = 0;
      function _e(t) {
        return '__private_' + me++ + '_' + t;
      }
      var be,
        ge = i.STATES.CONVERSATION,
        Se = (function () {
          function t() {
            return (
              (function (t, n) {
                if (!(t instanceof n))
                  throw new TypeError('Cannot call a class as a function');
              })(this, t),
              Object.defineProperty(this, Te, { value: We }),
              Object.defineProperty(this, Ee, { value: Ie }),
              Object.defineProperty(this, Ae, { value: Re }),
              Object.defineProperty(this, ke, { value: Be }),
              Object.defineProperty(this, Ce, { value: je }),
              Object.defineProperty(this, we, { value: Oe }),
              be || (c([ht, X, ft], this), (be = this)),
              be
            );
          }
          var n, e, r, o, a, i, s, u;
          return (
            (n = t),
            (e = [
              {
                key: 'sendText',
                value:
                  ((u = ye(
                    regeneratorRuntime.mark(function t(n) {
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (
                                  (t.next = 2), xe(this, Te)[Te]('sendText', n)
                                );
                              case 2:
                                return t.abrupt('return', t.sent);
                              case 3:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this
                      );
                    })
                  )),
                  function (t) {
                    return u.apply(this, arguments);
                  }),
              },
              {
                key: 'sendVoice',
                value:
                  ((s = ye(
                    regeneratorRuntime.mark(function t(n) {
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (
                                  (t.next = 2), xe(this, Te)[Te]('sendVoice', n)
                                );
                              case 2:
                                return t.abrupt('return', t.sent);
                              case 3:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this
                      );
                    })
                  )),
                  function (t) {
                    return s.apply(this, arguments);
                  }),
              },
              {
                key: 'sendPostBack',
                value:
                  ((i = ye(
                    regeneratorRuntime.mark(function t(n) {
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (
                                  (t.next = 2),
                                  xe(this, Te)[Te]('sendPostBack', n)
                                );
                              case 2:
                                return t.abrupt('return', t.sent);
                              case 3:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this
                      );
                    })
                  )),
                  function (t) {
                    return i.apply(this, arguments);
                  }),
              },
              {
                key: 'sendStartConversation',
                value:
                  ((a = ye(
                    regeneratorRuntime.mark(function t() {
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (
                                  (t.next = 2),
                                  xe(this, Te)[Te]('sendStartConversation')
                                );
                              case 2:
                                return t.abrupt('return', t.sent);
                              case 3:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this
                      );
                    })
                  )),
                  function () {
                    return a.apply(this, arguments);
                  }),
              },
              {
                key: 'sendReset',
                value:
                  ((o = ye(
                    regeneratorRuntime.mark(function t() {
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (
                                  (t.next = 2), xe(this, Te)[Te]('sendReset')
                                );
                              case 2:
                                return t.abrupt('return', t.sent);
                              case 3:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this
                      );
                    })
                  )),
                  function () {
                    return o.apply(this, arguments);
                  }),
              },
            ]) && ve(n.prototype, e),
            r && ve(n, r),
            t
          );
        })(),
        we = _e('extractConversationFromResponse'),
        Ce = _e('updateConversationEvent'),
        ke = _e('parseDataForConversation'),
        Ae = _e('middlewareIsApiInitiated'),
        Ee = _e('middlewareBefore'),
        Te = _e('middleware'),
        Oe = function (t) {
          var n;
          try {
            n = t.system ? t : t.result.content;
          } catch (t) {
            n = { text: 'error', type: 'direct_message' };
          }
          return { type: 'output', data: n };
        },
        je = function (t) {
          this.PubSub.emit(i.EVENTS.CONVERSATION_UPDATE, t);
        },
        Be = function (t, n) {
          switch (
            ((n = { type: 'input', data: { type: '', content: n } }), t)
          ) {
            case 'sendText':
              n.data.type = 'text';
              break;
            case 'sendPostBack':
              n.data.type = 'postback';
              break;
            case 'sendVoice':
              n.data.type = 'voice';
          }
          return n;
        },
        Re = function () {
          return this.State.get(i.STATES.API_READY);
        },
        Ie = function (t) {
          var n = this.State.get(ge) || [];
          return (
            n.push(t),
            this.State.set(ge, n),
            xe(this, Ce)[Ce](t),
            { index: n.length - 1, conversation: n }
          );
        },
        We = (function () {
          var t = ye(
            regeneratorRuntime.mark(function t(n, e) {
              var r, o, a, s;
              return regeneratorRuntime.wrap(
                function (t) {
                  for (;;)
                    switch ((t.prev = t.next)) {
                      case 0:
                        if (xe(this, Ae)[Ae]()) {
                          t.next = 2;
                          break;
                        }
                        return t.abrupt(
                          'return',
                          Promise.reject(
                            Response(1, { message: 'API_NOT_READY' })
                          )
                        );
                      case 2:
                        if (
                          ((o = xe(this, Ee)[Ee](xe(this, ke)[ke](n, e))),
                          (t.prev = 3),
                          'sendText' !== n)
                        ) {
                          t.next = 8;
                          break;
                        }
                        return (t.next = 7), ue(e);
                      case 7:
                        a = t.sent;
                      case 8:
                        if ('sendVoice' !== n) {
                          t.next = 12;
                          break;
                        }
                        return (t.next = 11), fe(e);
                      case 11:
                        a = t.sent;
                      case 12:
                        if ('sendPostBack' !== n) {
                          t.next = 16;
                          break;
                        }
                        return (t.next = 15), de(e);
                      case 15:
                        a = t.sent;
                      case 16:
                        if ('sendReset' !== n) {
                          t.next = 20;
                          break;
                        }
                        return (t.next = 19), le();
                      case 19:
                        a = t.sent;
                      case 20:
                        if ('sendStartConversation' !== n) {
                          t.next = 24;
                          break;
                        }
                        return (t.next = 23), he(e);
                      case 23:
                        a = t.sent;
                      case 24:
                        return (
                          (a = xe(this, we)[we](a)),
                          (r = this.State.get(ge)).push(a),
                          this.State.set(ge, r),
                          xe(this, Ce)[Ce](a),
                          t.abrupt('return', Promise.resolve(a))
                        );
                      case 32:
                        return (
                          (t.prev = 32),
                          (t.t0 = t.catch(3)),
                          ((s = this.State.get(ge))[o.index].failed = !0),
                          this.State.set(ge, s),
                          this.PubSub.emit(i.EVENTS.CONVERSATION_REPLY_FAIL, {
                            index: o.index,
                            reply: s[o.index],
                          }),
                          t.abrupt('return', Promise.reject(t.t0))
                        );
                      case 39:
                      case 'end':
                        return t.stop();
                    }
                },
                t,
                this,
                [[3, 32]]
              );
            })
          );
          return function (n, e) {
            return t.apply(this, arguments);
          };
        })(),
        Me = Se;
      function Pe(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      function He(t) {
        return function () {
          var n = this,
            e = arguments;
          return new Promise(function (r, o) {
            var a = t.apply(n, e);
            function i(t) {
              Pe(a, r, o, i, s, 'next', t);
            }
            function s(t) {
              Pe(a, r, o, i, s, 'throw', t);
            }
            i(void 0);
          });
        };
      }
      function Le(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function Ne(t, n) {
        if (!Object.prototype.hasOwnProperty.call(t, n))
          throw new TypeError('attempted to use private field on non-instance');
        return t;
      }
      var De = 0;
      function Fe(t) {
        return '__private_' + De++ + '_' + t;
      }
      var Xe = (function () {
          function t(n, e) {
            if (
              ((function (t, n) {
                if (!(t instanceof n))
                  throw new TypeError('Cannot call a class as a function');
              })(this, t),
              Object.defineProperty(this, Ge, { value: Ve }),
              Object.defineProperty(this, Ke, { value: qe }),
              Object.defineProperty(this, Je, {
                writable: !0,
                value: {
                  user: !1,
                  id: !1,
                  module: !1,
                  projectId: !1,
                  isOpen: !1,
                },
              }),
              Object.defineProperty(this, ze, { writable: !0, value: {} }),
              Object.defineProperty(this, Ue, { writable: !0, value: [] }),
              (this.parameters = {}),
              !n || !e)
            )
              throw 'ERROR.SESSION_CREATE_WITHOUT_LOGIN_OR_INIT';
            (Ne(this, Je)[Je].module = n),
              (Ne(this, Je)[Je].user = e),
              c([nt, ht, ft, Me], this);
          }
          var n, e, r, o, a, i;
          return (
            (n = t),
            (e = [
              {
                key: 'getId',
                value: function () {
                  return Ne(this, Je)[Je].id;
                },
              },
              {
                key: 'getUser',
                value: function () {
                  return Ne(this, Je)[Je].user;
                },
              },
              {
                key: 'getModule',
                value: function () {
                  return Ne(this, Je)[Je].module;
                },
              },
              {
                key: 'isOpen',
                value: function () {
                  return Ne(this, Je)[Je].isOpen;
                },
              },
              {
                key: 'sendText',
                value: function (t) {
                  return this.Communication.sendText(t);
                },
              },
              {
                key: 'sendVoice',
                value: function (t) {
                  return this.Communication.sendVoice(t);
                },
              },
              {
                key: 'sendPostBack',
                value: function (t) {
                  return this.Communication.sendPostBack(t);
                },
              },
              {
                key: 'sendStartConversation',
                value: function () {
                  return this.Communication.sendStartConversation();
                },
              },
              {
                key: 'sendLogout',
                value: function () {
                  return this.Communication.sendLogout({});
                },
              },
              {
                key: 'getSession',
                value:
                  ((i = He(
                    regeneratorRuntime.mark(function t() {
                      var n;
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (t.prev = 0), (t.next = 3), ce();
                              case 3:
                                if (!(n = t.sent)) {
                                  t.next = 10;
                                  break;
                                }
                                return (
                                  (Ne(this, Je)[Je].isOpen =
                                    'open' === n.attributes.status),
                                  (Ne(this, Je)[Je].projectId =
                                    n.relationships.project.data.id),
                                  (Ne(this, Je)[Je].id = n.id),
                                  (Ne(this, ze)[ze] = n),
                                  t.abrupt(
                                    'return',
                                    Promise.resolve(Ne(this, Ge)[Ge](n))
                                  )
                                );
                              case 10:
                                return t.abrupt(
                                  'return',
                                  Promise.resolve(Ne(this, Ue)[Ue])
                                );
                              case 13:
                                return (
                                  (t.prev = 13),
                                  (t.t0 = t.catch(0)),
                                  t.abrupt(
                                    'return',
                                    Promise.reject(
                                      nt.error({ message: t.t0, data: t.t0 })
                                    )
                                  )
                                );
                              case 16:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this,
                        [[0, 13]]
                      );
                    })
                  )),
                  function () {
                    return i.apply(this, arguments);
                  }),
              },
              {
                key: 'getConversation',
                value:
                  ((a = He(
                    regeneratorRuntime.mark(function t() {
                      var n, e;
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                if (
                                  ((t.prev = 0),
                                  !((n = Ne(this, Ue)[Ue]).length > 0))
                                ) {
                                  t.next = 4;
                                  break;
                                }
                                return t.abrupt('return', Promise.resolve(n));
                              case 4:
                                return (t.next = 6), this.getSession();
                              case 6:
                                return (
                                  (e = t.sent),
                                  t.abrupt('return', Promise.resolve(e))
                                );
                              case 10:
                                return (
                                  (t.prev = 10),
                                  (t.t0 = t.catch(0)),
                                  console.warn(t.t0),
                                  t.abrupt(
                                    'return',
                                    Promise.resolve(Ne(this, Ue)[Ue])
                                  )
                                );
                              case 14:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this,
                        [[0, 10]]
                      );
                    })
                  )),
                  function () {
                    return a.apply(this, arguments);
                  }),
              },
              {
                key: 'reset',
                value:
                  ((o = He(
                    regeneratorRuntime.mark(function t() {
                      var n;
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (
                                  (t.next = 2), this.Communication.sendReset()
                                );
                              case 2:
                                return (
                                  (n = t.sent),
                                  (Ne(this, Ue)[Ue] = {}),
                                  t.abrupt('return', n)
                                );
                              case 5:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this
                      );
                    })
                  )),
                  function () {
                    return o.apply(this, arguments);
                  }),
              },
            ]) && Le(n.prototype, e),
            r && Le(n, r),
            t
          );
        })(),
        Je = Fe('meta'),
        ze = Fe('session'),
        Ue = Fe('conversation'),
        Ke = Fe('updateConversation'),
        Ge = Fe('buildConversationFromSession'),
        qe = function (t, n) {
          if (t && n) {
            var e = { type: t, data: n };
            Ne(this, Ue)[Ue].push(e);
          }
        },
        Ve = function (t) {
          if (!t || !t.attributes || !t.attributes.context)
            return Ne(this, Ue)[Ue];
          for (
            var n = t.attributes.context, e = 1;
            e <= n.n_interactions;
            e++
          ) {
            var r = 'interaction_' + e,
              o =
                n.inputs[r] && Array.isArray(n.inputs[r])
                  ? n.inputs[r][0]
                  : void 0,
              a =
                n.outputs[r] && Array.isArray(n.outputs[r])
                  ? n.outputs[r][0]
                  : void 0;
            Ne(this, Ke)[Ke]('input', o), Ne(this, Ke)[Ke]('output', a);
          }
          return (
            this.State.set(i.STATES.CONVERSATION, Ne(this, Ue)[Ue]),
            Ne(this, Ue)[Ue]
          );
        },
        Ye = Xe,
        $e = function () {
          return Object.assign({}, {});
        },
        Qe = function () {
          var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $e;
          arguments.length > 1 && void 0 !== arguments[1]
            ? arguments[1]
            : new ft();
          return ft.post('url', Kt($e, t));
        };
      function Ze(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function tr(t, n) {
        if (!Object.prototype.hasOwnProperty.call(t, n))
          throw new TypeError('attempted to use private field on non-instance');
        return t;
      }
      var nr = 0;
      function er(t) {
        return '__private_' + nr++ + '_' + t;
      }
      var rr = (function () {
          function t(n) {
            !(function (t, n) {
              if (!(t instanceof n))
                throw new TypeError('Cannot call a class as a function');
            })(this, t),
              Object.defineProperty(this, or, {
                writable: !0,
                value: { label: !1, id: !1, channels: [], user: {}, bot: {} },
              }),
              Object.defineProperty(this, ar, { writable: !0, value: [] }),
              (n = n.attributes || n),
              (tr(this, or)[or] = n),
              (tr(this, or)[or].label = n.label),
              (tr(this, or)[or].id = n.id),
              (tr(this, ar)[ar] = n.am_channel_tokens),
              (this.intents = []),
              c([ft], this);
          }
          var n, e, r;
          return (
            (n = t),
            (e = [
              {
                key: 'getIntents',
                value: function () {
                  return this.intents;
                },
              },
              {
                key: 'getSession',
                value: function (t) {
                  return ie(t, this.Http);
                },
              },
              {
                key: 'getChannels',
                value: function () {
                  return tr(this, or)[or].channels;
                },
              },
              {
                key: 'getLabel',
                value: function () {
                  return tr(this, or)[or].label;
                },
              },
              {
                key: 'getId',
                value: function () {
                  return tr(this, or)[or].id;
                },
              },
              {
                key: 'getMeta',
                value: function () {
                  return tr(this, or)[or];
                },
              },
              {
                key: 'createSession',
                value: function (t) {
                  return Qe(t);
                },
              },
              { key: 'setMetaChannels', value: function () {} },
              {
                key: 'setMetaUser',
                value: function (t) {
                  tr(this, or)[or].user = new oe(t);
                },
              },
            ]) && Ze(n.prototype, e),
            r && Ze(n, r),
            t
          );
        })(),
        or = er('meta'),
        ar = er('channelTokens'),
        ir = rr,
        sr = function (t) {
          var n =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : new ft();
          return n.get('am_channels/'.concat(t));
        },
        cr = function (t) {
          var n =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : new ft();
          return n.get('am_channel_tokens/'.concat(t));
        },
        ur = function (t) {
          var n =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : new ft();
          return n.get('am_intents/'.concat(t));
        };
      function fr(t) {
        return (fr =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  'function' == typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      function dr(t, n, e, r, o, a, i) {
        try {
          var s = t[a](i),
            c = s.value;
        } catch (t) {
          return void e(t);
        }
        s.done ? n(c) : Promise.resolve(c).then(r, o);
      }
      function lr(t) {
        return function () {
          var n = this,
            e = arguments;
          return new Promise(function (r, o) {
            var a = t.apply(n, e);
            function i(t) {
              dr(a, r, o, i, s, 'next', t);
            }
            function s(t) {
              dr(a, r, o, i, s, 'throw', t);
            }
            i(void 0);
          });
        };
      }
      function hr(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function pr(t, n) {
        return !n || ('object' !== fr(n) && 'function' != typeof n) ? yr(t) : n;
      }
      function yr(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function vr(t) {
        return (vr = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function (t) {
              return t.__proto__ || Object.getPrototypeOf(t);
            })(t);
      }
      function xr(t, n) {
        return (xr =
          Object.setPrototypeOf ||
          function (t, n) {
            return (t.__proto__ = n), t;
          })(t, n);
      }
      function mr(t, n) {
        if (!Object.prototype.hasOwnProperty.call(t, n))
          throw new TypeError('attempted to use private field on non-instance');
        return t;
      }
      var _r = 0;
      function br(t) {
        return '__private_' + _r++ + '_' + t;
      }
      var gr = (function (t) {
          !(function (t, n) {
            if ('function' != typeof n && null !== n)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (t.prototype = Object.create(n && n.prototype, {
              constructor: { value: t, writable: !0, configurable: !0 },
            })),
              n && xr(t, n);
          })(s, t);
          var n,
            e,
            r,
            o,
            a = (function (t) {
              function n() {
                if ('undefined' == typeof Reflect || !Reflect.construct)
                  return !1;
                if (Reflect.construct.sham) return !1;
                if ('function' == typeof Proxy) return !0;
                try {
                  return (
                    Date.prototype.toString.call(
                      Reflect.construct(Date, [], function () {})
                    ),
                    !0
                  );
                } catch (t) {
                  return !1;
                }
              }
              return function () {
                var e,
                  r = vr(t);
                if (n()) {
                  var o = vr(this).constructor;
                  e = Reflect.construct(r, arguments, o);
                } else e = r.apply(this, arguments);
                return pr(this, e);
              };
            })(s);
          function s() {
            var t;
            !(function (t, n) {
              if (!(t instanceof n))
                throw new TypeError('Cannot call a class as a function');
            })(this, s),
              (t = a.apply(this, arguments)),
              Object.defineProperty(yr(t), Or, { value: Ir }),
              Object.defineProperty(yr(t), Tr, { value: Rr }),
              Object.defineProperty(yr(t), Er, { value: Br }),
              Object.defineProperty(yr(t), Ar, { value: jr }),
              Object.defineProperty(yr(t), Sr, { writable: !0, value: [] }),
              Object.defineProperty(yr(t), wr, { writable: !0, value: void 0 }),
              Object.defineProperty(yr(t), Cr, { writable: !0, value: void 0 }),
              Object.defineProperty(yr(t), kr, { writable: !0, value: void 0 });
            try {
              (t.events = t.PubSub),
                delete t.events.emit,
                delete t.events.off,
                delete t.events.reset,
                delete t.events.getEvents,
                t.events.on('LOGOUT', function () {});
            } catch (t) {
              console.dir(t);
            }
            return t;
          }
          return (
            (n = s),
            (e = [
              {
                key: 'boot',
                value:
                  ((o = lr(
                    regeneratorRuntime.mark(function t(n) {
                      var e, r, o;
                      return regeneratorRuntime.wrap(
                        function (t) {
                          for (;;)
                            switch ((t.prev = t.next)) {
                              case 0:
                                return (t.prev = 0), (t.next = 3), this.setup();
                              case 3:
                                if (
                                  ((this.chatbotUser = n || this.chatbotUser),
                                  this.State.set(i.STATES.IS_INITIALIZED, !0),
                                  this.State.set(
                                    i.STATES.HAS_MODULE,
                                    this.module
                                  ),
                                  this.State.set(
                                    i.STATES.HAS_CLIENT_USER_ID,
                                    this.chatbotUser
                                  ),
                                  this.State.get(i.STATES.IS_LOGGED_IN))
                                ) {
                                  t.next = 10;
                                  break;
                                }
                                return (
                                  (e = this.Response.ok({
                                    message:
                                      'Chatbot iframe init: Waiting for login',
                                  })),
                                  t.abrupt('return', Promise.reject(e))
                                );
                              case 10:
                                return (t.next = 12), mr(this, Ar)[Ar]();
                              case 12:
                                return (
                                  (r = t.sent),
                                  (t.next = 15),
                                  mr(this, Er)[Er](r)
                                );
                              case 15:
                                return (t.next = 17), mr(this, Tr)[Tr](r);
                              case 17:
                                return (t.next = 19), mr(this, Or)[Or]();
                              case 19:
                                return (
                                  (mr(this, Cr)[Cr] = new Ye(
                                    r,
                                    i.STATES.HAS_USER
                                  )),
                                  (t.next = 22),
                                  mr(this, Cr)[Cr].getConversation()
                                );
                              case 22:
                                return (
                                  (o = t.sent),
                                  this.State.set(i.STATES.API_READY, !0),
                                  this.PubSub.emit(i.EVENTS.API_READY),
                                  t.abrupt('return', Promise.resolve(o))
                                );
                              case 28:
                                return (
                                  (t.prev = 28),
                                  (t.t0 = t.catch(0)),
                                  this.PubSub.emit(i.EVENTS.API_FAIL),
                                  t.abrupt(
                                    'return',
                                    Promise.reject(
                                      this.Response.error({ message: t.t0 })
                                    )
                                  )
                                );
                              case 32:
                              case 'end':
                                return t.stop();
                            }
                        },
                        t,
                        this,
                        [[0, 28]]
                      );
                    })
                  )),
                  function (t) {
                    return o.apply(this, arguments);
                  }),
              },
              {
                key: 'getMeta',
                value: function () {
                  return mr(this, kr)[kr].getMeta();
                },
              },
              {
                key: 'getConversation',
                value: function (t) {
                  return this.State.get(i.STATES.CONVERSATION);
                },
              },
              {
                key: 'sendText',
                value: function (t) {
                  return mr(this, Cr)[Cr].sendText(t);
                },
              },
              {
                key: 'sendVoice',
                value: function (t) {
                  return mr(this, Cr)[Cr].sendVoice(t);
                },
              },
              {
                key: 'sendPostBack',
                value: function (t) {
                  return mr(this, Cr)[Cr].sendPostBack(t);
                },
              },
              {
                key: 'startConversation',
                value: function () {
                  return mr(this, Cr)[Cr].sendStartConversation();
                },
              },
              {
                key: 'resetConversation',
                value: function () {
                  return mr(this, Cr)[Cr].reset();
                },
              },
            ]) && hr(n.prototype, e),
            r && hr(n, r),
            s
          );
        })(zt),
        Sr = br('channels'),
        wr = br('intent'),
        Cr = br('session'),
        kr = br('chatbotModule'),
        Ar = br('initGetModule'),
        Er = br('initGetChannels'),
        Tr = br('initGetIntent'),
        Or = br('initGetChatbotUser'),
        jr = (function () {
          var t = lr(
            regeneratorRuntime.mark(function t() {
              var n;
              return regeneratorRuntime.wrap(
                function (t) {
                  for (;;)
                    switch ((t.prev = t.next)) {
                      case 0:
                        return (
                          (t.prev = 0),
                          (t.next = 3),
                          pt(this.module, this.Http, this.State)
                        );
                      case 3:
                        if ((n = t.sent) && 'item not found' !== n) {
                          t.next = 6;
                          break;
                        }
                        throw 'ERROR.MODULE_NOT_FOUND';
                      case 6:
                        return (
                          this.State.set(i.STATES.MODEL_MODULE, n),
                          this.State.set(
                            i.STATES.HAS_PROJECT,
                            n.relationships.project &&
                              n.relationships.project.data &&
                              n.relationships.project.data.id
                              ? n.relationships.project.data.id
                              : void 0
                          ),
                          (mr(this, kr)[kr] = new ir(n)),
                          t.abrupt('return', n)
                        );
                      case 12:
                        throw ((t.prev = 12), (t.t0 = t.catch(0)), t.t0);
                      case 15:
                      case 'end':
                        return t.stop();
                    }
                },
                t,
                this,
                [[0, 12]]
              );
            })
          );
          return function () {
            return t.apply(this, arguments);
          };
        })(),
        Br = (function () {
          var t = lr(
            regeneratorRuntime.mark(function t(n) {
              var e, r, o, a;
              return regeneratorRuntime.wrap(
                function (t) {
                  for (;;)
                    switch ((t.prev = t.next)) {
                      case 0:
                        (t.prev = 0), (e = 0);
                      case 2:
                        if (
                          !(e < n.relationships.am_channel_tokens.data.length)
                        ) {
                          t.next = 14;
                          break;
                        }
                        return (
                          (r = n.relationships.am_channel_tokens.data[e].id),
                          (t.next = 6),
                          cr(r, this.Http)
                        );
                      case 6:
                        return (
                          (o = t.sent),
                          (t.next = 9),
                          sr(o.relationships.am_channel.data.id)
                        );
                      case 9:
                        'BlueDarwin' === (a = t.sent).attributes.label &&
                          (mr(this, Sr)[Sr].push(a.attributes),
                          this.State.set(
                            i.STATES.CHANNEL_TOKEN,
                            o.attributes.token
                          ));
                      case 11:
                        e++, (t.next = 2);
                        break;
                      case 14:
                        this.State.set(
                          i.STATES.MODEL_CHANNELS,
                          mr(this, Sr)[Sr]
                        ),
                          (t.next = 20);
                        break;
                      case 17:
                        throw ((t.prev = 17), (t.t0 = t.catch(0)), t.t0);
                      case 20:
                      case 'end':
                        return t.stop();
                    }
                },
                t,
                this,
                [[0, 17]]
              );
            })
          );
          return function (n) {
            return t.apply(this, arguments);
          };
        })(),
        Rr = (function () {
          var t = lr(
            regeneratorRuntime.mark(function t(n) {
              var e;
              return regeneratorRuntime.wrap(
                function (t) {
                  for (;;)
                    switch ((t.prev = t.next)) {
                      case 0:
                        return (
                          (t.prev = 0),
                          (t.next = 3),
                          ur(n.relationships.am_intents.data.id, this.Http)
                        );
                      case 3:
                        return (
                          (e = t.sent),
                          this.State.set(i.STATES.MODEL_INTENT, e),
                          (mr(this, wr)[wr] = e),
                          t.abrupt('return', e)
                        );
                      case 9:
                        throw ((t.prev = 9), (t.t0 = t.catch(0)), t.t0);
                      case 12:
                      case 'end':
                        return t.stop();
                    }
                },
                t,
                this,
                [[0, 9]]
              );
            })
          );
          return function (n) {
            return t.apply(this, arguments);
          };
        })(),
        Ir = (function () {
          var t = lr(
            regeneratorRuntime.mark(function t() {
              var n;
              return regeneratorRuntime.wrap(
                function (t) {
                  for (;;)
                    switch ((t.prev = t.next)) {
                      case 0:
                        return (t.prev = 0), (t.next = 3), xt();
                      case 3:
                        n = t.sent;
                        try {
                          this.State.set(
                            i.STATES.HAS_CHATBOT_USER,
                            n[0].relationships.am_users.data.id
                          ),
                            mr(this, kr)[kr].setMetaUser(n[0].attributes);
                        } catch (t) {
                          mr(this, kr)[kr].setMetaUser(Gn());
                        }
                        return t.abrupt('return', n);
                      case 8:
                        throw ((t.prev = 8), (t.t0 = t.catch(0)), t.t0);
                      case 11:
                      case 'end':
                        return t.stop();
                    }
                },
                t,
                this,
                [[0, 8]]
              );
            })
          );
          return function () {
            return t.apply(this, arguments);
          };
        })(),
        Wr = gr;
      e.d(n, 'Iframe', function () {
        return Mr;
      }),
        e.d(n, 'Api', function () {
          return Pr;
        });
      var Mr = Kn,
        Pr = Wr;
    },
  ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvbG9jYWxmb3JhZ2UvZGlzdC9sb2NhbGZvcmFnZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvYmFzZS1lbmNyeXB0aW9uL2luZGV4LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2Z1bmN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNvYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNlbXB0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Lyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9ub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9jb25maWctb2JqZWN0cy9jb25maWcuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvZGVwZW5kZW5jaWVzL2luamVjdC1kZXBlbmRlbmNpZXMuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2luZGV4LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9jb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2h0dHAvYnVpbGQtdXJsLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2VuY3J5cHRpb24vbWlkZGxld2FyZS13aWxsLWVuY3J5cHQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvZW5jcnlwdGlvbi9lbmNyeXB0LXN0cmluZy5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvYXBwLWNvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9lbmNyeXB0aW9uL3VwZGF0ZS1rZXkuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvZW5jcnlwdGlvbi9lbmNyeXB0LXBheWxvYWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvZW5jcnlwdGlvbi9kZWNyeXB0LXBheWxvYWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2VuY3J5cHRpb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvaHR0cC91cGRhdGUtdG9rZW4uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvdmFsaWRhdG9ycy9nZXQtZnVuY3Rpb24tY29udGVudC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy92YWxpZGF0b3JzL2lzLWVxdWFsLWZ1bmN0aW9uLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL3ZhbGlkYXRvcnMvYXJyYXktY29udGFpbnMtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9odHRwL2NoZWNrLXJlc3BvbnNlLWZvci1rZXktYW5kLXRva2VuLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9wdWItc3ViLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2h0dHAvZXZlbnQtdG9rZW4tbmVnb3RpYXRpb24tcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvaHR0cC9oYW5kbGUtcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9odHRwL2hhbmRsZS1yZXNwb25zZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9jb25maWctb2JqZWN0cy9yZXNwb25zZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9zZWFyY2gtb2JqZWN0LXBhdGguanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL3RyYW5zbGF0ZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvaHR0cC9oYW5kbGUtZmFpbC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9odHRwL2dldC1oZWFkZXJzLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2h0dHAvcmVxdWVzdC1nZXQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvY29uZmlnLW9iamVjdHMvaHR0cC1yZXF1ZXN0LWJvZHkuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvaHR0cC9wYXJzZS1ib2R5LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2NvbmZpZy1vYmplY3RzL2h0dHAtcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9odHRwL3JlcXVlc3QtcG9zdC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2hlbHBlcnMvcmVzdC1hcGkvZ2V0LW1vZHVsZXMuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL3N0YXRlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvaGVscGVycy9yZXN0LWFwaS9nZXQtbW9kdWxlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL3V1aWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvZ2V0LWNoYXRib3QtdXNlci1pZC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2hlbHBlcnMvcmVzdC1hcGkvZ2V0LWNoYXRib3QtdXNlci5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9zZXQtb3JjaGVzdHJhdG9yLXBheWxvYWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9oZWxwZXJzL3Jlc3QtYXBpL3NlbmQtbG9nb3V0LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvaTE4bi9lbl9FTi5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9hdXRoL3NldC1jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9hdXRoL3NldC1sb2dnZWQtaW4tc3RhdGUuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvYXV0aC9hcGktbG9naW4uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvcmVnZXgvaXMtZW1haWwuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvYXV0aC9jaGVjay1sb2dpbi10eXBlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2F1dGgvbG9naW4uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvZGV2aWNlLWluZm8tdXVpZC5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9hdXRoL2xvZ2luLWNoYXRib3QuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvYXV0aC9sb2dvdXQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2F1dGguanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9jaGF0Ym90LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL3Bvc3QtbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9leHRlbmQtYW5kLWtlZXAtc3RydWN0dXJlLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL3Bvc3QtbWVzc2FnZS9pZnJhbWUtc2V0dXAtY2xpZW50LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9ub2RlX21vZHVsZXMvQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL3Bvc3QtbWVzc2FnZS9pZnJhbWUtc2V0dXAtdXNlci5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9wb3N0LW1lc3NhZ2UvaWZyYW1lLXNldC1tb2R1bGUtYnktaWQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy91dGlscy9pZnJhbWUuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9kb20vY3VzdG9tLWVsZW1lbnRzL3RlbXBsYXRlcy9jb2dudXMtY2hhdGJvdC1idXR0b24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL25vZGVfbW9kdWxlcy9CbHVlRGFyd2luSlMvc3JjL3Byb3RvdHlwZXMvZXh0ZW5kLWNvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9kb20vYW5pbWF0aW9ucy9mYWRlLWluLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvZG9tL2FuaW1hdGlvbnMvZmFkZS1vdXQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9kb20vY3VzdG9tLWVsZW1lbnRzL2NvZ251cy1jaGF0Ym90LWJ1dHRvbi5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2xpYnMvaWZyYW1lLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvbW9kZWxzL2NoYXRib3QtdXNlci5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2hlbHBlcnMvcmVzdC1hcGkvc2V0LWNoYXRib3QtdXNlci1uYW1lLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvaGVscGVycy9yZXN0LWFwaS9zZXQtY2hhdGJvdC11c2VyLWF2YXRhci5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2NvbXBvbmVudHMvY2ItdXNlci5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2hlbHBlcnMvcmVzdC1hcGkvZ2V0LXNlc3Npb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9oZWxwZXJzL3Jlc3QtYXBpL2dldC1vci1jcmVhdGUtY2hhdGJvdC1zZXNzaW9uLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvaGVscGVycy9yZXN0LWFwaS9zZW5kLXRleHQuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9oZWxwZXJzL3Jlc3QtYXBpL3NlbmQtdm9pY2UuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9oZWxwZXJzL3Jlc3QtYXBpL3NlbmQtcG9zdC1iYWNrLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvaGVscGVycy9yZXN0LWFwaS9zZW5kLXJlc2V0LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvaGVscGVycy9yZXN0LWFwaS9zZW5kLXN0YXJ0LWNvbnZlcnNhdGlvbi5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL3V0aWxzL2NvbW11bmljYXRpb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9jb21wb25lbnRzL3Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9tb2RlbHMvc2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2hlbHBlcnMvcmVzdC1hcGkvY3JlYXRlLXNlc3Npb24uanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9jb21wb25lbnRzL2NiLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly9Db2dudXNDaGF0Ym90Ly4vc3JjL2hlbHBlcnMvcmVzdC1hcGkvZ2V0LWNoYW5uZWwuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9oZWxwZXJzL3Jlc3QtYXBpL2dldC1jaGFubmVsLXRva2VuLmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvaGVscGVycy9yZXN0LWFwaS9nZXQtaW50ZW50LmpzIiwid2VicGFjazovL0NvZ251c0NoYXRib3QvLi9zcmMvbGlicy9hcGkuanMiLCJ3ZWJwYWNrOi8vQ29nbnVzQ2hhdGJvdC8uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJ3aW5kb3ciLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0dGVyIiwidmFsdWUiLCJrZXkiLCJiaW5kIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwib2JqZWN0IiwicHJvcGVydHkiLCJnbG9iYWwiLCJNYXRoIiwic2VsZiIsIkZ1bmN0aW9uIiwiX19nIiwic3RvcmUiLCJyZXF1aXJlIiwidWlkIiwiU3ltYm9sIiwiVVNFX1NZTUJPTCIsIm5hbWUiLCJpdCIsImlzT2JqZWN0IiwiVHlwZUVycm9yIiwiY2xhc3NvZiIsInRlc3QiLCJ0aGlzIiwiZGVmaW5lUHJvcGVydHkiLCJhIiwiSW50ZXJuYWwiLCJuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkiLCJPd25Qcm9taXNlQ2FwYWJpbGl0eSIsIldyYXBwZXIiLCJMSUJSQVJZIiwiY3R4IiwiJGV4cG9ydCIsImFGdW5jdGlvbiIsImFuSW5zdGFuY2UiLCJmb3JPZiIsInNwZWNpZXNDb25zdHJ1Y3RvciIsInRhc2siLCJzZXQiLCJtaWNyb3Rhc2siLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSIsInBlcmZvcm0iLCJ1c2VyQWdlbnQiLCJwcm9taXNlUmVzb2x2ZSIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsInY4IiwiJFByb21pc2UiLCJpc05vZGUiLCJlbXB0eSIsIm5ld1Byb21pc2VDYXBhYmlsaXR5IiwiZiIsIlVTRV9OQVRJVkUiLCJwcm9taXNlIiwicmVzb2x2ZSIsIkZha2VQcm9taXNlIiwiY29uc3RydWN0b3IiLCJleGVjIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwidGhlbiIsImluZGV4T2YiLCJlIiwiaXNUaGVuYWJsZSIsIm5vdGlmeSIsImlzUmVqZWN0IiwiX24iLCJjaGFpbiIsIl9jIiwiX3YiLCJvayIsIl9zIiwiaSIsInJ1biIsInJlYWN0aW9uIiwicmVzdWx0IiwiZXhpdGVkIiwiaGFuZGxlciIsImZhaWwiLCJyZWplY3QiLCJkb21haW4iLCJfaCIsIm9uSGFuZGxlVW5oYW5kbGVkIiwiZW50ZXIiLCJleGl0IiwibGVuZ3RoIiwib25VbmhhbmRsZWQiLCJjb25zb2xlIiwidW5oYW5kbGVkIiwiaXNVbmhhbmRsZWQiLCJlbWl0Iiwib251bmhhbmRsZWRyZWplY3Rpb24iLCJyZWFzb24iLCJlcnJvciIsIl9hIiwidW5kZWZpbmVkIiwidiIsIm9ucmVqZWN0aW9uaGFuZGxlZCIsIiRyZWplY3QiLCJfZCIsIl93Iiwic2xpY2UiLCIkcmVzb2x2ZSIsIndyYXBwZXIiLCJleGVjdXRvciIsImVyciIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInB1c2giLCJDIiwiRyIsIlciLCJGIiwiUHJvbWlzZSIsIlMiLCJyIiwiY2FwYWJpbGl0eSIsIiQkcmVqZWN0IiwieCIsIml0ZXIiLCJhbGwiLCJpdGVyYWJsZSIsInZhbHVlcyIsImluZGV4IiwicmVtYWluaW5nIiwiJGluZGV4IiwiYWxyZWFkeUNhbGxlZCIsInJhY2UiLCJhbk9iamVjdCIsIklFOF9ET01fREVGSU5FIiwidG9QcmltaXRpdmUiLCJkUCIsIk8iLCJQIiwiQXR0cmlidXRlcyIsIk9wIiwiaGFzT3duIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpbk1vZHVsZSIsInJ1bnRpbWUiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJ3cmFwIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwiR3AiLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkdlbmVyYXRvciIsImNyZWF0ZSIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiZGlzcGxheU5hbWUiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsIm1hcmsiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImF3cmFwIiwiYXJnIiwiX19hd2FpdCIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsIkFzeW5jSXRlcmF0b3IiLCJhc3luYyIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJuZXh0IiwiZG9uZSIsInRvU3RyaW5nIiwia2V5cyIsInJldmVyc2UiLCJwb3AiLCJDb250ZXh0IiwicmVzZXQiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsInNlbnQiLCJfc2VudCIsImRlbGVnYXRlIiwibWV0aG9kIiwidHJ5RW50cmllcyIsImZvckVhY2giLCJyZXNldFRyeUVudHJ5IiwiY2hhckF0IiwiaXNOYU4iLCJzdG9wIiwicm9vdFJlY29yZCIsImNvbXBsZXRpb24iLCJ0eXBlIiwicnZhbCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiZXhjZXB0aW9uIiwiY29udGV4dCIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsInJlY29yZCIsImVudHJ5IiwidHJ5TG9jIiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiRXJyb3IiLCJhYnJ1cHQiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsImFmdGVyTG9jIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlc3VsdE5hbWUiLCJuZXh0TG9jIiwicHJvdG9HZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJfaW52b2tlIiwic3RhdGUiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwidHJ5Q2F0Y2giLCJtYWtlSW52b2tlTWV0aG9kIiwiZm4iLCJvYmoiLCJwcmV2aW91c1Byb21pc2UiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsImludm9rZSIsInVud3JhcHBlZCIsInJldHVybiIsImluZm8iLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwiaXRlcmF0b3JNZXRob2QiLCJjb3JlIiwiaGlkZSIsInJlZGVmaW5lIiwic291cmNlIiwib3duIiwib3V0IiwiZXhwIiwiSVNfRk9SQ0VEIiwiSVNfR0xPQkFMIiwiSVNfU1RBVElDIiwiSVNfUFJPVE8iLCJJU19CSU5EIiwiQiIsInRhcmdldCIsImV4cFByb3RvIiwiVSIsIlIiLCJoYXMiLCJTUkMiLCIkdG9TdHJpbmciLCJUUEwiLCJzcGxpdCIsImluc3BlY3RTb3VyY2UiLCJ2YWwiLCJzYWZlIiwiaXNGdW5jdGlvbiIsImpvaW4iLCJTdHJpbmciLCJ0IiwibiIsInMiLCJvIiwidSIsImNvZGUiLCJsIiwiMSIsIl9kZXJlcV8iLCJzY2hlZHVsZURyYWluIiwiZHJhaW5pbmciLCJNdXRhdGlvbiIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiY2FsbGVkIiwib2JzZXJ2ZXIiLCJuZXh0VGljayIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJkYXRhIiwic2V0SW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJjcmVhdGVFbGVtZW50Iiwic2NyaXB0RWwiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJkb2N1bWVudEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInNldFRpbWVvdXQiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwicXVldWUiLCJvbGRRdWV1ZSIsImxlbiIsIjIiLCJpbW1lZGlhdGUiLCJJTlRFUk5BTCIsImhhbmRsZXJzIiwiUkVKRUNURUQiLCJGVUxGSUxMRUQiLCJQRU5ESU5HIiwicmVzb2x2ZXIiLCJvdXRjb21lIiwic2FmZWx5UmVzb2x2ZVRoZW5hYmxlIiwiUXVldWVJdGVtIiwiY2FsbEZ1bGZpbGxlZCIsIm90aGVyQ2FsbEZ1bGZpbGxlZCIsImNhbGxSZWplY3RlZCIsIm90aGVyQ2FsbFJlamVjdGVkIiwidW53cmFwIiwiZnVuYyIsInJldHVyblZhbHVlIiwiZ2V0VGhlbiIsImFwcGx5IiwiYXJndW1lbnRzIiwidGhlbmFibGUiLCJvbkVycm9yIiwib25TdWNjZXNzIiwic3RhdHVzIiwiQXJyYXkiLCJyZXNvbHZlZCIsImFsbFJlc29sdmVyIiwib3V0VmFsdWUiLCJyZXNwb25zZSIsIjMiLCI0IiwiX3R5cGVvZiIsImlkYiIsImluZGV4ZWREQiIsIndlYmtpdEluZGV4ZWREQiIsIm1vekluZGV4ZWREQiIsIk9JbmRleGVkREIiLCJtc0luZGV4ZWREQiIsImdldElEQiIsImNyZWF0ZUJsb2IiLCJwYXJ0cyIsInByb3BlcnRpZXMiLCJCbG9iIiwiYnVpbGRlciIsIkJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJhcHBlbmQiLCJnZXRCbG9iIiwiUHJvbWlzZSQxIiwiZXhlY3V0ZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJleGVjdXRlVHdvQ2FsbGJhY2tzIiwiZXJyb3JDYWxsYmFjayIsIm5vcm1hbGl6ZUtleSIsIndhcm4iLCJnZXRDYWxsYmFjayIsIkRFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUiLCJzdXBwb3J0c0Jsb2JzIiwiZGJDb250ZXh0cyIsIlJFQURfT05MWSIsIlJFQURfV1JJVEUiLCJfY2hlY2tCbG9iU3VwcG9ydCIsInR4biIsInRyYW5zYWN0aW9uIiwiYmxvYiIsIm9iamVjdFN0b3JlIiwicHV0Iiwib25hYm9ydCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwib25jb21wbGV0ZSIsIm1hdGNoZWRDaHJvbWUiLCJuYXZpZ2F0b3IiLCJtYXRjaCIsIm1hdGNoZWRFZGdlIiwicGFyc2VJbnQiLCJfY2hlY2tCbG9iU3VwcG9ydFdpdGhvdXRDYWNoaW5nIiwiX2RlZmVyUmVhZGluZXNzIiwiZGJJbmZvIiwiZGJDb250ZXh0IiwiZGVmZXJyZWRPcGVyYXRpb24iLCJkZWZlcnJlZE9wZXJhdGlvbnMiLCJkYlJlYWR5IiwiX2FkdmFuY2VSZWFkaW5lc3MiLCJfcmVqZWN0UmVhZGluZXNzIiwiX2dldENvbm5lY3Rpb24iLCJ1cGdyYWRlTmVlZGVkIiwiZm9yYWdlcyIsImRiIiwiY2xvc2UiLCJkYkFyZ3MiLCJ2ZXJzaW9uIiwib3BlbnJlcSIsIm9wZW4iLCJvbnVwZ3JhZGVuZWVkZWQiLCJjcmVhdGVPYmplY3RTdG9yZSIsInN0b3JlTmFtZSIsIm9sZFZlcnNpb24iLCJleCIsIm5ld1ZlcnNpb24iLCJvbmVycm9yIiwib25zdWNjZXNzIiwiX2dldE9yaWdpbmFsQ29ubmVjdGlvbiIsIl9nZXRVcGdyYWRlZENvbm5lY3Rpb24iLCJfaXNVcGdyYWRlTmVlZGVkIiwiZGVmYXVsdFZlcnNpb24iLCJpc05ld1N0b3JlIiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwiaXNEb3duZ3JhZGUiLCJpc1VwZ3JhZGUiLCJpbmNWZXJzaW9uIiwiX2RlY29kZUJsb2IiLCJlbmNvZGVkQmxvYiIsImJpbiIsImJ1ZiIsIkFycmF5QnVmZmVyIiwiYXJyIiwiVWludDhBcnJheSIsImNoYXJDb2RlQXQiLCJfYmluU3RyaW5nVG9BcnJheUJ1ZmZlciIsImF0b2IiLCJfaXNFbmNvZGVkQmxvYiIsIl9fbG9jYWxfZm9yYWdlX2VuY29kZWRfYmxvYiIsIl9mdWxseVJlYWR5IiwiX2luaXRSZWFkeSIsIl9kYkluZm8iLCJjcmVhdGVUcmFuc2FjdGlvbiIsIm1vZGUiLCJyZXRyaWVzIiwidHgiLCJmb3JhZ2UiLCJfdHJ5UmVjb25uZWN0IiwiYXN5bmNTdG9yYWdlIiwiX2RyaXZlciIsIl9pbml0U3RvcmFnZSIsIm9wdGlvbnMiLCJyZWFkeSIsImluaXRQcm9taXNlcyIsImlnbm9yZUVycm9ycyIsImoiLCJfZGVmYXVsdENvbmZpZyIsImsiLCJfc3VwcG9ydCIsImlzU2FmYXJpIiwib3BlbkRhdGFiYXNlIiwicGxhdGZvcm0iLCJoYXNGZXRjaCIsImZldGNoIiwiSURCS2V5UmFuZ2UiLCJpc0luZGV4ZWREQlZhbGlkIiwiaXRlcmF0ZSIsInJlcSIsIm9wZW5DdXJzb3IiLCJpdGVyYXRpb25OdW1iZXIiLCJjdXJzb3IiLCJnZXRJdGVtIiwic2V0SXRlbSIsImJsb2JTdXBwb3J0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZGVuZCIsImJhc2U2NCIsImJ0b2EiLCJyZWFkQXNCaW5hcnlTdHJpbmciLCJyZW1vdmVJdGVtIiwiY2xlYXIiLCJjb3VudCIsImFkdmFuY2VkIiwiYWR2YW5jZSIsImRyb3BJbnN0YW5jZSIsImN1cnJlbnRDb25maWciLCJjb25maWciLCJkYlByb21pc2UiLCJkZWxldGVPYmplY3RTdG9yZSIsIl9mb3JhZ2UyIiwiZGVsZXRlRGF0YWJhc2UiLCJvbmJsb2NrZWQiLCJCQVNFX0NIQVJTIiwiQkxPQl9UWVBFX1BSRUZJWCIsIkJMT0JfVFlQRV9QUkVGSVhfUkVHRVgiLCJTRVJJQUxJWkVEX01BUktFUiIsIlNFUklBTElaRURfTUFSS0VSX0xFTkdUSCIsIlRZUEVfQVJSQVlCVUZGRVIiLCJUWVBFX0JMT0IiLCJUWVBFX0lOVDhBUlJBWSIsIlRZUEVfVUlOVDhBUlJBWSIsIlRZUEVfVUlOVDhDTEFNUEVEQVJSQVkiLCJUWVBFX0lOVDE2QVJSQVkiLCJUWVBFX0lOVDMyQVJSQVkiLCJUWVBFX1VJTlQxNkFSUkFZIiwiVFlQRV9VSU5UMzJBUlJBWSIsIlRZUEVfRkxPQVQzMkFSUkFZIiwiVFlQRV9GTE9BVDY0QVJSQVkiLCJUWVBFX1NFUklBTElaRURfTUFSS0VSX0xFTkdUSCIsInRvU3RyaW5nJDEiLCJzdHJpbmdUb0J1ZmZlciIsInNlcmlhbGl6ZWRTdHJpbmciLCJlbmNvZGVkMSIsImVuY29kZWQyIiwiZW5jb2RlZDMiLCJlbmNvZGVkNCIsImJ1ZmZlckxlbmd0aCIsInAiLCJidWZmZXIiLCJieXRlcyIsImJ1ZmZlclRvU3RyaW5nIiwiYmFzZTY0U3RyaW5nIiwic3Vic3RyaW5nIiwibG9jYWxmb3JhZ2VTZXJpYWxpemVyIiwic2VyaWFsaXplIiwidmFsdWVUeXBlIiwibWFya2VyIiwiZmlsZVJlYWRlciIsIm9ubG9hZCIsInN0ciIsInJlYWRBc0FycmF5QnVmZmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImRlc2VyaWFsaXplIiwicGFyc2UiLCJibG9iVHlwZSIsIm1hdGNoZXIiLCJJbnQ4QXJyYXkiLCJVaW50OENsYW1wZWRBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsImNyZWF0ZURiVGFibGUiLCJleGVjdXRlU3FsIiwidHJ5RXhlY3V0ZVNxbCIsInNxbFN0YXRlbWVudCIsImFyZ3MiLCJTWU5UQVhfRVJSIiwicmVzdWx0cyIsInJvd3MiLCJfc2V0SXRlbSIsInJldHJpZXNMZWZ0Iiwib3JpZ2luYWxWYWx1ZSIsInNlcmlhbGl6ZXIiLCJzcWxFcnJvciIsIlFVT1RBX0VSUiIsIndlYlNRTFN0b3JhZ2UiLCJkYkluZm9Qcm9taXNlIiwiZGVzY3JpcHRpb24iLCJzaXplIiwiaXRlbSIsImMiLCJzdG9yZU5hbWVzIiwiZ2V0QWxsU3RvcmVOYW1lcyIsIm9wZXJhdGlvbkluZm8iLCJkcm9wVGFibGUiLCJvcGVyYXRpb25zIiwiX2dldEtleVByZWZpeCIsImRlZmF1bHRDb25maWciLCJrZXlQcmVmaXgiLCJfaXNMb2NhbFN0b3JhZ2VVc2FibGUiLCJsb2NhbFN0b3JhZ2UiLCJjaGVja0lmTG9jYWxTdG9yYWdlVGhyb3dzIiwibG9jYWxTdG9yYWdlV3JhcHBlciIsImlzTG9jYWxTdG9yYWdlVmFsaWQiLCJrZXlQcmVmaXhMZW5ndGgiLCJpdGVtS2V5IiwiaW5jbHVkZXMiLCJhcnJheSIsInNlYXJjaEVsZW1lbnQiLCJ5IiwiaXNBcnJheSIsIkRlZmluZWREcml2ZXJzIiwiRHJpdmVyU3VwcG9ydCIsIkRlZmF1bHREcml2ZXJzIiwiSU5ERVhFRERCIiwiV0VCU1FMIiwiTE9DQUxTVE9SQUdFIiwiRGVmYXVsdERyaXZlck9yZGVyIiwiT3B0aW9uYWxEcml2ZXJNZXRob2RzIiwiTGlicmFyeU1ldGhvZHMiLCJjb25jYXQiLCJEZWZhdWx0Q29uZmlnIiwiZHJpdmVyIiwiY2FsbFdoZW5SZWFkeSIsImxvY2FsRm9yYWdlSW5zdGFuY2UiLCJsaWJyYXJ5TWV0aG9kIiwiX2FyZ3MiLCJleHRlbmQiLCJfa2V5IiwibG9jYWxmb3JhZ2VfanMiLCJMb2NhbEZvcmFnZSIsImRyaXZlclR5cGVLZXkiLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2NsYXNzQ2FsbENoZWNrIiwiZHJpdmVyTmFtZSIsImRlZmluZURyaXZlciIsIl9jb25maWciLCJfZHJpdmVyU2V0IiwiX2luaXREcml2ZXIiLCJfcmVhZHkiLCJfd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5Iiwic2V0RHJpdmVyIiwicmVwbGFjZSIsImRyaXZlck9iamVjdCIsImNvbXBsaWFuY2VFcnJvciIsImRyaXZlck1ldGhvZHMiLCJkcml2ZXJNZXRob2ROYW1lIiwibWV0aG9kTm90SW1wbGVtZW50ZWRGYWN0b3J5IiwibWV0aG9kTmFtZSIsIl9pIiwiX2xlbiIsIm9wdGlvbmFsRHJpdmVyTWV0aG9kIiwiY29uZmlndXJlTWlzc2luZ01ldGhvZHMiLCJzZXREcml2ZXJTdXBwb3J0Iiwic3VwcG9ydCIsImdldERyaXZlciIsImdldERyaXZlclByb21pc2UiLCJnZXRTZXJpYWxpemVyIiwic2VyaWFsaXplclByb21pc2UiLCJkcml2ZXJzIiwic3VwcG9ydGVkRHJpdmVycyIsIl9nZXRTdXBwb3J0ZWREcml2ZXJzIiwic2V0RHJpdmVyVG9Db25maWciLCJleHRlbmRTZWxmV2l0aERyaXZlciIsIl9leHRlbmQiLCJvbGREcml2ZXJTZXREb25lIiwiY3VycmVudERyaXZlckluZGV4IiwiZHJpdmVyUHJvbWlzZUxvb3AiLCJpbml0RHJpdmVyIiwic3VwcG9ydHMiLCJsaWJyYXJ5TWV0aG9kc0FuZFByb3BlcnRpZXMiLCJjcmVhdGVJbnN0YW5jZSIsIl9fZSIsImNyZWF0ZURlc2MiLCJ0aGF0IiwiYiIsIiRrZXlzIiwiZW51bUJ1Z0tleXMiLCJJT2JqZWN0IiwiZGVmaW5lZCIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwibSIsImQiLCJjb25maWd1cmFibGUiLCJfX2VzTW9kdWxlIiwiZXZhbCIsImlkIiwicHgiLCJyYW5kb20iLCJkZWYiLCJUQUciLCJ0YWciLCJzdGF0IiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwibnVsbFRhZyIsInByb3h5VGFnIiwidW5kZWZpbmVkVGFnIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwib2JqZWN0UHJvdG8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyIsImlzT3duIiwidW5tYXNrZWQiLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsImNvcHlyaWdodCIsImJpdG1hcCIsIndyaXRhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJkUHMiLCJJRV9QUk9UTyIsIkVtcHR5IiwiY3JlYXRlRGljdCIsImlmcmFtZURvY3VtZW50IiwiaWZyYW1lIiwic3R5bGUiLCJkaXNwbGF5Iiwic3JjIiwiY29udGVudFdpbmRvdyIsIndyaXRlIiwibHQiLCJQcm9wZXJ0aWVzIiwiYWRkVG9VbnNjb3BhYmxlcyIsInN0ZXAiLCJJdGVyYXRvcnMiLCJ0b0lPYmplY3QiLCJpdGVyYXRlZCIsImtpbmQiLCJfdCIsIl9rIiwiQXJndW1lbnRzIiwiaXMiLCJ2YWx1ZU9mIiwiREVTQ1JJUFRPUlMiLCJNRVRBIiwiS0VZIiwiJGZhaWxzIiwic2hhcmVkIiwic2V0VG9TdHJpbmdUYWciLCJ3a3MiLCJ3a3NFeHQiLCJ3a3NEZWZpbmUiLCJlbnVtS2V5cyIsInRvT2JqZWN0IiwiX2NyZWF0ZSIsImdPUE5FeHQiLCIkR09QRCIsIiRHT1BTIiwiJERQIiwiZ09QRCIsImdPUE4iLCIkSlNPTiIsIl9zdHJpbmdpZnkiLCJISURERU4iLCJUT19QUklNSVRJVkUiLCJpc0VudW0iLCJTeW1ib2xSZWdpc3RyeSIsIkFsbFN5bWJvbHMiLCJPUFN5bWJvbHMiLCJPYmplY3RQcm90byIsIlFPYmplY3QiLCJzZXR0ZXIiLCJmaW5kQ2hpbGQiLCJzZXRTeW1ib2xEZXNjIiwiRCIsInByb3RvRGVzYyIsInN5bSIsImlzU3ltYm9sIiwiJGRlZmluZVByb3BlcnR5IiwiJGRlZmluZVByb3BlcnRpZXMiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJFIiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIiRnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibmFtZXMiLCIkZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiSVNfT1AiLCIkc2V0IiwiZXM2U3ltYm9scyIsIndlbGxLbm93blN5bWJvbHMiLCJrZXlGb3IiLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIkZBSUxTX09OX1BSSU1JVElWRVMiLCJyZXBsYWNlciIsIiRyZXBsYWNlciIsInNldERlc2MiLCJpc0V4dGVuc2libGUiLCJGUkVFWkUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNldE1ldGEiLCJ3IiwibWV0YSIsIk5FRUQiLCJmYXN0S2V5IiwiZ2V0V2VhayIsIm9uRnJlZXplIiwiY2VpbCIsImZsb29yIiwiJGZsYWdzIiwiUmVnRXhwIiwiZmxhZ3MiLCJmYWlscyIsInJDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiTkVXX1RBUkdFVF9CVUciLCJBUkdTX0JVRyIsIlRhcmdldCIsIm5ld1RhcmdldCIsIiRhcmdzIiwicHJvdG8iLCJjb2YiLCJBUkciLCJUIiwidHJ5R2V0IiwiY2FsbGVlIiwiZm9yYmlkZGVuRmllbGQiLCJpc0FycmF5SXRlciIsInRvTGVuZ3RoIiwiZ2V0SXRlckZuIiwiQlJFQUsiLCJSRVRVUk4iLCJlbnRyaWVzIiwiSVRFUkFUT1IiLCJpdGVyRm4iLCIkaXRlcmF0b3JzIiwiZ2V0S2V5cyIsIlRPX1NUUklOR19UQUciLCJBcnJheVZhbHVlcyIsIkRPTUl0ZXJhYmxlcyIsIkNTU1J1bGVMaXN0IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsIkNTU1ZhbHVlTGlzdCIsIkNsaWVudFJlY3RMaXN0IiwiRE9NUmVjdExpc3QiLCJET01TdHJpbmdMaXN0IiwiRE9NVG9rZW5MaXN0IiwiRGF0YVRyYW5zZmVySXRlbUxpc3QiLCJGaWxlTGlzdCIsIkhUTUxBbGxDb2xsZWN0aW9uIiwiSFRNTENvbGxlY3Rpb24iLCJIVE1MRm9ybUVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIk1lZGlhTGlzdCIsIk1pbWVUeXBlQXJyYXkiLCJOYW1lZE5vZGVNYXAiLCJOb2RlTGlzdCIsIlBhaW50UmVxdWVzdExpc3QiLCJQbHVnaW4iLCJQbHVnaW5BcnJheSIsIlNWR0xlbmd0aExpc3QiLCJTVkdOdW1iZXJMaXN0IiwiU1ZHUGF0aFNlZ0xpc3QiLCJTVkdQb2ludExpc3QiLCJTVkdTdHJpbmdMaXN0IiwiU1ZHVHJhbnNmb3JtTGlzdCIsIlNvdXJjZUJ1ZmZlckxpc3QiLCJTdHlsZVNoZWV0TGlzdCIsIlRleHRUcmFja0N1ZUxpc3QiLCJUZXh0VHJhY2tMaXN0IiwiVG91Y2hMaXN0IiwiY29sbGVjdGlvbnMiLCJOQU1FIiwiZXhwbGljaXQiLCJDb2xsZWN0aW9uIiwiJGl0ZXJDcmVhdGUiLCJCVUdHWSIsInJldHVyblRoaXMiLCJCYXNlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsIm1ldGhvZHMiLCJnZXRNZXRob2QiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsImFycmF5SW5kZXhPZiIsInRvSW50ZWdlciIsIm1pbiIsImhpZGRlbktleXMiLCJwSUUiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwidW5pY29kZSIsInN0aWNreSIsInVuIiwiY2hlY2siLCJidWdneSIsImRlZmVyIiwicG9ydCIsImh0bWwiLCJjZWwiLCJzZXRUYXNrIiwiY2xlYXJUYXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJEaXNwYXRjaCIsImNvdW50ZXIiLCJsaXN0ZW5lciIsImV2ZW50Iiwibm93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImltcG9ydFNjcmlwdHMiLCJQcm9taXNlQ2FwYWJpbGl0eSIsIiQkcmVzb2x2ZSIsIlNQRUNJRVMiLCJTQUZFX0NMT1NJTkciLCJyaXRlciIsImZyb20iLCJza2lwQ2xvc2luZyIsIlRZUEUiLCJhc3NpZ24iLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXJnc1RhZyIsIm1hcFRhZyIsInNldFRhZyIsInJlSXNIb3N0Q3RvciIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsInRyYW5zZm9ybSIsImZ1bmNQcm90byIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJuYXRpdmVLZXlzIiwiRGF0YVZpZXciLCJnZXROYXRpdmUiLCJNYXAiLCJTZXQiLCJXZWFrTWFwIiwibm9uRW51bVNoYWRvd3MiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJ0b1NvdXJjZSIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwiaXNIb3N0T2JqZWN0IiwiZ2V0VmFsdWUiLCJnZXRUYWciLCJpc0FyZ3VtZW50cyIsImlzT2JqZWN0TGlrZSIsImlzQXJyYXlMaWtlIiwiaXNBcnJheUxpa2VPYmplY3QiLCJDdG9yIiwiY3RvclN0cmluZyIsImlzTGVuZ3RoIiwic3BsaWNlIiwiaXNQcm90b3R5cGUiLCJnT1BTIiwiZ2V0U3ltYm9scyIsInN5bWJvbHMiLCJ0b0Fic29sdXRlSW5kZXgiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZWwiLCJmcm9tSW5kZXgiLCJtYXgiLCJ3aW5kb3dOYW1lcyIsImdldFdpbmRvd05hbWVzIiwiYXJyYXlTbGljZSIsImZhY3RvcmllcyIsInBhcnRBcmdzIiwiYm91bmQiLCJyZXQiLCJBcnJheVByb3RvIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJtYWNyb3Rhc2siLCJPYnNlcnZlciIsImhlYWQiLCJsYXN0IiwiZmx1c2giLCJwYXJlbnQiLCJzdGFuZGFsb25lIiwidG9nZ2xlIiwibm9kZSIsInByb21pc2VDYXBhYmlsaXR5Iiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJjaGlsZHJlbiIsImdldEdsb2JhbCIsImRlZmF1bHQiLCJIZWFkZXJzIiwiUmVxdWVzdCIsIlJlc3BvbnNlIiwicm5nIiwiYnl0ZXNUb1V1aWQiLCJvZmZzZXQiLCJybmRzIiwiaWkiLCJnZXRSYW5kb21WYWx1ZXMiLCJjcnlwdG8iLCJtc0NyeXB0byIsInJuZHM4IiwiYnl0ZVRvSGV4Iiwic3Vic3RyIiwiYnRoIiwiVU5TQ09QQUJMRVMiLCJkZXNjcmlwdG9yIiwiJGF0IiwicG9pbnQiLCJUT19TVFJJTkciLCJwb3MiLCJzdHJvbmciLCJ2YWxpZGF0ZSIsImdldEVudHJ5IiwicmVkZWZpbmVBbGwiLCIkaXRlckRlZmluZSIsInNldFNwZWNpZXMiLCJTSVpFIiwiX2YiLCJnZXRDb25zdHJ1Y3RvciIsIklTX01BUCIsIkFEREVSIiwiX2wiLCJjYWxsYmFja2ZuIiwic2V0U3Ryb25nIiwiJGl0ZXJEZXRlY3QiLCJpbmhlcml0SWZSZXF1aXJlZCIsImNvbW1vbiIsIklTX1dFQUsiLCJmaXhNZXRob2QiLCJIQVNOVF9DSEFJTklORyIsIlRIUk9XU19PTl9QUklNSVRJVkVTIiwiQUNDRVBUX0lURVJBQkxFUyIsIkJVR0dZX1pFUk8iLCIkaW5zdGFuY2UiLCIkYXNzaWduIiwiQSIsIksiLCJhTGVuIiwiQVBQX0NPTlNUQU5UUyIsIlZFUlNJT04iLCJERUZBVUxUUyIsIkxBTkdVQUdFIiwiRU5DUllQVElPTiIsIkVOVklST05NRU5UIiwiSUZSQU1FX0NTUyIsInBvc2l0aW9uIiwiYm90dG9tIiwicmlnaHQiLCJoZWlnaHQiLCJ3aWR0aCIsImJvcmRlciIsIkVOVklST05NRU5UUyIsIkVOVklST05NRU5UX1NIT1JUX05BTUVTIiwiZGV2ZWxvcG1lbnQiLCJzdGFnaW5nIiwicHJvZHVjdGlvbiIsImxvY2FsIiwiRU5WSVJPTk1FTlRfSURTIiwiRU5DUllQVEVEX0VOVklST05NRU5UUyIsIkxBTkdVQUdFUyIsIkxPR0lOX1RZUEVTIiwiVVJMUyIsIklGUkFNRSIsIkFQSSIsIkVWRU5UUyIsIkFQSV9SRUFEWSIsIkFQSV9GQUlMIiwiTE9HR0VEX0lOIiwiTE9HR0VEX09VVCIsIkxPR0lOX0ZBSUwiLCJDT05WRVJTQVRJT05fUkVQTFlfRkFJTCIsIkNPTlZFUlNBVElPTl9VUERBVEUiLCJUT0tFTl9ORUdPVElBVElPTl9SRVFVSVJFRCIsIklGUkFNRV9MT0FERUQiLCJTVEFURVMiLCJNT0RFTF9NT0RVTEUiLCJNT0RFTF9DSEFOTkVMUyIsIk1PREVMX0lOVEVOVCIsIk1PREVMX1NFU1NJT04iLCJVUkxfQVBJIiwiVVJMX0lGUkFNRSIsIklTX0VOQ1JZUFRFRCIsIklTX0xPR0dFRF9JTiIsIklTX0lOSVRJQUxJWkVEIiwiSEFTX01PRFVMRSIsIkhBU19DSEFUQk9UX1VTRVIiLCJIQVNfQ0xJRU5UX1VTRVJfSUQiLCJIQVNfVVNFUiIsIkhBU19UT0tFTiIsIkhBU19QUk9KRUNUIiwiSEFTX0tFWSIsIkxPR0lOX01FVEhPRCIsIkVMRU1FTlRfSUZSQU1FIiwiSVNfSUZSQU1FX0lOX0RFQlVHX01PREUiLCJDT05WRVJTQVRJT04iLCJDSEFOTkVMX1RPS0VOIiwiU1RPUkFHRSIsIlVTRVIiLCJUT0tFTiIsIk9MRF9LRVkiLCJPTERfVE9LRU4iLCJvcmlnaW5hbCIsImVudmlyb25tZW50IiwibGFuZ3VhZ2UiLCJwb3NzaWJsZSIsImluamVjdERlcGVuZGVuY2llcyIsImFycmF5T2ZEZXBlbmRlbmNpZXMiLCJwb2ludGVyIiwiX2NsYXNzIiwiX2NsYXNzTmFtZSIsIkNvbmZpZ3VyYXRpb24iLCJpbnN0YW5jZXMiLCJTZXJ2aWNlIiwiZGVmYXVsdENvbmZpZ3VyYXRpb24iLCJjb25maWdPYmplY3QiLCJ1cmwiLCJhcGkiLCJlbmNyeXB0aW9uIiwic3VwZXIiLCJjb25maWdPYmplY3RLZXkiLCJjb25maWdPYmplY3RWYWxpZENvbmZpZ3MiLCJmcmVlemUiLCJidWlsZFVybCIsInJvdXRlIiwiY29uZmlndXJhdGlvbiIsImZpbHRlciIsIm1pZGRsZXdhcmVXaWxsRW5jcnlwdCIsInBvaW50ZXJTaG91bGRFbmNyeXB0IiwiZW5jcnlwdFN0cmluZyIsIkJsdWVEYXJ3aW5CYXNlRW5jcnlwdGlvbiIsIm9uZVdheUVuY3J5cHQiLCJTdG9yYWdlIiwibG9jYWxmb3JhZ2UiLCJjYXRjaCIsImRlbGV0ZSIsInVwZGF0ZUtleSIsIm5ld0tleSIsInNjb3BlIiwib2xkS2V5Iiwic3RvcmFnZSIsImVuY3J5cHRQYXlsb2FkIiwicGF5bG9hZCIsInBvaW50ZXJLZXkiLCJjb2dudXMiLCJ0d29XYXlFbmNyeXB0IiwiZGVjcnlwdCIsImRlY3J5cHRlZCIsInR3b1dheURlY3J5cHQiLCJkZWNyeXB0UGF5bG9hZCIsInBvaW50ZXJPbGRLZXkiLCJjdXN0b21LZXkiLCJtZXNzYWdlIiwicHJpdmF0ZVNjb3BlIiwiRW5jcnlwdGlvbiIsInVwZGF0ZVRva2VuIiwibmV3VG9rZW4iLCJ0b2tlbiIsImdldEZ1bmN0aW9uQ29udGVudCIsImZ1bmN0aW9uU3RyIiwiaXNFcXVhbEZ1bmN0aW9uIiwiYXJyYXlDb250YWluc0Z1bmN0aW9uIiwiVmFsaWRhdG9yIiwiaXNFbXB0eSIsImNvbnRhaW5zRnVuY3Rpb24iLCJjaGVja1Jlc3BvbnNlRm9yS2V5QW5kVG9rZW4iLCJkZWNyeXB0ZWRQYXlsb2FkIiwicG9pbnRlclRva2VuIiwidmFsaWRhdG9yIiwiX2V2ZW50cyIsIlB1YlN1YiIsIm9uIiwiZXZlbnROYW1lIiwib2ZmIiwiZ2V0RXZlbnRzIiwiZXZlbnRUb2tlbk5lZ290aWF0aW9uUmVxdWlyZWQiLCJwdWJTdWIiLCJfZmV0Y2giLCJfZXgiLCJoYW5kbGVSZXF1ZXN0IiwicGFyYW1zIiwianNvbiIsImxvZ2luRGVjcnlwdGlvbiIsImdldEZ1bGxSZXNwb25zZSIsImhhbmRsZVJlc3BvbnNlIiwicmV0dXJuVHlwZSIsInNlYXJjaE9uamVjdFBhdGgiLCJwYXRoIiwic3BsaXRQYXRoIiwiY3VycmVudE9iamVjdCIsInRlc3ROb2RlIiwiZGljdGlvbmFyeSIsIlRyYW5zbGF0ZSIsInNldExhbmd1YWdlIiwiaW5zdGFudCIsInRyaW0iLCJhdmFpbGFibGVTdGF0dXMiLCJidWlsZFJlc3BvbnNlIiwiaW5mb09iamVjdCIsImhhbmRsZUZhaWwiLCJnZXRIZWFkZXJzIiwicmVxdWVzdEdldCIsImhlYWRlcnMiLCJza2lwRW5jcnlwdGlvbiIsInBhcnNlQm9keSIsInJlcXVlc3RQb3N0IiwiX2RhdGEiLCJib2R5IiwiSHR0cCIsInBvc3QiLCJnZXRNb2R1bGVzIiwiaHR0cCIsInN0YXRlcyIsIlN0YXRlIiwibGlzdCIsImdldE1vZHVsZSIsInV1aWQiLCJnZXRDaGF0Qm90VXNlcklkIiwidXNlcklkIiwiY2xpZW50VXNlcklkIiwiZ2V0Q2hhdGJvdFVzZXIiLCJfYnVpbGRQYXlsb2FkIiwiaW5wdXQiLCJhdXRoIiwiY2hhbm5lbF90b2tlbiIsImNsaWVudF91c2VyX2lkIiwiZ2V0Q2hhdEJvdFVzZXIiLCJzdGFnZSIsImNvbnRleHRfdmFyaWFibGVzIiwiZXh0cmFjdGVkX2VudGl0aWVzIiwiYWN0aW9ucyIsImNsb3NlX3Nlc3Npb24iLCJlbmFibGVkIiwibG9nb3V0Iiwic2V0T3JjaGVzdHJhdG9yUGF5bG9hZCIsInYzIiwidGV4dCIsInZvaWNlIiwicG9zdEJhY2siLCJwb3N0YmFjayIsImxhYmVsIiwiYXJnVHlwZSIsInNlbmRMb2dvdXQiLCJJMThOIiwiRVJST1IiLCJNT0RVTEVfTk9UX0ZPVU5EIiwiU0VTU0lPTl9DUkVBVEVfV0lUSE9VVF9MT0dJTl9PUl9JTklUIiwiR0VUX09SX0NSRUFURV9TRVNTSU9OIiwiRU5DUllQVElPTl9OT1RfSU5JVElBTElaRUQiLCJJTlZBTElEX0NPR05VU19SRVNQT05TRV9PQkpFQ1QiLCJGQUlMRURfVE9fREVDUllQVCIsIkhUVFBfUkVRVUVTVF9GQUlMIiwiV0FSTiIsIkFMUkVBRFlfSU5TVEFOQ0lBVEVEIiwiTk9fSUZSQU1FX0VMRU1FTlRfRk9VTkQiLCJzZXRDcmVkZW50aWFscyIsImNyZWRlbnRpYWxzIiwidXNlciIsInNldExvZ2dlZEluU3RhdGUiLCJhcGlMb2dpbiIsImxvZ2luUGFyYW1zIiwibG9naW5EYXRhIiwiZW1haWwiLCJwYXNzd29yZCIsInJlZ2V4IiwiaXNFbWFpbCIsImNoZWNrTG9naW5UeXBlIiwiZmlyc3RBcmd1bWVudCIsImxvZ2luVHlwZSIsImxvZ2luIiwiSVNfQk9UX1JFR0VYUCIsIkRldmljZVVVSUQiLCJkZWZPcHRpb25zIiwib3MiLCJwaXhlbERlcHRoIiwiY29sb3JEZXB0aCIsInJlc29sdXRpb24iLCJpc0F1dGhvcml0YXRpdmUiLCJzaWxrQWNjZWxlcmF0ZWQiLCJpc0tpbmRsZUZpcmUiLCJpc0Rlc2t0b3AiLCJpc01vYmlsZSIsImlzVGFibGV0IiwiaXNXaW5kb3dzIiwiaXNMaW51eCIsImlzTGludXg2NCIsImlzQ2hyb21lT1MiLCJpc01hYyIsImlzaVBhZCIsImlzaVBob25lIiwiaXNpUG9kIiwiaXNBbmRyb2lkIiwiaXNTYW1zdW5nIiwiaXNTbWFydFRWIiwiaXNSYXNwYmVycnkiLCJpc0JsYWNrYmVycnkiLCJpc1RvdWNoU2NyZWVuIiwiaXNPcGVyYSIsImlzSUUiLCJpc0VkZ2UiLCJpc0lFQ29tcGF0aWJpbGl0eU1vZGUiLCJpc0ZpcmVmb3giLCJpc1dlYmtpdCIsImlzQ2hyb21lIiwiaXNLb25xdWVyb3IiLCJpc09tbmlXZWIiLCJpc1NlYU1vbmtleSIsImlzRmxvY2siLCJpc0FtYXlhIiwiaXNQaGFudG9tSlMiLCJpc0VwaXBoYW55IiwiY3B1Q29yZXMiLCJfVmVyc2lvbnMiLCJFZGdlIiwiRmlyZWZveCIsIklFIiwiQ2hyb21lIiwiQ2hyb21pdW0iLCJTYWZhcmkiLCJPcGVyYSIsIlBzMyIsIlBzcCIsIkFtYXlhIiwiU2VhTW9ua2V5IiwiT21uaVdlYiIsIkZsb2NrIiwiRXBpcGhhbnkiLCJXaW5KcyIsIlBoYW50b21KUyIsIlVDIiwiX0Jyb3dzZXJzIiwiS29ucXVlcm9yIiwiUFMzIiwiUFNQIiwiX09TIiwiV2luZG93czEwIiwiV2luZG93czgxIiwiV2luZG93czgiLCJXaW5kb3dzNyIsIlVua25vd25XaW5kb3dzIiwiV2luZG93c1Zpc3RhIiwiV2luZG93czIwMDMiLCJXaW5kb3dzWFAiLCJXaW5kb3dzMjAwMCIsIldpbmRvd3NQaG9uZTgiLCJPU1hDaGVldGFoIiwiT1NYUHVtYSIsIk9TWEphZ3VhciIsIk9TWFBhbnRoZXIiLCJPU1hUaWdlciIsIk9TWExlb3BhcmQiLCJPU1hTbm93TGVvcGFyZCIsIk9TWExpb24iLCJPU1hNb3VudGFpbkxpb24iLCJPU1hNYXZlcmlja3MiLCJPU1hZb3NlbWl0ZSIsIk9TWEVsQ2FwaXRhbiIsIk9TWFNpZXJyYSIsIk1hYyIsIkxpbnV4IiwiTGludXg2NCIsIkNocm9tZU9TIiwiV2lpIiwiaVBhZCIsImlQaG9uZSIsIkJhZGEiLCJDdXJsIiwiX1BsYXRmb3JtIiwiV2luZG93cyIsIldpbmRvd3NQaG9uZSIsIlBsYXlzdGF0aW9uIiwiaVBvZCIsIkFuZHJvaWQiLCJCbGFja2JlcnJ5IiwiU2Ftc3VuZyIsIkRlZmF1bHRBZ2VudCIsImlzQmFkYSIsImlzQm90IiwiaXNDdXJsIiwiaXNBbmRyb2lkVGFibGV0IiwiaXNXaW5KcyIsImlzU2lsayIsImlzQ2FwdGl2ZSIsImlzVUMiLCJicm93c2VyIiwiZ2VvSXAiLCJoYXNoSW50Iiwic3RyaW5nIiwiaGFzaCIsImhhc2hNRDUiLCJyb3RhdGVMZWZ0IiwibFZhbHVlIiwiaVNoaWZ0Qml0cyIsImFkZFVuc2lnbmVkIiwibFgiLCJsWSIsImxYNCIsImxZNCIsImxYOCIsImxZOCIsImxSZXN1bHQiLCJnRkYiLCJhYyIsInoiLCJnRiIsImdHRyIsImdHIiwiZ0hIIiwiZ0giLCJnSUkiLCJnSSIsIndvcmRUb0hleCIsImxDb3VudCIsIndvcmRUb0hleFZhbHVlIiwid29yZFRvSGV4VmFsdWVUZW1wIiwiQUEiLCJCQiIsIkNDIiwiREQiLCJsV29yZENvdW50IiwibE1lc3NhZ2VMZW5ndGgiLCJsTnVtYmVyT2ZXb3Jkc1RlbXAxIiwibE51bWJlck9mV29yZHMiLCJsV29yZEFycmF5IiwibEJ5dGVQb3NpdGlvbiIsImxCeXRlQ291bnQiLCJjb252ZXJ0VG9Xb3JkQXJyYXkiLCJ1dGZ0ZXh0IiwiZnJvbUNoYXJDb2RlIiwidXRmOEVuY29kZSIsInRvTG93ZXJDYXNlIiwiQWdlbnQiLCJnZXRCcm93c2VyIiwiJDEiLCJnZXRCcm93c2VyVmVyc2lvbiIsIiQyIiwiZ2V0T1MiLCJnZXRQbGF0Zm9ybSIsImlzV2luZG93c1Bob25lIiwiaXNpU2Ftc3VuZyIsInRlc3RDb21wYXRpYmlsaXR5TW9kZSIsInVhIiwidHJpZGVudFZlcnNpb24iLCJ0ZXN0U2lsayIsIlNpbGtBY2NlbGVyYXRlZCIsInRlc3RLaW5kbGVGaXJlIiwidGVzdENhcHRpdmVOZXR3b3JrIiwidGVzdE1vYmlsZSIsInRlc3RUYWJsZXQiLCJ0ZXN0TmdpbnhHZW9JUCIsInRlc3RCb3QiLCJ0ZXN0U21hcnRUViIsInRlc3RBbmRyb2lkVGFibGV0IiwidGVzdFRvdWNoU3VwcG9ydCIsIm1heFRvdWNoUG9pbnRzIiwibXNNYXhUb3VjaFBvaW50cyIsImdldExhZ3VhZ2UiLCJ1c2VyTGFuZ3VhZ2UiLCJicm93c2VyTGFuZ3VhZ2UiLCJzeXN0ZW1MYW5ndWFnZSIsImdldENvbG9yRGVwdGgiLCJzY3JlZW4iLCJnZXRTY3JlZW5SZXNvbHV0aW9uIiwiYXZhaWxXaWR0aCIsImF2YWlsSGVpZ2h0IiwiZ2V0UGl4ZWxEZXB0aCIsImdldENQVSIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJjdXN0b21EYXRhIiwiZHUiLCJkdWEiLCJ0bXBVdWlkIiwiZGV2aWNlSW5mb1V1aWQiLCJtYWNoaW5lIiwibWFjaGluZVV1aWRLZXkiLCJEYXRlIiwiZ2V0VGltZSIsImxvZ2luQ2hhdGJvdCIsImNoYW5uZWxUb2tlbiIsImFwaUtleSIsIm1hY2hpbmVVdWlkIiwiQXV0aCIsIkNoYXRib3QiLCJjaGF0Ym90VXNlciIsIndoaXNwZXIiLCJsb2ciLCJLZXkxIiwiS2V5MiIsInJlcyIsInJlaiIsInN1Y2Nlc3MiLCJQb3N0TWVzc2FnZSIsInNlbmQiLCJjb2dudXNFdmVudCIsInJlY2lldmUiLCJleHRlbmRBbmRLZWVwU3RydWN0dXJlIiwibW9kZWwiLCJ1cGRhdGVkTW9kZWwiLCJNb2RlbCIsImlmcmFtZVNldHVwQ2xpZW50IiwiaWZyYW1lU2V0dXBVc2VyIiwiaWZyYW1lU2V0TW9kdWxlQnlJZCIsImluc3RhbmNpYXRlZCIsIklmcmFtZSIsImlmcmFtZVNldHVwIiwic3R5bGVzIiwiYWxsb3ciLCJxdWVyeVNlbGVjdG9yIiwic2hhZG93Um9vdCIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsIiRpZnJhbWUiLCJURU1QTEFURSIsImlubmVySFRNTCIsImV4dGVuZENvbmZpZ3VyYXRpb24iLCJDT05GSUciLCJ0aW1lIiwiZGVsYXkiLCJmYWRlSW4iLCIkZWwiLCJvcGFjaXR5IiwiV2Via2l0VHJhbnNpdGlvbiIsIk1velRyYW5zaXRpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmYWRlT3V0IiwiZXZlbnRMaXN0ZW5lckVsZW1lbnRzIiwiYWN0aW9uIiwiQU5JTUFUSU9OUyIsIkNvZ251c0NoYXRib3RCdXR0b24iLCJpc0xvY2tlZCIsImlzQ2hhdGJvdFdpbmRvd09wZW4iLCJpc0J1dHRvblByZXNzZWQiLCJfc2hhZG93Um9vdCIsImF0dGFjaFNoYWRvdyIsImNvbnRlbnQiLCJjbG9uZU5vZGUiLCJoYW5kbGVDbGljayIsInN0YXJ0QnV0dG9uUHJlc3MiLCJlbmRCdXR0b25QcmVzcyIsIiRjb250YWluZXIiLCJnZXRFbGVtZW50QnlJZCIsIiRidXR0b24iLCIkaWNvbkNsb3NlIiwiJGljb25PcGVuIiwiYWRkRXZlbnRMaXN0ZW5lcnMiLCJjbG9zZUNoYXRib3RXaW5kb3ciLCJvcGVuQ2hhdGJvdFdpbmRvdyIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJIVE1MRWxlbWVudCIsImN1c3RvbUVsZW1lbnRzIiwiaUZyYW1lIiwicHJvamVjdCIsImFtTW9kdWxlIiwiZXZlbnRzIiwic2V0dXAiLCJyZWplY3Rpb24iLCJyZW5kZXIiLCJDaGF0Ym90VXNlck1vZGVsIiwiYXZhdGFyIiwic2V0Q2hhdGJvdFVzZXJOYW1lIiwidXNlcm5hbWUiLCJ1c2VyX3NldHRpbmdzIiwic2V0Q2hhdGJvdFVzZXJBdmF0YXIiLCJDYlVzZXIiLCJyb2xsYmFjayIsIl9idWlsZFF1ZXJ5U3RyaW5nIiwidXJsU3RyIiwiYW1fdXNlciIsImdldFNlc3Npb24iLCJnZXRPckNyZWF0ZUNoYXRib3RTZXNzaW9uIiwic2Vzc2lvbiIsInNlbmRUZXh0Iiwic2VuZFZvaWNlIiwic2VuZFBvc3RCYWNrIiwic2VuZFN0YXJ0Q29udmVyc2F0aW9uIiwiU3RhdGVLZXkiLCJDb21tdW5pY2F0aW9uIiwiX3Jlc3BvbnNlIiwic3lzdGVtIiwiY29udmVyc2F0aW9uIiwiY29udmVyc2F0aW9uQmVmb3JlIiwic2VuZFJlc2V0IiwiZmFpbGVkIiwicmVwbHkiLCJTZXNzaW9uIiwicHJvamVjdElkIiwiaXNPcGVuIiwicGFyYW1ldGVycyIsImF1ZGlvIiwiYXR0cmlidXRlcyIsInJlbGF0aW9uc2hpcHMiLCJjb252ZXJzYXRpb25PYmplY3QiLCJuX2ludGVyYWN0aW9ucyIsImlucHV0cyIsIm91dHB1dCIsIm91dHB1dHMiLCJTZXNzaW9uTW9kZWwiLCJjcmVhdGVTZXNzaW9uIiwiQ2JNb2R1bGUiLCJjaGFubmVscyIsImJvdCIsImFtX2NoYW5uZWxfdG9rZW5zIiwiaW50ZW50cyIsImNiVXNlciIsImdldENoYW5uZWwiLCJnZXRJbnRlbnQiLCJBcGkiLCJkaXIiLCJfY2hhdGJvdFVzZXIiLCJnZXRDb252ZXJzYXRpb24iLCJnZXRNZXRhIiwiY2hhbm5lbFRva2VuSWQiLCJnZXRDaGFubmVsVG9rZW4iLCJhbV9jaGFubmVsIiwiYW1faW50ZW50cyIsImludGVudCIsImFtX3VzZXJzIiwic2V0TWV0YVVzZXIiXSwibWFwcGluZ3MiOiJDQUFBLFNBQTJDQSxFQUFNQyxHQUMxQixpQkFBWkMsU0FBMEMsaUJBQVhDLE9BQ3hDQSxPQUFPRCxRQUFVRCxJQUNRLG1CQUFYRyxRQUF5QkEsT0FBT0MsSUFDOUNELE9BQU8sZ0JBQWlCLEdBQUlILEdBQ0YsaUJBQVpDLFFBQ2RBLFFBQXVCLGNBQUlELElBRTNCRCxFQUFvQixjQUFJQyxJQVIxQixDQVNHSyxRQUFRLFdBQ1gsTyxZQ1RBLFNB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QVNzQyxjQUFjVyxrQkFBa0J2eEMsS0FBSy9OLEdBQUdtbEIsRyxTQUV4Qjg2QixHQUFnQkQsRUFBZ0JoakQsS0FBSzBwQyxNLGNBQTFEOFEsRSxnQkFDZ0JpSSxHQUNwQmpJLEVBQWFtSCxjQUFjdUIsV0FBV255QyxLQUFLb1gsSSxPQUdaLGdCQUozQnpXLEUsUUFJTWd3QyxXQUFXaFcsUUFDckIsR0FBQTFyQyxLQUFBLFFBQWVvRixLQUFLc00sRUFBUWd3QyxZQUM1QjFoRCxLQUFLK3BDLE1BQU1ocEMsSUFDVGsrQixFQUFjb0MsT0FBT3FCLGNBQ3JCOFgsRUFBYWtILFdBQVduYixRLFFBZDVCdmpDLEksdUJBa0JGaEQsS0FBSytwQyxNQUFNaHBDLElBQUlrK0IsRUFBY29DLE9BQU9FLGVBQXBDLEdBQW9EdmhDLEtBQXBELFMsd09BTWlCcS9DLEcsK0dBR0lxRCxHQUNuQnJELEVBQVNzQyxjQUFjd0IsV0FBV3B5QyxLQUFLb1gsR0FDdkNub0IsS0FBSzBwQyxNLGNBRkQwWixFLE9BSU5wakQsS0FBSytwQyxNQUFNaHBDLElBQUlrK0IsRUFBY29DLE9BQU9HLGFBQWM0aEIsR0FDbEQsR0FBQXBqRCxLQUFBLFFBQWVvakQsRSxrQkFDUkEsRyxzVUFRbUI5WSxLLE9BQXBCdVEsRSxPQUVOLElBQ0U3NkMsS0FBSytwQyxNQUFNaHBDLElBQ1RrK0IsRUFBY29DLE9BQU9XLGlCQUNyQjZZLEVBQVksR0FBRzhHLGNBQWMwQixTQUFTdHlDLEtBQUtvWCxJQUU3QyxHQUFBbm9CLEtBQUEsUUFBb0JzakQsWUFBWXpJLEVBQVksR0FBRzZHLFlBQy9DLE1BQU85WixHQUNQLEdBQUE1bkMsS0FBQSxRQUFvQnNqRCxZQUFZNUQsTSx5QkFJM0I3RSxHLHlKQTRFRThILE1DM01mLDZFQVNPLElBQU0xRyxHQUFTOXhCLEdBQ1R3NEIsR0FBTTVlIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJDb2dudXNDaGF0Ym90XCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkNvZ251c0NoYXRib3RcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQ29nbnVzQ2hhdGJvdFwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwNyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgJHRvU3RyaW5nID0gcmVxdWlyZSgnLi9fZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwiLyohXG4gICAgbG9jYWxGb3JhZ2UgLS0gT2ZmbGluZSBTdG9yYWdlLCBJbXByb3ZlZFxuICAgIFZlcnNpb24gMS43LjNcbiAgICBodHRwczovL2xvY2FsZm9yYWdlLmdpdGh1Yi5pby9sb2NhbEZvcmFnZVxuICAgIChjKSAyMDEzLTIwMTcgTW96aWxsYSwgQXBhY2hlIExpY2Vuc2UgMi4wXG4qL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcubG9jYWxmb3JhZ2UgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgKGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIiwgZil9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSBfZGVyZXFfKDEpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxuXG52YXIgaGFuZGxlcnMgPSB7fTtcblxudmFyIFJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xudmFyIEZVTEZJTExFRCA9IFsnRlVMRklMTEVEJ107XG52YXIgUEVORElORyA9IFsnUEVORElORyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbn0se1wiMVwiOjF9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcbmlmICh0eXBlb2YgZ2xvYmFsLlByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgZ2xvYmFsLlByb21pc2UgPSBfZGVyZXFfKDIpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiMlwiOjJ9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBnZXRJREIoKSB7XG4gICAgLyogZ2xvYmFsIGluZGV4ZWREQix3ZWJraXRJbmRleGVkREIsbW96SW5kZXhlZERCLE9JbmRleGVkREIsbXNJbmRleGVkREIgKi9cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleGVkREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3ZWJraXRJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Via2l0SW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbW96SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1vekluZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIE9JbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gT0luZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1zSW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1zSW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG52YXIgaWRiID0gZ2V0SURCKCk7XG5cbmZ1bmN0aW9uIGlzSW5kZXhlZERCVmFsaWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBJbmRleGVkREI7IGZhbGwgYmFjayB0byB2ZW5kb3ItcHJlZml4ZWQgdmVyc2lvbnNcbiAgICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIWlkYikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG1pbWljIFBvdWNoREIgaGVyZTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgdGVzdCBmb3Igb3BlbkRhdGFiYXNlIGJlY2F1c2UgSUUgTW9iaWxlIGlkZW50aWZpZXMgaXRzZWxmXG4gICAgICAgIC8vIGFzIFNhZmFyaS4gT2ggdGhlIGx1bHouLi5cbiAgICAgICAgdmFyIGlzU2FmYXJpID0gdHlwZW9mIG9wZW5EYXRhYmFzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgLyhTYWZhcml8aVBob25lfGlQYWR8aVBvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9DaHJvbWUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9CbGFja0JlcnJ5Ly50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5cbiAgICAgICAgdmFyIGhhc0ZldGNoID0gdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nICYmIGZldGNoLnRvU3RyaW5nKCkuaW5kZXhPZignW25hdGl2ZSBjb2RlJykgIT09IC0xO1xuXG4gICAgICAgIC8vIFNhZmFyaSA8MTAuMSBkb2VzIG5vdCBtZWV0IG91ciByZXF1aXJlbWVudHMgZm9yIElEQiBzdXBwb3J0ICgjNTU3MilcbiAgICAgICAgLy8gc2luY2UgU2FmYXJpIDEwLjEgc2hpcHBlZCB3aXRoIGZldGNoLCB3ZSBjYW4gdXNlIHRoYXQgdG8gZGV0ZWN0IGl0XG4gICAgICAgIHJldHVybiAoIWlzU2FmYXJpIHx8IGhhc0ZldGNoKSAmJiB0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBzb21lIG91dGRhdGVkIGltcGxlbWVudGF0aW9ucyBvZiBJREIgdGhhdCBhcHBlYXIgb24gU2Ftc3VuZ1xuICAgICAgICAvLyBhbmQgSFRDIEFuZHJvaWQgZGV2aWNlcyA8NC40IGFyZSBtaXNzaW5nIElEQktleVJhbmdlXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvaXNzdWVzLzEyOFxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL2lzc3Vlcy8yNzJcbiAgICAgICAgdHlwZW9mIElEQktleVJhbmdlICE9PSAndW5kZWZpbmVkJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIEFic3RyYWN0cyBjb25zdHJ1Y3RpbmcgYSBCbG9iIG9iamVjdCwgc28gaXQgYWxzbyB3b3JrcyBpbiBvbGRlclxuLy8gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBuYXRpdmUgQmxvYiBjb25zdHJ1Y3Rvci4gKGkuZS5cbi8vIG9sZCBRdFdlYktpdCB2ZXJzaW9ucywgYXQgbGVhc3QpLlxuLy8gQWJzdHJhY3RzIGNvbnN0cnVjdGluZyBhIEJsb2Igb2JqZWN0LCBzbyBpdCBhbHNvIHdvcmtzIGluIG9sZGVyXG4vLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBCbG9iIGNvbnN0cnVjdG9yLiAoaS5lLlxuLy8gb2xkIFF0V2ViS2l0IHZlcnNpb25zLCBhdCBsZWFzdCkuXG5mdW5jdGlvbiBjcmVhdGVCbG9iKHBhcnRzLCBwcm9wZXJ0aWVzKSB7XG4gICAgLyogZ2xvYmFsIEJsb2JCdWlsZGVyLE1TQmxvYkJ1aWxkZXIsTW96QmxvYkJ1aWxkZXIsV2ViS2l0QmxvYkJ1aWxkZXIgKi9cbiAgICBwYXJ0cyA9IHBhcnRzIHx8IFtdO1xuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvYihwYXJ0cywgcHJvcGVydGllcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQnVpbGRlciA9IHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iQnVpbGRlciA6IHR5cGVvZiBNU0Jsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1TQmxvYkJ1aWxkZXIgOiB0eXBlb2YgTW96QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTW96QmxvYkJ1aWxkZXIgOiBXZWJLaXRCbG9iQnVpbGRlcjtcbiAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0QmxvYihwcm9wZXJ0aWVzLnR5cGUpO1xuICAgIH1cbn1cblxuLy8gVGhpcyBpcyBDb21tb25KUyBiZWNhdXNlIGxpZSBpcyBhbiBleHRlcm5hbCBkZXBlbmRlbmN5LCBzbyBSb2xsdXBcbi8vIGNhbiBqdXN0IGlnbm9yZSBpdC5cbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBJbiB0aGUgXCJub3Byb21pc2VzXCIgYnVpbGQgdGhpcyB3aWxsIGp1c3QgdGhyb3cgaWYgeW91IGRvbid0IGhhdmVcbiAgICAvLyBhIGdsb2JhbCBwcm9taXNlIG9iamVjdCwgYnV0IGl0IHdvdWxkIHRocm93IGFueXdheSBsYXRlci5cbiAgICBfZGVyZXFfKDMpO1xufVxudmFyIFByb21pc2UkMSA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZVtcImNhdGNoXCJdKGVycm9yQ2FsbGJhY2spO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIC8vIENhc3QgdGhlIGtleSB0byBhIHN0cmluZywgYXMgdGhhdCdzIGFsbCB3ZSBjYW4gc2V0IGFzIGEga2V5LlxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlLndhcm4oa2V5ICsgJyB1c2VkIGFzIGEga2V5LCBidXQgaXQgaXMgbm90IGEgc3RyaW5nLicpO1xuICAgICAgICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBnZXRDYWxsYmFjaygpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG59XG5cbi8vIFNvbWUgY29kZSBvcmlnaW5hbGx5IGZyb20gYXN5bmNfc3RvcmFnZS5qcyBpblxuLy8gW0dhaWFdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhLWIyZy9nYWlhKS5cblxudmFyIERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUgPSAnbG9jYWwtZm9yYWdlLWRldGVjdC1ibG9iLXN1cHBvcnQnO1xudmFyIHN1cHBvcnRzQmxvYnMgPSB2b2lkIDA7XG52YXIgZGJDb250ZXh0cyA9IHt9O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gVHJhbnNhY3Rpb24gTW9kZXNcbnZhciBSRUFEX09OTFkgPSAncmVhZG9ubHknO1xudmFyIFJFQURfV1JJVEUgPSAncmVhZHdyaXRlJztcblxuLy8gVHJhbnNmb3JtIGEgYmluYXJ5IHN0cmluZyB0byBhbiBhcnJheSBidWZmZXIsIGJlY2F1c2Ugb3RoZXJ3aXNlXG4vLyB3ZWlyZCBzdHVmZiBoYXBwZW5zIHdoZW4geW91IHRyeSB0byB3b3JrIHdpdGggdGhlIGJpbmFyeSBzdHJpbmcgZGlyZWN0bHkuXG4vLyBJdCBpcyBrbm93bi5cbi8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDk2NzY0Ny8gKGNvbnRpbnVlcyBvbiBuZXh0IGxpbmUpXG4vLyBlbmNvZGUtZGVjb2RlLWltYWdlLXdpdGgtYmFzZTY0LWJyZWFrcy1pbWFnZSAoMjAxMy0wNC0yMSlcbmZ1bmN0aW9uIF9iaW5TdHJpbmdUb0FycmF5QnVmZmVyKGJpbikge1xuICAgIHZhciBsZW5ndGggPSBiaW4ubGVuZ3RoO1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuXG4vL1xuLy8gQmxvYnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIHZlcnNpb25zIG9mIEluZGV4ZWREQiwgbm90YWJseVxuLy8gQ2hyb21lIDwzNyBhbmQgQW5kcm9pZCA8NS4gSW4gdGhvc2UgdmVyc2lvbnMsIHN0b3JpbmcgYSBibG9iIHdpbGwgdGhyb3cuXG4vL1xuLy8gVmFyaW91cyBvdGhlciBibG9iIGJ1Z3MgZXhpc3QgaW4gQ2hyb21lIHYzNy00MiAoaW5jbHVzaXZlKS5cbi8vIERldGVjdGluZyB0aGVtIGlzIGV4cGVuc2l2ZSBhbmQgY29uZnVzaW5nIHRvIHVzZXJzLCBhbmQgQ2hyb21lIDM3LTQyXG4vLyBpcyBhdCB2ZXJ5IGxvdyB1c2FnZSB3b3JsZHdpZGUsIHNvIHdlIGRvIGEgaGFja3kgdXNlckFnZW50IGNoZWNrIGluc3RlYWQuXG4vL1xuLy8gY29udGVudC10eXBlIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQwODEyMFxuLy8gNDA0IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzkxNlxuLy8gRmlsZVJlYWRlciBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc4MzZcbi8vXG4vLyBDb2RlIGJvcnJvd2VkIGZyb20gUG91Y2hEQi4gU2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvdWNoZGIvcG91Y2hkYi9ibG9iL21hc3Rlci9wYWNrYWdlcy9ub2RlX21vZHVsZXMvcG91Y2hkYi1hZGFwdGVyLWlkYi9zcmMvYmxvYlN1cHBvcnQuanNcbi8vXG5mdW5jdGlvbiBfY2hlY2tCbG9iU3VwcG9ydFdpdGhvdXRDYWNoaW5nKGlkYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciB0eG4gPSBpZGIudHJhbnNhY3Rpb24oREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSwgUkVBRF9XUklURSk7XG4gICAgICAgIHZhciBibG9iID0gY3JlYXRlQmxvYihbJyddKTtcbiAgICAgICAgdHhuLm9iamVjdFN0b3JlKERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUpLnB1dChibG9iLCAna2V5Jyk7XG5cbiAgICAgICAgdHhuLm9uYWJvcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGFib3J0cyBub3cgaXRzIGR1ZSB0byBub3QgYmVpbmcgYWJsZSB0b1xuICAgICAgICAgICAgLy8gd3JpdGUgdG8gdGhlIGRhdGFiYXNlLCBsaWtlbHkgZHVlIHRvIHRoZSBkaXNrIGJlaW5nIGZ1bGxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkQ2hyb21lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZEVkZ2UgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvLyk7XG4gICAgICAgICAgICAvLyBNUyBFZGdlIHByZXRlbmRzIHRvIGJlIENocm9tZSA0MjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4NjkzMDElMjh2PXZzLjg1JTI5LmFzcHhcbiAgICAgICAgICAgIHJlc29sdmUobWF0Y2hlZEVkZ2UgfHwgIW1hdGNoZWRDaHJvbWUgfHwgcGFyc2VJbnQobWF0Y2hlZENocm9tZVsxXSwgMTApID49IDQzKTtcbiAgICAgICAgfTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBlcnJvciwgc28gYXNzdW1lIHVuc3VwcG9ydGVkXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9jaGVja0Jsb2JTdXBwb3J0KGlkYikge1xuICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNCbG9icyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZShzdXBwb3J0c0Jsb2JzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jaGVja0Jsb2JTdXBwb3J0V2l0aG91dENhY2hpbmcoaWRiKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzdXBwb3J0c0Jsb2JzID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBzdXBwb3J0c0Jsb2JzO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZGVmZXJSZWFkaW5lc3MoZGJJbmZvKSB7XG4gICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdO1xuXG4gICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBkYXRhYmFzZSBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0ge307XG5cbiAgICBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRlZmVycmVkT3BlcmF0aW9uLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICAvLyBFbnF1ZXVlIHRoZSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wdXNoKGRlZmVycmVkT3BlcmF0aW9uKTtcblxuICAgIC8vIENoYWluIGl0cyBwcm9taXNlIHRvIHRoZSBkYXRhYmFzZSByZWFkaW5lc3MuXG4gICAgaWYgKCFkYkNvbnRleHQuZGJSZWFkeSkge1xuICAgICAgICBkYkNvbnRleHQuZGJSZWFkeSA9IGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGJDb250ZXh0LmRiUmVhZHkgPSBkYkNvbnRleHQuZGJSZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9hZHZhbmNlUmVhZGluZXNzKGRiSW5mbykge1xuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcblxuICAgIC8vIERlcXVldWUgYSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0gZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wb3AoKTtcblxuICAgIC8vIFJlc29sdmUgaXRzIHByb21pc2UgKHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRhdGFiYXNlIHJlYWRpbmVzc1xuICAgIC8vIGNoYWluIG9mIHByb21pc2VzKS5cbiAgICBpZiAoZGVmZXJyZWRPcGVyYXRpb24pIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWRPcGVyYXRpb24ucHJvbWlzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9yZWplY3RSZWFkaW5lc3MoZGJJbmZvLCBlcnIpIHtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyBEZXF1ZXVlIGEgZGVmZXJyZWQgb3BlcmF0aW9uLlxuICAgIHZhciBkZWZlcnJlZE9wZXJhdGlvbiA9IGRiQ29udGV4dC5kZWZlcnJlZE9wZXJhdGlvbnMucG9wKCk7XG5cbiAgICAvLyBSZWplY3QgaXRzIHByb21pc2UgKHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRhdGFiYXNlIHJlYWRpbmVzc1xuICAgIC8vIGNoYWluIG9mIHByb21pc2VzKS5cbiAgICBpZiAoZGVmZXJyZWRPcGVyYXRpb24pIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2dldENvbm5lY3Rpb24oZGJJbmZvLCB1cGdyYWRlTmVlZGVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBkYkNvbnRleHRzW2RiSW5mby5uYW1lXSA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdIHx8IGNyZWF0ZURiQ29udGV4dCgpO1xuXG4gICAgICAgIGlmIChkYkluZm8uZGIpIHtcbiAgICAgICAgICAgIGlmICh1cGdyYWRlTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKGRiSW5mbyk7XG4gICAgICAgICAgICAgICAgZGJJbmZvLmRiLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRiSW5mby5kYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGJBcmdzID0gW2RiSW5mby5uYW1lXTtcblxuICAgICAgICBpZiAodXBncmFkZU5lZWRlZCkge1xuICAgICAgICAgICAgZGJBcmdzLnB1c2goZGJJbmZvLnZlcnNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wZW5yZXEgPSBpZGIub3Blbi5hcHBseShpZGIsIGRiQXJncyk7XG5cbiAgICAgICAgaWYgKHVwZ3JhZGVOZWVkZWQpIHtcbiAgICAgICAgICAgIG9wZW5yZXEub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGIgPSBvcGVucmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShkYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub2xkVmVyc2lvbiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGRlZCB3aGVuIHN1cHBvcnQgZm9yIGJsb2Igc2hpbXMgd2FzIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSAnQ29uc3RyYWludEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZGF0YWJhc2UgXCInICsgZGJJbmZvLm5hbWUgKyAnXCInICsgJyBoYXMgYmVlbiB1cGdyYWRlZCBmcm9tIHZlcnNpb24gJyArIGUub2xkVmVyc2lvbiArICcgdG8gdmVyc2lvbiAnICsgZS5uZXdWZXJzaW9uICsgJywgYnV0IHRoZSBzdG9yYWdlIFwiJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBvcGVucmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVqZWN0KG9wZW5yZXEuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wZW5yZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShvcGVucmVxLnJlc3VsdCk7XG4gICAgICAgICAgICBfYWR2YW5jZVJlYWRpbmVzcyhkYkluZm8pO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZ2V0T3JpZ2luYWxDb25uZWN0aW9uKGRiSW5mbykge1xuICAgIHJldHVybiBfZ2V0Q29ubmVjdGlvbihkYkluZm8sIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gX2dldFVwZ3JhZGVkQ29ubmVjdGlvbihkYkluZm8pIHtcbiAgICByZXR1cm4gX2dldENvbm5lY3Rpb24oZGJJbmZvLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gX2lzVXBncmFkZU5lZWRlZChkYkluZm8sIGRlZmF1bHRWZXJzaW9uKSB7XG4gICAgaWYgKCFkYkluZm8uZGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzTmV3U3RvcmUgPSAhZGJJbmZvLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgdmFyIGlzRG93bmdyYWRlID0gZGJJbmZvLnZlcnNpb24gPCBkYkluZm8uZGIudmVyc2lvbjtcbiAgICB2YXIgaXNVcGdyYWRlID0gZGJJbmZvLnZlcnNpb24gPiBkYkluZm8uZGIudmVyc2lvbjtcblxuICAgIGlmIChpc0Rvd25ncmFkZSkge1xuICAgICAgICAvLyBJZiB0aGUgdmVyc2lvbiBpcyBub3QgdGhlIGRlZmF1bHQgb25lXG4gICAgICAgIC8vIHRoZW4gd2FybiBmb3IgaW1wb3NzaWJsZSBkb3duZ3JhZGUuXG4gICAgICAgIGlmIChkYkluZm8udmVyc2lvbiAhPT0gZGVmYXVsdFZlcnNpb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGRhdGFiYXNlIFwiJyArIGRiSW5mby5uYW1lICsgJ1wiJyArIFwiIGNhbid0IGJlIGRvd25ncmFkZWQgZnJvbSB2ZXJzaW9uIFwiICsgZGJJbmZvLmRiLnZlcnNpb24gKyAnIHRvIHZlcnNpb24gJyArIGRiSW5mby52ZXJzaW9uICsgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGlnbiB0aGUgdmVyc2lvbnMgdG8gcHJldmVudCBlcnJvcnMuXG4gICAgICAgIGRiSW5mby52ZXJzaW9uID0gZGJJbmZvLmRiLnZlcnNpb247XG4gICAgfVxuXG4gICAgaWYgKGlzVXBncmFkZSB8fCBpc05ld1N0b3JlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdG9yZSBpcyBuZXcgdGhlbiBpbmNyZW1lbnQgdGhlIHZlcnNpb24gKGlmIG5lZWRlZCkuXG4gICAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGFuIFwidXBncmFkZW5lZWRlZFwiIGV2ZW50IHdoaWNoIGlzIHJlcXVpcmVkXG4gICAgICAgIC8vIGZvciBjcmVhdGluZyBhIHN0b3JlLlxuICAgICAgICBpZiAoaXNOZXdTdG9yZSkge1xuICAgICAgICAgICAgdmFyIGluY1ZlcnNpb24gPSBkYkluZm8uZGIudmVyc2lvbiArIDE7XG4gICAgICAgICAgICBpZiAoaW5jVmVyc2lvbiA+IGRiSW5mby52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgZGJJbmZvLnZlcnNpb24gPSBpbmNWZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBlbmNvZGUgYSBibG9iIGZvciBpbmRleGVkZGIgZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnQgYmxvYnNcbmZ1bmN0aW9uIF9lbmNvZGVCbG9iKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgYmFzZTY0ID0gYnRvYShlLnRhcmdldC5yZXN1bHQgfHwgJycpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgX19sb2NhbF9mb3JhZ2VfZW5jb2RlZF9ibG9iOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGJhc2U2NCxcbiAgICAgICAgICAgICAgICB0eXBlOiBibG9iLnR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nKGJsb2IpO1xuICAgIH0pO1xufVxuXG4vLyBkZWNvZGUgYW4gZW5jb2RlZCBibG9iXG5mdW5jdGlvbiBfZGVjb2RlQmxvYihlbmNvZGVkQmxvYikge1xuICAgIHZhciBhcnJheUJ1ZmYgPSBfYmluU3RyaW5nVG9BcnJheUJ1ZmZlcihhdG9iKGVuY29kZWRCbG9iLmRhdGEpKTtcbiAgICByZXR1cm4gY3JlYXRlQmxvYihbYXJyYXlCdWZmXSwgeyB0eXBlOiBlbmNvZGVkQmxvYi50eXBlIH0pO1xufVxuXG4vLyBpcyB0aGlzIG9uZSBvZiBvdXIgZmFuY3kgZW5jb2RlZCBibG9icz9cbmZ1bmN0aW9uIF9pc0VuY29kZWRCbG9iKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLl9fbG9jYWxfZm9yYWdlX2VuY29kZWRfYmxvYjtcbn1cblxuLy8gU3BlY2lhbGl6ZSB0aGUgZGVmYXVsdCBgcmVhZHkoKWAgZnVuY3Rpb24gYnkgbWFraW5nIGl0IGRlcGVuZGVudFxuLy8gb24gdGhlIGN1cnJlbnQgZGF0YWJhc2Ugb3BlcmF0aW9ucy4gVGh1cywgdGhlIGRyaXZlciB3aWxsIGJlIGFjdHVhbGx5XG4vLyByZWFkeSB3aGVuIGl0J3MgYmVlbiBpbml0aWFsaXplZCAoZGVmYXVsdCkgKmFuZCogdGhlcmUgYXJlIG5vIHBlbmRpbmdcbi8vIG9wZXJhdGlvbnMgb24gdGhlIGRhdGFiYXNlIChpbml0aWF0ZWQgYnkgc29tZSBvdGhlciBpbnN0YW5jZXMpLlxuZnVuY3Rpb24gX2Z1bGx5UmVhZHkoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYuX2luaXRSZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tzZWxmLl9kYkluZm8ubmFtZV07XG5cbiAgICAgICAgaWYgKGRiQ29udGV4dCAmJiBkYkNvbnRleHQuZGJSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuIGRiQ29udGV4dC5kYlJlYWR5O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHByb21pc2UsIGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFRyeSB0byBlc3RhYmxpc2ggYSBuZXcgZGIgY29ubmVjdGlvbiB0byByZXBsYWNlIHRoZVxuLy8gY3VycmVudCBvbmUgd2hpY2ggaXMgYnJva2VuIChpLmUuIGV4cGVyaWVuY2luZ1xuLy8gSW52YWxpZFN0YXRlRXJyb3Igd2hpbGUgY3JlYXRpbmcgYSB0cmFuc2FjdGlvbikuXG5mdW5jdGlvbiBfdHJ5UmVjb25uZWN0KGRiSW5mbykge1xuICAgIF9kZWZlclJlYWRpbmVzcyhkYkluZm8pO1xuXG4gICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdO1xuICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgIGlmIChmb3JhZ2UuX2RiSW5mby5kYikge1xuICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkYkluZm8uZGIgPSBudWxsO1xuXG4gICAgcmV0dXJuIF9nZXRPcmlnaW5hbENvbm5lY3Rpb24oZGJJbmZvKS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICBkYkluZm8uZGIgPSBkYjtcbiAgICAgICAgaWYgKF9pc1VwZ3JhZGVOZWVkZWQoZGJJbmZvKSkge1xuICAgICAgICAgICAgLy8gUmVvcGVuIHRoZSBkYXRhYmFzZSBmb3IgdXBncmFkaW5nLlxuICAgICAgICAgICAgcmV0dXJuIF9nZXRVcGdyYWRlZENvbm5lY3Rpb24oZGJJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGI7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgLy8gc3RvcmUgdGhlIGxhdGVzdCBkYiByZWZlcmVuY2VcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgZGIgd2FzIHVwZ3JhZGVkXG4gICAgICAgIGRiSW5mby5kYiA9IGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvcmFnZXNbaV0uX2RiSW5mby5kYiA9IGRiO1xuICAgICAgICB9XG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF9yZWplY3RSZWFkaW5lc3MoZGJJbmZvLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG59XG5cbi8vIEZGIGRvZXNuJ3QgbGlrZSBQcm9taXNlcyAobWljcm8tdGFza3MpIGFuZCBJRERCIHN0b3JlIG9wZXJhdGlvbnMsXG4vLyBzbyB3ZSBoYXZlIHRvIGRvIGl0IHdpdGggY2FsbGJhY2tzXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbihkYkluZm8sIG1vZGUsIGNhbGxiYWNrLCByZXRyaWVzKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXRyaWVzID0gMTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICB2YXIgdHggPSBkYkluZm8uZGIudHJhbnNhY3Rpb24oZGJJbmZvLnN0b3JlTmFtZSwgbW9kZSk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHR4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHJldHJpZXMgPiAwICYmICghZGJJbmZvLmRiIHx8IGVyci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InIHx8IGVyci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZSQxLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRiSW5mby5kYiB8fCBlcnIubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InICYmICFkYkluZm8uZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhkYkluZm8uc3RvcmVOYW1lKSAmJiBkYkluZm8udmVyc2lvbiA8PSBkYkluZm8uZGIudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgZGIgdmVyc2lvbiwgdG8gY3JlYXRlIHRoZSBuZXcgT2JqZWN0U3RvcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRiSW5mby5kYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGJJbmZvLnZlcnNpb24gPSBkYkluZm8uZGIudmVyc2lvbiArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVvcGVuIHRoZSBkYXRhYmFzZSBmb3IgdXBncmFkaW5nLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2dldFVwZ3JhZGVkQ29ubmVjdGlvbihkYkluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdHJ5UmVjb25uZWN0KGRiSW5mbykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKGRiSW5mbywgbW9kZSwgY2FsbGJhY2ssIHJldHJpZXMgLSAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURiQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBSdW5uaW5nIGxvY2FsRm9yYWdlcyBzaGFyaW5nIGEgZGF0YWJhc2UuXG4gICAgICAgIGZvcmFnZXM6IFtdLFxuICAgICAgICAvLyBTaGFyZWQgZGF0YWJhc2UuXG4gICAgICAgIGRiOiBudWxsLFxuICAgICAgICAvLyBEYXRhYmFzZSByZWFkaW5lc3MgKHByb21pc2UpLlxuICAgICAgICBkYlJlYWR5OiBudWxsLFxuICAgICAgICAvLyBEZWZlcnJlZCBvcGVyYXRpb25zIG9uIHRoZSBkYXRhYmFzZS5cbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb25zOiBbXVxuICAgIH07XG59XG5cbi8vIE9wZW4gdGhlIEluZGV4ZWREQiBkYXRhYmFzZSAoYXV0b21hdGljYWxseSBjcmVhdGVzIG9uZSBpZiBvbmUgZGlkbid0XG4vLyBwcmV2aW91c2x5IGV4aXN0KSwgdXNpbmcgYW55IG9wdGlvbnMgc2V0IGluIHRoZSBjb25maWcuXG5mdW5jdGlvbiBfaW5pdFN0b3JhZ2Uob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGJJbmZvID0ge1xuICAgICAgICBkYjogbnVsbFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRiSW5mb1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgY29udGV4dCBvZiB0aGUgZGF0YWJhc2U7XG4gICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdO1xuXG4gICAgLy8gLi4ub3IgY3JlYXRlIGEgbmV3IGNvbnRleHQuXG4gICAgaWYgKCFkYkNvbnRleHQpIHtcbiAgICAgICAgZGJDb250ZXh0ID0gY3JlYXRlRGJDb250ZXh0KCk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXcgY29udGV4dCBpbiB0aGUgZ2xvYmFsIGNvbnRhaW5lci5cbiAgICAgICAgZGJDb250ZXh0c1tkYkluZm8ubmFtZV0gPSBkYkNvbnRleHQ7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgaXRzZWxmIGFzIGEgcnVubmluZyBsb2NhbEZvcmFnZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgIGRiQ29udGV4dC5mb3JhZ2VzLnB1c2goc2VsZik7XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBkZWZhdWx0IGByZWFkeSgpYCBmdW5jdGlvbiB3aXRoIHRoZSBzcGVjaWFsaXplZCBvbmUuXG4gICAgaWYgKCFzZWxmLl9pbml0UmVhZHkpIHtcbiAgICAgICAgc2VsZi5faW5pdFJlYWR5ID0gc2VsZi5yZWFkeTtcbiAgICAgICAgc2VsZi5yZWFkeSA9IF9mdWxseVJlYWR5O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiBpbml0aWFsaXphdGlvbiBzdGF0ZXMgb2YgdGhlIHJlbGF0ZWQgbG9jYWxGb3JhZ2VzLlxuICAgIHZhciBpbml0UHJvbWlzZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGlnbm9yZUVycm9ycygpIHtcbiAgICAgICAgLy8gRG9uJ3QgaGFuZGxlIGVycm9ycyBoZXJlLFxuICAgICAgICAvLyBqdXN0IG1ha2VzIHN1cmUgcmVsYXRlZCBsb2NhbEZvcmFnZXMgYXJlbid0IHBlbmRpbmcuXG4gICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGJDb250ZXh0LmZvcmFnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGZvcmFnZSA9IGRiQ29udGV4dC5mb3JhZ2VzW2pdO1xuICAgICAgICBpZiAoZm9yYWdlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB3YWl0IGZvciBpdHNlbGYuLi5cbiAgICAgICAgICAgIGluaXRQcm9taXNlcy5wdXNoKGZvcmFnZS5faW5pdFJlYWR5KClbXCJjYXRjaFwiXShpZ25vcmVFcnJvcnMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRha2UgYSBzbmFwc2hvdCBvZiB0aGUgcmVsYXRlZCBsb2NhbEZvcmFnZXMuXG4gICAgdmFyIGZvcmFnZXMgPSBkYkNvbnRleHQuZm9yYWdlcy5zbGljZSgwKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGNvbm5lY3Rpb24gcHJvY2VzcyBvbmx5IHdoZW5cbiAgICAvLyBhbGwgdGhlIHJlbGF0ZWQgbG9jYWxGb3JhZ2VzIGFyZW4ndCBwZW5kaW5nLlxuICAgIHJldHVybiBQcm9taXNlJDEuYWxsKGluaXRQcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiQ29udGV4dC5kYjtcbiAgICAgICAgLy8gR2V0IHRoZSBjb25uZWN0aW9uIG9yIG9wZW4gYSBuZXcgb25lIHdpdGhvdXQgdXBncmFkZS5cbiAgICAgICAgcmV0dXJuIF9nZXRPcmlnaW5hbENvbm5lY3Rpb24oZGJJbmZvKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICBkYkluZm8uZGIgPSBkYjtcbiAgICAgICAgaWYgKF9pc1VwZ3JhZGVOZWVkZWQoZGJJbmZvLCBzZWxmLl9kZWZhdWx0Q29uZmlnLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAvLyBSZW9wZW4gdGhlIGRhdGFiYXNlIGZvciB1cGdyYWRpbmcuXG4gICAgICAgICAgICByZXR1cm4gX2dldFVwZ3JhZGVkQ29ubmVjdGlvbihkYkluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYjtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICBkYkluZm8uZGIgPSBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgc2VsZi5fZGJJbmZvID0gZGJJbmZvO1xuICAgICAgICAvLyBTaGFyZSB0aGUgZmluYWwgY29ubmVjdGlvbiBhbW9uZ3N0IHJlbGF0ZWQgbG9jYWxGb3JhZ2VzLlxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGZvcmFnZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBmb3JhZ2UgPSBmb3JhZ2VzW2tdO1xuICAgICAgICAgICAgaWYgKGZvcmFnZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICAgIC8vIFNlbGYgaXMgYWxyZWFkeSB1cC10by1kYXRlLlxuICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiID0gZGJJbmZvLmRiO1xuICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLnZlcnNpb24gPSBkYkluZm8udmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVtKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9PTkxZLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNFbmNvZGVkQmxvYih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9kZWNvZGVCbG9iKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIEl0ZXJhdGUgb3ZlciBhbGwgaXRlbXMgc3RvcmVkIGluIGRhdGFiYXNlLlxuZnVuY3Rpb24gaXRlcmF0ZShpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbk51bWJlciA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNFbmNvZGVkQmxvYih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZGVjb2RlQmxvYih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvcih2YWx1ZSwgY3Vyc29yLmtleSwgaXRlcmF0aW9uTnVtYmVyKyspO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaXRlcmF0b3IgY2FsbGJhY2sgcmV0dW5zIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChub24tYHVuZGVmaW5lZGApIHZhbHVlLCB0aGVuIHdlIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaXRlcmF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gc2V0SXRlbShrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRiSW5mbztcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBCbG9iXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NoZWNrQmxvYlN1cHBvcnQoZGJJbmZvLmRiKS50aGVuKGZ1bmN0aW9uIChibG9iU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvYlN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VuY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2UgZG9uJ3QgX3NhdmVfIG51bGwgaXMgYmVjYXVzZSBJRSAxMCBkb2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0IHNhdmluZyB0aGUgYG51bGxgIHR5cGUgaW4gSW5kZXhlZERCLiBIb3dcbiAgICAgICAgICAgICAgICAgICAgLy8gaXJvbmljLCBnaXZlbiB0aGUgYnVnIGJlbG93IVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL2lzc3Vlcy8xNjFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5wdXQodmFsdWUsIGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc3QgdG8gdW5kZWZpbmVkIHNvIHRoZSB2YWx1ZSBwYXNzZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrL3Byb21pc2UgaXMgdGhlIHNhbWUgYXMgd2hhdCBvbmUgd291bGQgZ2V0IG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYGdldEl0ZW0oKWAgbGF0ZXIuIFRoaXMgbGVhZHMgdG8gc29tZSB3ZWlyZG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChzZXRJdGVtKCdmb28nLCB1bmRlZmluZWQpIHdpbGwgcmV0dXJuIGBudWxsYCksIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3QgbXkgZmF1bHQgbG9jYWxTdG9yYWdlIGlzIG91ciBiYXNlbGluZSBhbmQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyB3ZWlyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25hYm9ydCA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gcmVxLmVycm9yID8gcmVxLmVycm9yIDogcmVxLnRyYW5zYWN0aW9uLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBHcnVudCB0YXNrIHRvIG1ha2UgdGhpcyBzYWZlIGZvciBJRSBhbmQgc29tZVxuICAgICAgICAgICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBBbmRyb2lkIChpbmNsdWRpbmcgdGhvc2UgdXNlZCBieSBDb3Jkb3ZhKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm9ybWFsbHkgSUUgd29uJ3QgbGlrZSBgLmRlbGV0ZSgpYCBhbmQgd2lsbCBpbnNpc3Qgb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgYFsnZGVsZXRlJ10oKWAsIGJ1dCB3ZSBoYXZlIGEgYnVpbGQgc3RlcCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeGVzIHRoaXMgZm9yIHVzIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IHdpbGwgYmUgYWxzbyBiZSBhYm9ydGVkIGlmIHdlJ3ZlIGV4Y2VlZGVkIG91ciBzdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlLlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlcS5lcnJvciA/IHJlcS5lcnJvciA6IHJlcS50cmFuc2FjdGlvbi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBjbGVhcihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9XUklURSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSByZXEuZXJyb3IgPyByZXEuZXJyb3IgOiByZXEudHJhbnNhY3Rpb24uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5jb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleShuLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZHZhbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbkN1cnNvcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGVyZSB3ZXJlbid0IGVub3VnaCBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRoZSBmaXJzdCBrZXksIHJldHVybiBpdCBpZiB0aGF0J3Mgd2hhdCB0aGV5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWR2YW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc2sgdGhlIGN1cnNvciB0byBza2lwIGFoZWFkIG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3Jkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGdldCBoZXJlLCB3ZSd2ZSBnb3QgdGhlIG50aCBrZXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleXMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gZHJvcEluc3RhbmNlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBjdXJyZW50Q29uZmlnLm5hbWU7XG4gICAgICAgIG9wdGlvbnMuc3RvcmVOYW1lID0gb3B0aW9ucy5zdG9yZU5hbWUgfHwgY3VycmVudENvbmZpZy5zdG9yZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc0N1cnJlbnREYiA9IG9wdGlvbnMubmFtZSA9PT0gY3VycmVudENvbmZpZy5uYW1lICYmIHNlbGYuX2RiSW5mby5kYjtcblxuICAgICAgICB2YXIgZGJQcm9taXNlID0gaXNDdXJyZW50RGIgPyBQcm9taXNlJDEucmVzb2x2ZShzZWxmLl9kYkluZm8uZGIpIDogX2dldE9yaWdpbmFsQ29ubmVjdGlvbihvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG4gICAgICAgICAgICBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvcmFnZXNbaV0uX2RiSW5mby5kYiA9IGRiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gZGJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzO1xuXG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcERCUHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRiLmRlbGV0ZURhdGFiYXNlKG9wdGlvbnMubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZXEub25ibG9ja2VkID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkcm9wREJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hZHZhbmNlUmVhZGluZXNzKF9mb3JhZ2UuX2RiSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9yZWplY3RSZWFkaW5lc3Mob3B0aW9ucywgZXJyKSB8fCBQcm9taXNlJDEucmVzb2x2ZSgpKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gZGJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKG9wdGlvbnMuc3RvcmVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZlcnNpb24gPSBkYi52ZXJzaW9uICsgMTtcblxuICAgICAgICAgICAgICAgIF9kZWZlclJlYWRpbmVzcyhvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW29wdGlvbnMubmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGZvcmFnZXMgPSBkYkNvbnRleHQuZm9yYWdlcztcblxuICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JhZ2UgPSBmb3JhZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLnZlcnNpb24gPSBuZXdWZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkcm9wT2JqZWN0UHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRiLm9wZW4ob3B0aW9ucy5uYW1lLCBuZXdWZXJzaW9uKTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZShvcHRpb25zLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZHJvcE9iamVjdFByb21pc2UudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm9yYWdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9mb3JhZ2UyID0gZm9yYWdlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mb3JhZ2UyLl9kYkluZm8uZGIgPSBkYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hZHZhbmNlUmVhZGluZXNzKF9mb3JhZ2UyLl9kYkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfcmVqZWN0UmVhZGluZXNzKG9wdGlvbnMsIGVycikgfHwgUHJvbWlzZSQxLnJlc29sdmUoKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIGFzeW5jU3RvcmFnZSA9IHtcbiAgICBfZHJpdmVyOiAnYXN5bmNTdG9yYWdlJyxcbiAgICBfaW5pdFN0b3JhZ2U6IF9pbml0U3RvcmFnZSxcbiAgICBfc3VwcG9ydDogaXNJbmRleGVkREJWYWxpZCgpLFxuICAgIGl0ZXJhdGU6IGl0ZXJhdGUsXG4gICAgZ2V0SXRlbTogZ2V0SXRlbSxcbiAgICBzZXRJdGVtOiBzZXRJdGVtLFxuICAgIHJlbW92ZUl0ZW06IHJlbW92ZUl0ZW0sXG4gICAgY2xlYXI6IGNsZWFyLFxuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIGtleToga2V5LFxuICAgIGtleXM6IGtleXMsXG4gICAgZHJvcEluc3RhbmNlOiBkcm9wSW5zdGFuY2Vcbn07XG5cbmZ1bmN0aW9uIGlzV2ViU1FMVmFsaWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvcGVuRGF0YWJhc2UgPT09ICdmdW5jdGlvbic7XG59XG5cbi8vIFNhZGx5LCB0aGUgYmVzdCB3YXkgdG8gc2F2ZSBiaW5hcnkgZGF0YSBpbiBXZWJTUUwvbG9jYWxTdG9yYWdlIGlzIHNlcmlhbGl6aW5nXG4vLyBpdCB0byBCYXNlNjQsIHNvIHRoaXMgaXMgaG93IHdlIHN0b3JlIGl0IHRvIHByZXZlbnQgdmVyeSBzdHJhbmdlIGVycm9ycyB3aXRoIGxlc3Ncbi8vIHZlcmJvc2Ugd2F5cyBvZiBiaW5hcnkgPC0+IHN0cmluZyBkYXRhIHN0b3JhZ2UuXG52YXIgQkFTRV9DSEFSUyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxudmFyIEJMT0JfVFlQRV9QUkVGSVggPSAnfn5sb2NhbF9mb3JhZ2VfdHlwZX4nO1xudmFyIEJMT0JfVFlQRV9QUkVGSVhfUkVHRVggPSAvXn5+bG9jYWxfZm9yYWdlX3R5cGV+KFtefl0rKX4vO1xuXG52YXIgU0VSSUFMSVpFRF9NQVJLRVIgPSAnX19sZnNjX186JztcbnZhciBTRVJJQUxJWkVEX01BUktFUl9MRU5HVEggPSBTRVJJQUxJWkVEX01BUktFUi5sZW5ndGg7XG5cbi8vIE9NRyB0aGUgc2VyaWFsaXphdGlvbnMhXG52YXIgVFlQRV9BUlJBWUJVRkZFUiA9ICdhcmJmJztcbnZhciBUWVBFX0JMT0IgPSAnYmxvYic7XG52YXIgVFlQRV9JTlQ4QVJSQVkgPSAnc2kwOCc7XG52YXIgVFlQRV9VSU5UOEFSUkFZID0gJ3VpMDgnO1xudmFyIFRZUEVfVUlOVDhDTEFNUEVEQVJSQVkgPSAndWljOCc7XG52YXIgVFlQRV9JTlQxNkFSUkFZID0gJ3NpMTYnO1xudmFyIFRZUEVfSU5UMzJBUlJBWSA9ICdzaTMyJztcbnZhciBUWVBFX1VJTlQxNkFSUkFZID0gJ3VyMTYnO1xudmFyIFRZUEVfVUlOVDMyQVJSQVkgPSAndWkzMic7XG52YXIgVFlQRV9GTE9BVDMyQVJSQVkgPSAnZmwzMic7XG52YXIgVFlQRV9GTE9BVDY0QVJSQVkgPSAnZmw2NCc7XG52YXIgVFlQRV9TRVJJQUxJWkVEX01BUktFUl9MRU5HVEggPSBTRVJJQUxJWkVEX01BUktFUl9MRU5HVEggKyBUWVBFX0FSUkFZQlVGRkVSLmxlbmd0aDtcblxudmFyIHRvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J1ZmZlcihzZXJpYWxpemVkU3RyaW5nKSB7XG4gICAgLy8gRmlsbCB0aGUgc3RyaW5nIGludG8gYSBBcnJheUJ1ZmZlci5cbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gc2VyaWFsaXplZFN0cmluZy5sZW5ndGggKiAwLjc1O1xuICAgIHZhciBsZW4gPSBzZXJpYWxpemVkU3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKHNlcmlhbGl6ZWRTdHJpbmdbc2VyaWFsaXplZFN0cmluZy5sZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICBpZiAoc2VyaWFsaXplZFN0cmluZ1tzZXJpYWxpemVkU3RyaW5nLmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpO1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZW5jb2RlZDEgPSBCQVNFX0NIQVJTLmluZGV4T2Yoc2VyaWFsaXplZFN0cmluZ1tpXSk7XG4gICAgICAgIGVuY29kZWQyID0gQkFTRV9DSEFSUy5pbmRleE9mKHNlcmlhbGl6ZWRTdHJpbmdbaSArIDFdKTtcbiAgICAgICAgZW5jb2RlZDMgPSBCQVNFX0NIQVJTLmluZGV4T2Yoc2VyaWFsaXplZFN0cmluZ1tpICsgMl0pO1xuICAgICAgICBlbmNvZGVkNCA9IEJBU0VfQ0hBUlMuaW5kZXhPZihzZXJpYWxpemVkU3RyaW5nW2kgKyAzXSk7XG5cbiAgICAgICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuICAgICAgICBieXRlc1twKytdID0gZW5jb2RlZDEgPDwgMiB8IGVuY29kZWQyID4+IDQ7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDIgJiAxNSkgPDwgNCB8IGVuY29kZWQzID4+IDI7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDMgJiAzKSA8PCA2IHwgZW5jb2RlZDQgJiA2MztcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLy8gQ29udmVydHMgYSBidWZmZXIgdG8gYSBzdHJpbmcgdG8gc3RvcmUsIHNlcmlhbGl6ZWQsIGluIHRoZSBiYWNrZW5kXG4vLyBzdG9yYWdlIGxpYnJhcnkuXG5mdW5jdGlvbiBidWZmZXJUb1N0cmluZyhidWZmZXIpIHtcbiAgICAvLyBiYXNlNjQtYXJyYXlidWZmZXJcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIHZhciBiYXNlNjRTdHJpbmcgPSAnJztcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4gICAgICAgIGJhc2U2NFN0cmluZyArPSBCQVNFX0NIQVJTW2J5dGVzW2ldID4+IDJdO1xuICAgICAgICBiYXNlNjRTdHJpbmcgKz0gQkFTRV9DSEFSU1soYnl0ZXNbaV0gJiAzKSA8PCA0IHwgYnl0ZXNbaSArIDFdID4+IDRdO1xuICAgICAgICBiYXNlNjRTdHJpbmcgKz0gQkFTRV9DSEFSU1soYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpICsgMl0gPj4gNl07XG4gICAgICAgIGJhc2U2NFN0cmluZyArPSBCQVNFX0NIQVJTW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZXMubGVuZ3RoICUgMyA9PT0gMikge1xuICAgICAgICBiYXNlNjRTdHJpbmcgPSBiYXNlNjRTdHJpbmcuc3Vic3RyaW5nKDAsIGJhc2U2NFN0cmluZy5sZW5ndGggLSAxKSArICc9JztcbiAgICB9IGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCAlIDMgPT09IDEpIHtcbiAgICAgICAgYmFzZTY0U3RyaW5nID0gYmFzZTY0U3RyaW5nLnN1YnN0cmluZygwLCBiYXNlNjRTdHJpbmcubGVuZ3RoIC0gMikgKyAnPT0nO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjRTdHJpbmc7XG59XG5cbi8vIFNlcmlhbGl6ZSBhIHZhbHVlLCBhZnRlcndhcmRzIGV4ZWN1dGluZyBhIGNhbGxiYWNrICh3aGljaCB1c3VhbGx5XG4vLyBpbnN0cnVjdHMgdGhlIGBzZXRJdGVtKClgIGNhbGxiYWNrL3Byb21pc2UgdG8gYmUgZXhlY3V0ZWQpLiBUaGlzIGlzIGhvd1xuLy8gd2Ugc3RvcmUgYmluYXJ5IGRhdGEgd2l0aCBsb2NhbFN0b3JhZ2UuXG5mdW5jdGlvbiBzZXJpYWxpemUodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlVHlwZSA9ICcnO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZVR5cGUgPSB0b1N0cmluZyQxLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIENhbm5vdCB1c2UgYHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJgIG9yIHN1Y2ggaGVyZSwgYXMgdGhlc2VcbiAgICAvLyBjaGVja3MgZmFpbCB3aGVuIHJ1bm5pbmcgdGhlIHRlc3RzIHVzaW5nIGNhc3Blci5qcy4uLlxuICAgIC8vXG4gICAgLy8gVE9ETzogU2VlIHdoeSB0aG9zZSB0ZXN0cyBmYWlsIGFuZCB1c2UgYSBiZXR0ZXIgc29sdXRpb24uXG4gICAgaWYgKHZhbHVlICYmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScgfHwgdmFsdWUuYnVmZmVyICYmIHRvU3RyaW5nJDEuY2FsbCh2YWx1ZS5idWZmZXIpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSkge1xuICAgICAgICAvLyBDb252ZXJ0IGJpbmFyeSBhcnJheXMgdG8gYSBzdHJpbmcgYW5kIHByZWZpeCB0aGUgc3RyaW5nIHdpdGhcbiAgICAgICAgLy8gYSBzcGVjaWFsIG1hcmtlci5cbiAgICAgICAgdmFyIGJ1ZmZlcjtcbiAgICAgICAgdmFyIG1hcmtlciA9IFNFUklBTElaRURfTUFSS0VSO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBidWZmZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0FSUkFZQlVGRkVSO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyID0gdmFsdWUuYnVmZmVyO1xuXG4gICAgICAgICAgICBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBJbnQ4QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0lOVDhBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBVaW50OEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9VSU5UOEFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9VSU5UOENMQU1QRURBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBJbnQxNkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9JTlQxNkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IFVpbnQxNkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9VSU5UMTZBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBJbnQzMkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9JTlQzMkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IFVpbnQzMkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9VSU5UMzJBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBGbG9hdDMyQXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0ZMT0FUMzJBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBGbG9hdDY0QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0ZMT0FUNjRBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHR5cGUgZm9yIEJpbmFyeUFycmF5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobWFya2VyICsgYnVmZmVyVG9TdHJpbmcoYnVmZmVyKSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEJsb2JdJykge1xuICAgICAgICAvLyBDb252ZXIgdGhlIGJsb2IgdG8gYSBiaW5hcnlBcnJheSBhbmQgdGhlbiB0byBhIHN0cmluZy5cbiAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdGlibGUgcHJlZml4IGZvciB0aGUgYmxvYiB0eXBlLlxuICAgICAgICAgICAgdmFyIHN0ciA9IEJMT0JfVFlQRV9QUkVGSVggKyB2YWx1ZS50eXBlICsgJ34nICsgYnVmZmVyVG9TdHJpbmcodGhpcy5yZXN1bHQpO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhTRVJJQUxJWkVEX01BUktFUiArIFRZUEVfQkxPQiArIHN0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZG4ndCBjb252ZXJ0IHZhbHVlIGludG8gYSBKU09OIHN0cmluZzogXCIsIHZhbHVlKTtcblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIERlc2VyaWFsaXplIGRhdGEgd2UndmUgaW5zZXJ0ZWQgaW50byBhIHZhbHVlIGNvbHVtbi9maWVsZC4gV2UgcGxhY2Vcbi8vIHNwZWNpYWwgbWFya2VycyBpbnRvIG91ciBzdHJpbmdzIHRvIG1hcmsgdGhlbSBhcyBlbmNvZGVkOyB0aGlzIGlzbid0XG4vLyBhcyBuaWNlIGFzIGEgbWV0YSBmaWVsZCwgYnV0IGl0J3MgdGhlIG9ubHkgc2FuZSB0aGluZyB3ZSBjYW4gZG8gd2hpbHN0XG4vLyBrZWVwaW5nIGxvY2FsU3RvcmFnZSBzdXBwb3J0IGludGFjdC5cbi8vXG4vLyBPZnRlbnRpbWVzIHRoaXMgd2lsbCBqdXN0IGRlc2VyaWFsaXplIEpTT04gY29udGVudCwgYnV0IGlmIHdlIGhhdmUgYVxuLy8gc3BlY2lhbCBtYXJrZXIgKFNFUklBTElaRURfTUFSS0VSLCBkZWZpbmVkIGFib3ZlKSwgd2Ugd2lsbCBleHRyYWN0XG4vLyBzb21lIGtpbmQgb2YgYXJyYXlidWZmZXIvYmluYXJ5IGRhdGEvdHlwZWQgYXJyYXkgb3V0IG9mIHRoZSBzdHJpbmcuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgIC8vIElmIHdlIGhhdmVuJ3QgbWFya2VkIHRoaXMgc3RyaW5nIGFzIGJlaW5nIHNwZWNpYWxseSBzZXJpYWxpemVkIChpLmUuXG4gICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gc2VyaWFsaXplZCBKU09OKSwgd2UgY2FuIGp1c3QgcmV0dXJuIGl0IGFuZCBiZVxuICAgIC8vIGRvbmUgd2l0aCBpdC5cbiAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIFNFUklBTElaRURfTUFSS0VSX0xFTkdUSCkgIT09IFNFUklBTElaRURfTUFSS0VSKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgZGVhbHMgd2l0aCBkZXNlcmlhbGl6aW5nIHNvbWUga2luZCBvZiBCbG9iIG9yXG4gICAgLy8gVHlwZWRBcnJheS4gRmlyc3Qgd2Ugc2VwYXJhdGUgb3V0IHRoZSB0eXBlIG9mIGRhdGEgd2UncmUgZGVhbGluZ1xuICAgIC8vIHdpdGggZnJvbSB0aGUgZGF0YSBpdHNlbGYuXG4gICAgdmFyIHNlcmlhbGl6ZWRTdHJpbmcgPSB2YWx1ZS5zdWJzdHJpbmcoVFlQRV9TRVJJQUxJWkVEX01BUktFUl9MRU5HVEgpO1xuICAgIHZhciB0eXBlID0gdmFsdWUuc3Vic3RyaW5nKFNFUklBTElaRURfTUFSS0VSX0xFTkdUSCwgVFlQRV9TRVJJQUxJWkVEX01BUktFUl9MRU5HVEgpO1xuXG4gICAgdmFyIGJsb2JUeXBlO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmxlIGJsb2IgdHlwZSBzZXJpYWxpemF0aW9uIHN0cmF0ZWd5LlxuICAgIC8vIERCcyBjcmVhdGVkIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgbG9jYWxGb3JhZ2Ugd2lsbCBzaW1wbHkgbm90IGhhdmUgdGhlIGJsb2IgdHlwZS5cbiAgICBpZiAodHlwZSA9PT0gVFlQRV9CTE9CICYmIEJMT0JfVFlQRV9QUkVGSVhfUkVHRVgudGVzdChzZXJpYWxpemVkU3RyaW5nKSkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IHNlcmlhbGl6ZWRTdHJpbmcubWF0Y2goQkxPQl9UWVBFX1BSRUZJWF9SRUdFWCk7XG4gICAgICAgIGJsb2JUeXBlID0gbWF0Y2hlclsxXTtcbiAgICAgICAgc2VyaWFsaXplZFN0cmluZyA9IHNlcmlhbGl6ZWRTdHJpbmcuc3Vic3RyaW5nKG1hdGNoZXJbMF0ubGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKHNlcmlhbGl6ZWRTdHJpbmcpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByaWdodCB0eXBlIGJhc2VkIG9uIHRoZSBjb2RlL3R5cGUgc2V0IGR1cmluZ1xuICAgIC8vIHNlcmlhbGl6YXRpb24uXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgVFlQRV9BUlJBWUJVRkZFUjpcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIGNhc2UgVFlQRV9CTE9COlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogYmxvYlR5cGUgfSk7XG4gICAgICAgIGNhc2UgVFlQRV9JTlQ4QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfVUlOVDhBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfVUlOVDhDTEFNUEVEQVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9JTlQxNkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9VSU5UMTZBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX0lOVDMyQVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX1VJTlQzMkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfRkxPQVQzMkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX0ZMT0FUNjRBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua293biB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxufVxuXG52YXIgbG9jYWxmb3JhZ2VTZXJpYWxpemVyID0ge1xuICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgIGRlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICBzdHJpbmdUb0J1ZmZlcjogc3RyaW5nVG9CdWZmZXIsXG4gICAgYnVmZmVyVG9TdHJpbmc6IGJ1ZmZlclRvU3RyaW5nXG59O1xuXG4vKlxuICogSW5jbHVkZXMgY29kZSBmcm9tOlxuICpcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEYlRhYmxlKHQsIGRiSW5mbywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB0LmV4ZWN1dGVTcWwoJ0NSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyAnICsgJyhpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBrZXkgdW5pcXVlLCB2YWx1ZSknLCBbXSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xufVxuXG4vLyBPcGVuIHRoZSBXZWJTUUwgZGF0YWJhc2UgKGF1dG9tYXRpY2FsbHkgY3JlYXRlcyBvbmUgaWYgb25lIGRpZG4ndFxuLy8gcHJldmlvdXNseSBleGlzdCksIHVzaW5nIGFueSBvcHRpb25zIHNldCBpbiB0aGUgY29uZmlnLlxuZnVuY3Rpb24gX2luaXRTdG9yYWdlJDEob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGJJbmZvID0ge1xuICAgICAgICBkYjogbnVsbFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRiSW5mb1tpXSA9IHR5cGVvZiBvcHRpb25zW2ldICE9PSAnc3RyaW5nJyA/IG9wdGlvbnNbaV0udG9TdHJpbmcoKSA6IG9wdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGJJbmZvUHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBPcGVuIHRoZSBkYXRhYmFzZTsgdGhlIG9wZW5EYXRhYmFzZSBBUEkgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIC8vIGNyZWF0ZSBpdCBmb3IgdXMgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRiSW5mby5kYiA9IG9wZW5EYXRhYmFzZShkYkluZm8ubmFtZSwgU3RyaW5nKGRiSW5mby52ZXJzaW9uKSwgZGJJbmZvLmRlc2NyaXB0aW9uLCBkYkluZm8uc2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgb3VyIGtleS92YWx1ZSB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGNyZWF0ZURiVGFibGUodCwgZGJJbmZvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZGJJbmZvID0gZGJJbmZvO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGRiSW5mby5zZXJpYWxpemVyID0gbG9jYWxmb3JhZ2VTZXJpYWxpemVyO1xuICAgIHJldHVybiBkYkluZm9Qcm9taXNlO1xufVxuXG5mdW5jdGlvbiB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgc3FsU3RhdGVtZW50LCBhcmdzLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHQuZXhlY3V0ZVNxbChzcWxTdGF0ZW1lbnQsIGFyZ3MsIGNhbGxiYWNrLCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGVycm9yLlNZTlRBWF9FUlIpIHtcbiAgICAgICAgICAgIHQuZXhlY3V0ZVNxbCgnU0VMRUNUIG5hbWUgRlJPTSBzcWxpdGVfbWFzdGVyICcgKyBcIldIRVJFIHR5cGU9J3RhYmxlJyBBTkQgbmFtZSA9ID9cIiwgW2RiSW5mby5zdG9yZU5hbWVdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cy5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGFibGUgaXMgbWlzc2luZyAod2FzIGRlbGV0ZWQpXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLWNyZWF0ZSBpdCB0YWJsZSBhbmQgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRGJUYWJsZSh0LCBkYkluZm8sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuZXhlY3V0ZVNxbChzcWxTdGF0ZW1lbnQsIGFyZ3MsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayh0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKHQsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sIGVycm9yQ2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVtJDEoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUICogRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgV0hFUkUga2V5ID0gPyBMSU1JVCAxJywgW2tleV0sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzLnJvd3MubGVuZ3RoID8gcmVzdWx0cy5yb3dzLml0ZW0oMCkudmFsdWUgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIHNlcmlhbGl6ZWQgY29udGVudCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVucGFjay5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBpdGVyYXRlJDEoaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcblxuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1QgKiBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSByZXN1bHRzLnJvd3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSByb3dzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHJvd3MuaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBzZXJpYWxpemVkIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdW5wYWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yKHJlc3VsdCwgaXRlbS5rZXksIGkgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdm9pZCgwKSBwcmV2ZW50cyBwcm9ibGVtcyB3aXRoIHJlZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYHVuZGVmaW5lZGAuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIF9zZXRJdGVtKGtleSwgdmFsdWUsIGNhbGxiYWNrLCByZXRyaWVzTGVmdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVGhlIGxvY2FsU3RvcmFnZSBBUEkgZG9lc24ndCByZXR1cm4gdW5kZWZpbmVkIHZhbHVlcyBpbiBhblxuICAgICAgICAgICAgLy8gXCJleHBlY3RlZFwiIHdheSwgc28gdW5kZWZpbmVkIGlzIGFsd2F5cyBjYXN0IHRvIG51bGwgaW4gYWxsXG4gICAgICAgICAgICAvLyBkcml2ZXJzLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL3B1bGwvNDJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uc2VyaWFsaXplci5zZXJpYWxpemUodmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnSU5TRVJUIE9SIFJFUExBQ0UgSU5UTyAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgJyArICcoa2V5LCB2YWx1ZSkgVkFMVUVTICg/LCA/KScsIFtrZXksIHZhbHVlXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3JpZ2luYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChzcWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRyYW5zYWN0aW9uIGZhaWxlZDsgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHNlZSBpZiBpdCdzIGEgcXVvdGEgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3FsRXJyb3IuY29kZSA9PT0gc3FsRXJyb3IuUVVPVEFfRVJSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmVqZWN0IHRoZSBjYWxsYmFjayBvdXRyaWdodCBmb3Igbm93LCBidXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHdvcnRoIHRyeWluZyB0byByZS1ydW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHVzZXIgYWNjZXB0cyB0aGUgcHJvbXB0IHRvIHVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgc3RvcmFnZSBvbiBTYWZhcmksIHRoaXMgZXJyb3Igd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZS1ydW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyaWVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfc2V0SXRlbS5hcHBseShzZWxmLCBba2V5LCBvcmlnaW5hbFZhbHVlLCBjYWxsYmFjaywgcmV0cmllc0xlZnQgLSAxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChzcWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBzZXRJdGVtJDEoa2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX3NldEl0ZW0uYXBwbHkodGhpcywgW2tleSwgdmFsdWUsIGNhbGxiYWNrLCAxXSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0kMShrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdERUxFVEUgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgV0hFUkUga2V5ID0gPycsIFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBEZWxldGVzIGV2ZXJ5IGl0ZW0gaW4gdGhlIHRhYmxlLlxuLy8gVE9ETzogRmluZCBvdXQgaWYgdGhpcyByZXNldHMgdGhlIEFVVE9fSU5DUkVNRU5UIG51bWJlci5cbmZ1bmN0aW9uIGNsZWFyJDEoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdERUxFVEUgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIERvZXMgYSBzaW1wbGUgYENPVU5UKGtleSlgIHRvIGdldCB0aGUgbnVtYmVyIG9mIGl0ZW1zIHN0b3JlZCBpblxuLy8gbG9jYWxGb3JhZ2UuXG5mdW5jdGlvbiBsZW5ndGgkMShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAvLyBBaGhoLCBTUUwgbWFrZXMgdGhpcyBvbmUgc29vb29vbyBlYXN5LlxuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUIENPVU5UKGtleSkgYXMgYyBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHMucm93cy5pdGVtKDApLmM7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBSZXR1cm4gdGhlIGtleSBsb2NhdGVkIGF0IGtleSBpbmRleCBYOyBlc3NlbnRpYWxseSBnZXRzIHRoZSBrZXkgZnJvbSBhXG4vLyBgV0hFUkUgaWQgPSA/YC4gVGhpcyBpcyB0aGUgbW9zdCBlZmZpY2llbnQgd2F5IEkgY2FuIHRoaW5rIHRvIGltcGxlbWVudFxuLy8gdGhpcyByYXJlbHktdXNlZCAoaW4gbXkgZXhwZXJpZW5jZSkgcGFydCBvZiB0aGUgQVBJLCBidXQgaXQgY2FuIHNlZW1cbi8vIGluY29uc2lzdGVudCwgYmVjYXVzZSB3ZSBkbyBgSU5TRVJUIE9SIFJFUExBQ0UgSU5UT2Agb24gYHNldEl0ZW0oKWAsIHNvXG4vLyB0aGUgSUQgb2YgZWFjaCBrZXkgd2lsbCBjaGFuZ2UgZXZlcnkgdGltZSBpdCdzIHVwZGF0ZWQuIFBlcmhhcHMgYSBzdG9yZWRcbi8vIHByb2NlZHVyZSBmb3IgdGhlIGBzZXRJdGVtKClgIFNRTCB3b3VsZCBzb2x2ZSB0aGlzIHByb2JsZW0/XG4vLyBUT0RPOiBEb24ndCBjaGFuZ2UgSUQgb24gYHNldEl0ZW0oKWAuXG5mdW5jdGlvbiBrZXkkMShuLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCBrZXkgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgV0hFUkUgaWQgPSA/IExJTUlUIDEnLCBbbiArIDFdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0cy5yb3dzLmxlbmd0aCA/IHJlc3VsdHMucm93cy5pdGVtKDApLmtleSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBrZXlzJDEoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1Qga2V5IEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2gocmVzdWx0cy5yb3dzLml0ZW0oaSkua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoa2V5cyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRhdGFiYXNlLyNkYXRhYmFzZXNcbi8vID4gVGhlcmUgaXMgbm8gd2F5IHRvIGVudW1lcmF0ZSBvciBkZWxldGUgdGhlIGRhdGFiYXNlcyBhdmFpbGFibGUgZm9yIGFuIG9yaWdpbiBmcm9tIHRoaXMgQVBJLlxuZnVuY3Rpb24gZ2V0QWxsU3RvcmVOYW1lcyhkYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHQuZXhlY3V0ZVNxbCgnU0VMRUNUIG5hbWUgRlJPTSBzcWxpdGVfbWFzdGVyICcgKyBcIldIRVJFIHR5cGU9J3RhYmxlJyBBTkQgbmFtZSA8PiAnX19XZWJLaXREYXRhYmFzZUluZm9UYWJsZV9fJ1wiLCBbXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmVOYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lcy5wdXNoKHJlc3VsdHMucm93cy5pdGVtKGkpLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBkYjogZGIsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXM6IHN0b3JlTmFtZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNxbEVycm9yKSB7XG4gICAgICAgICAgICByZWplY3Qoc3FsRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZHJvcEluc3RhbmNlJDEob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGdldENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgY3VycmVudENvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IGN1cnJlbnRDb25maWcubmFtZTtcbiAgICAgICAgb3B0aW9ucy5zdG9yZU5hbWUgPSBvcHRpb25zLnN0b3JlTmFtZSB8fCBjdXJyZW50Q29uZmlnLnN0b3JlTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZWplY3QoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciBkYjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5hbWUgPT09IGN1cnJlbnRDb25maWcubmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZGIgcmVmZXJlbmNlIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgZGIgPSBzZWxmLl9kYkluZm8uZGI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRiID0gb3BlbkRhdGFiYXNlKG9wdGlvbnMubmFtZSwgJycsICcnLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIGRyb3AgYWxsIGRhdGFiYXNlIHRhYmxlc1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZ2V0QWxsU3RvcmVOYW1lcyhkYikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgZGI6IGRiLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzOiBbb3B0aW9ucy5zdG9yZU5hbWVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG9wZXJhdGlvbkluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25JbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRyb3BUYWJsZShzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmV4ZWN1dGVTcWwoJ0RST1AgVEFCTEUgSUYgRVhJU1RTICcgKyBzdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9wZXJhdGlvbkluZm8uc3RvcmVOYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGRyb3BUYWJsZShvcGVyYXRpb25JbmZvLnN0b3JlTmFtZXNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UkMS5hbGwob3BlcmF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHNxbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChzcWxFcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIHdlYlNRTFN0b3JhZ2UgPSB7XG4gICAgX2RyaXZlcjogJ3dlYlNRTFN0b3JhZ2UnLFxuICAgIF9pbml0U3RvcmFnZTogX2luaXRTdG9yYWdlJDEsXG4gICAgX3N1cHBvcnQ6IGlzV2ViU1FMVmFsaWQoKSxcbiAgICBpdGVyYXRlOiBpdGVyYXRlJDEsXG4gICAgZ2V0SXRlbTogZ2V0SXRlbSQxLFxuICAgIHNldEl0ZW06IHNldEl0ZW0kMSxcbiAgICByZW1vdmVJdGVtOiByZW1vdmVJdGVtJDEsXG4gICAgY2xlYXI6IGNsZWFyJDEsXG4gICAgbGVuZ3RoOiBsZW5ndGgkMSxcbiAgICBrZXk6IGtleSQxLFxuICAgIGtleXM6IGtleXMkMSxcbiAgICBkcm9wSW5zdGFuY2U6IGRyb3BJbnN0YW5jZSQxXG59O1xuXG5mdW5jdGlvbiBpc0xvY2FsU3RvcmFnZVZhbGlkKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiAnc2V0SXRlbScgaW4gbG9jYWxTdG9yYWdlICYmXG4gICAgICAgIC8vIGluIElFOCB0eXBlb2YgbG9jYWxTdG9yYWdlLnNldEl0ZW0gPT09ICdvYmplY3QnXG4gICAgICAgICEhbG9jYWxTdG9yYWdlLnNldEl0ZW07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0S2V5UHJlZml4KG9wdGlvbnMsIGRlZmF1bHRDb25maWcpIHtcbiAgICB2YXIga2V5UHJlZml4ID0gb3B0aW9ucy5uYW1lICsgJy8nO1xuXG4gICAgaWYgKG9wdGlvbnMuc3RvcmVOYW1lICE9PSBkZWZhdWx0Q29uZmlnLnN0b3JlTmFtZSkge1xuICAgICAgICBrZXlQcmVmaXggKz0gb3B0aW9ucy5zdG9yZU5hbWUgKyAnLyc7XG4gICAgfVxuICAgIHJldHVybiBrZXlQcmVmaXg7XG59XG5cbi8vIENoZWNrIGlmIGxvY2FsU3RvcmFnZSB0aHJvd3Mgd2hlbiBzYXZpbmcgYW4gaXRlbVxuZnVuY3Rpb24gY2hlY2tJZkxvY2FsU3RvcmFnZVRocm93cygpIHtcbiAgICB2YXIgbG9jYWxTdG9yYWdlVGVzdEtleSA9ICdfbG9jYWxmb3JhZ2Vfc3VwcG9ydF90ZXN0JztcblxuICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU3RvcmFnZVRlc3RLZXksIHRydWUpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShsb2NhbFN0b3JhZ2VUZXN0S2V5KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIENoZWNrIGlmIGxvY2FsU3RvcmFnZSBpcyB1c2FibGUgYW5kIGFsbG93cyB0byBzYXZlIGFuIGl0ZW1cbi8vIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBsb2NhbFN0b3JhZ2UgaXMgdXNhYmxlIGluIFNhZmFyaSBQcml2YXRlIEJyb3dzaW5nXG4vLyBtb2RlLCBvciBpbiBhbnkgb3RoZXIgY2FzZSB3aGVyZSB0aGUgYXZhaWxhYmxlIHF1b3RhIGZvciBsb2NhbFN0b3JhZ2Vcbi8vIGlzIDAgYW5kIHRoZXJlIHdhc24ndCBhbnkgc2F2ZWQgaXRlbXMgeWV0LlxuZnVuY3Rpb24gX2lzTG9jYWxTdG9yYWdlVXNhYmxlKCkge1xuICAgIHJldHVybiAhY2hlY2tJZkxvY2FsU3RvcmFnZVRocm93cygpIHx8IGxvY2FsU3RvcmFnZS5sZW5ndGggPiAwO1xufVxuXG4vLyBDb25maWcgdGhlIGxvY2FsU3RvcmFnZSBiYWNrZW5kLCB1c2luZyBvcHRpb25zIHNldCBpbiB0aGUgY29uZmlnLlxuZnVuY3Rpb24gX2luaXRTdG9yYWdlJDIob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGJJbmZvID0ge307XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkYkluZm9baV0gPSBvcHRpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGJJbmZvLmtleVByZWZpeCA9IF9nZXRLZXlQcmVmaXgob3B0aW9ucywgc2VsZi5fZGVmYXVsdENvbmZpZyk7XG5cbiAgICBpZiAoIV9pc0xvY2FsU3RvcmFnZVVzYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlJDEucmVqZWN0KCk7XG4gICAgfVxuXG4gICAgc2VsZi5fZGJJbmZvID0gZGJJbmZvO1xuICAgIGRiSW5mby5zZXJpYWxpemVyID0gbG9jYWxmb3JhZ2VTZXJpYWxpemVyO1xuXG4gICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCk7XG59XG5cbi8vIFJlbW92ZSBhbGwga2V5cyBmcm9tIHRoZSBkYXRhc3RvcmUsIGVmZmVjdGl2ZWx5IGRlc3Ryb3lpbmcgYWxsIGRhdGEgaW5cbi8vIHRoZSBhcHAncyBrZXkvdmFsdWUgc3RvcmUhXG5mdW5jdGlvbiBjbGVhciQyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5UHJlZml4ID0gc2VsZi5fZGJJbmZvLmtleVByZWZpeDtcblxuICAgICAgICBmb3IgKHZhciBpID0gbG9jYWxTdG9yYWdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcblxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKGtleVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBSZXRyaWV2ZSBhbiBpdGVtIGZyb20gdGhlIHN0b3JlLiBVbmxpa2UgdGhlIG9yaWdpbmFsIGFzeW5jX3N0b3JhZ2Vcbi8vIGxpYnJhcnkgaW4gR2FpYSwgd2UgZG9uJ3QgbW9kaWZ5IHJldHVybiB2YWx1ZXMgYXQgYWxsLiBJZiBhIGtleSdzIHZhbHVlXG4vLyBpcyBgdW5kZWZpbmVkYCwgd2UgcGFzcyB0aGF0IHZhbHVlIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbmZ1bmN0aW9uIGdldEl0ZW0kMihrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGRiSW5mby5rZXlQcmVmaXggKyBrZXkpO1xuXG4gICAgICAgIC8vIElmIGEgcmVzdWx0IHdhcyBmb3VuZCwgcGFyc2UgaXQgZnJvbSB0aGUgc2VyaWFsaXplZFxuICAgICAgICAvLyBzdHJpbmcgaW50byBhIEpTIG9iamVjdC4gSWYgcmVzdWx0IGlzbid0IHRydXRoeSwgdGhlIGtleVxuICAgICAgICAvLyBpcyBsaWtlbHkgdW5kZWZpbmVkIGFuZCB3ZSdsbCBwYXNzIGl0IHN0cmFpZ2h0IHRvIHRoZVxuICAgICAgICAvLyBjYWxsYmFjay5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBJdGVyYXRlIG92ZXIgYWxsIGl0ZW1zIGluIHRoZSBzdG9yZS5cbmZ1bmN0aW9uIGl0ZXJhdGUkMihpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGRiSW5mby5rZXlQcmVmaXg7XG4gICAgICAgIHZhciBrZXlQcmVmaXhMZW5ndGggPSBrZXlQcmVmaXgubGVuZ3RoO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbG9jYWxTdG9yYWdlLmxlbmd0aDtcblxuICAgICAgICAvLyBXZSB1c2UgYSBkZWRpY2F0ZWQgaXRlcmF0b3IgaW5zdGVhZCBvZiB0aGUgYGlgIHZhcmlhYmxlIGJlbG93XG4gICAgICAgIC8vIHNvIG90aGVyIGtleXMgd2UgZmV0Y2ggaW4gbG9jYWxTdG9yYWdlIGFyZW4ndCBjb3VudGVkIGluXG4gICAgICAgIC8vIHRoZSBgaXRlcmF0aW9uTnVtYmVyYCBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGBpdGVyYXRlKClgXG4gICAgICAgIC8vIGNhbGxiYWNrLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTZWU6IGdpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9wdWxsLzQzNSNkaXNjdXNzaW9uX3IzODA2MTUzMFxuICAgICAgICB2YXIgaXRlcmF0aW9uTnVtYmVyID0gMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihrZXlQcmVmaXgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXG4gICAgICAgICAgICAvLyBJZiBhIHJlc3VsdCB3YXMgZm91bmQsIHBhcnNlIGl0IGZyb20gdGhlIHNlcmlhbGl6ZWRcbiAgICAgICAgICAgIC8vIHN0cmluZyBpbnRvIGEgSlMgb2JqZWN0LiBJZiByZXN1bHQgaXNuJ3QgdHJ1dGh5LCB0aGVcbiAgICAgICAgICAgIC8vIGtleSBpcyBsaWtlbHkgdW5kZWZpbmVkIGFuZCB3ZSdsbCBwYXNzIGl0IHN0cmFpZ2h0XG4gICAgICAgICAgICAvLyB0byB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBpdGVyYXRvcih2YWx1ZSwga2V5LnN1YnN0cmluZyhrZXlQcmVmaXhMZW5ndGgpLCBpdGVyYXRpb25OdW1iZXIrKyk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBTYW1lIGFzIGxvY2FsU3RvcmFnZSdzIGtleSgpIG1ldGhvZCwgZXhjZXB0IHRha2VzIGEgY2FsbGJhY2suXG5mdW5jdGlvbiBrZXkkMihuLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxvY2FsU3RvcmFnZS5rZXkobik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcmVmaXggZnJvbSB0aGUga2V5LCBpZiBhIGtleSBpcyBmb3VuZC5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZyhkYkluZm8ua2V5UHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24ga2V5cyQyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbG9jYWxTdG9yYWdlLmxlbmd0aDtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgICAgICBpZiAoaXRlbUtleS5pbmRleE9mKGRiSW5mby5rZXlQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGl0ZW1LZXkuc3Vic3RyaW5nKGRiSW5mby5rZXlQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFN1cHBseSB0aGUgbnVtYmVyIG9mIGtleXMgaW4gdGhlIGRhdGFzdG9yZSB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5mdW5jdGlvbiBsZW5ndGgkMihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYua2V5cygpLnRoZW4oZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgc3RvcmUsIG5pY2UgYW5kIHNpbXBsZS5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0kMihrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZGJJbmZvLmtleVByZWZpeCArIGtleSk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBTZXQgYSBrZXkncyB2YWx1ZSBhbmQgcnVuIGFuIG9wdGlvbmFsIGNhbGxiYWNrIG9uY2UgdGhlIHZhbHVlIGlzIHNldC5cbi8vIFVubGlrZSBHYWlhJ3MgaW1wbGVtZW50YXRpb24sIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHZhbHVlLFxuLy8gaW4gY2FzZSB5b3Ugd2FudCB0byBvcGVyYXRlIG9uIHRoYXQgdmFsdWUgb25seSBhZnRlciB5b3UncmUgc3VyZSBpdFxuLy8gc2F2ZWQsIG9yIHNvbWV0aGluZyBsaWtlIHRoYXQuXG5mdW5jdGlvbiBzZXRJdGVtJDIoa2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDb252ZXJ0IHVuZGVmaW5lZCB2YWx1ZXMgdG8gbnVsbC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvcHVsbC80MlxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5zZXJpYWxpemVyLnNlcmlhbGl6ZSh2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShkYkluZm8ua2V5UHJlZml4ICsga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9yaWdpbmFsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2NhbFN0b3JhZ2UgY2FwYWNpdHkgZXhjZWVkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIHRoaXMgYSBzcGVjaWZpYyBlcnJvci9ldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InIHx8IGUubmFtZSA9PT0gJ05TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGRyb3BJbnN0YW5jZSQyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgICAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgY3VycmVudENvbmZpZy5uYW1lO1xuICAgICAgICBvcHRpb25zLnN0b3JlTmFtZSA9IG9wdGlvbnMuc3RvcmVOYW1lIHx8IGN1cnJlbnRDb25maWcuc3RvcmVOYW1lO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZSQxLnJlamVjdCgnSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUob3B0aW9ucy5uYW1lICsgJy8nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfZ2V0S2V5UHJlZml4KG9wdGlvbnMsIHNlbGYuX2RlZmF1bHRDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoa2V5UHJlZml4KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbG9jYWxTdG9yYWdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yoa2V5UHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIGxvY2FsU3RvcmFnZVdyYXBwZXIgPSB7XG4gICAgX2RyaXZlcjogJ2xvY2FsU3RvcmFnZVdyYXBwZXInLFxuICAgIF9pbml0U3RvcmFnZTogX2luaXRTdG9yYWdlJDIsXG4gICAgX3N1cHBvcnQ6IGlzTG9jYWxTdG9yYWdlVmFsaWQoKSxcbiAgICBpdGVyYXRlOiBpdGVyYXRlJDIsXG4gICAgZ2V0SXRlbTogZ2V0SXRlbSQyLFxuICAgIHNldEl0ZW06IHNldEl0ZW0kMixcbiAgICByZW1vdmVJdGVtOiByZW1vdmVJdGVtJDIsXG4gICAgY2xlYXI6IGNsZWFyJDIsXG4gICAgbGVuZ3RoOiBsZW5ndGgkMixcbiAgICBrZXk6IGtleSQyLFxuICAgIGtleXM6IGtleXMkMixcbiAgICBkcm9wSW5zdGFuY2U6IGRyb3BJbnN0YW5jZSQyXG59O1xuXG52YXIgc2FtZVZhbHVlID0gZnVuY3Rpb24gc2FtZVZhbHVlKHgsIHkpIHtcbiAgICByZXR1cm4geCA9PT0geSB8fCB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT09ICdudW1iZXInICYmIGlzTmFOKHgpICYmIGlzTmFOKHkpO1xufTtcblxudmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIHNlYXJjaEVsZW1lbnQpIHtcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAoc2FtZVZhbHVlKGFycmF5W2ldLCBzZWFyY2hFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gRHJpdmVycyBhcmUgc3RvcmVkIGhlcmUgd2hlbiBgZGVmaW5lRHJpdmVyKClgIGlzIGNhbGxlZC5cbi8vIFRoZXkgYXJlIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcyBvZiBsb2NhbEZvcmFnZS5cbnZhciBEZWZpbmVkRHJpdmVycyA9IHt9O1xuXG52YXIgRHJpdmVyU3VwcG9ydCA9IHt9O1xuXG52YXIgRGVmYXVsdERyaXZlcnMgPSB7XG4gICAgSU5ERVhFRERCOiBhc3luY1N0b3JhZ2UsXG4gICAgV0VCU1FMOiB3ZWJTUUxTdG9yYWdlLFxuICAgIExPQ0FMU1RPUkFHRTogbG9jYWxTdG9yYWdlV3JhcHBlclxufTtcblxudmFyIERlZmF1bHREcml2ZXJPcmRlciA9IFtEZWZhdWx0RHJpdmVycy5JTkRFWEVEREIuX2RyaXZlciwgRGVmYXVsdERyaXZlcnMuV0VCU1FMLl9kcml2ZXIsIERlZmF1bHREcml2ZXJzLkxPQ0FMU1RPUkFHRS5fZHJpdmVyXTtcblxudmFyIE9wdGlvbmFsRHJpdmVyTWV0aG9kcyA9IFsnZHJvcEluc3RhbmNlJ107XG5cbnZhciBMaWJyYXJ5TWV0aG9kcyA9IFsnY2xlYXInLCAnZ2V0SXRlbScsICdpdGVyYXRlJywgJ2tleScsICdrZXlzJywgJ2xlbmd0aCcsICdyZW1vdmVJdGVtJywgJ3NldEl0ZW0nXS5jb25jYXQoT3B0aW9uYWxEcml2ZXJNZXRob2RzKTtcblxudmFyIERlZmF1bHRDb25maWcgPSB7XG4gICAgZGVzY3JpcHRpb246ICcnLFxuICAgIGRyaXZlcjogRGVmYXVsdERyaXZlck9yZGVyLnNsaWNlKCksXG4gICAgbmFtZTogJ2xvY2FsZm9yYWdlJyxcbiAgICAvLyBEZWZhdWx0IERCIHNpemUgaXMgX0pVU1QgVU5ERVJfIDVNQiwgYXMgaXQncyB0aGUgaGlnaGVzdCBzaXplXG4gICAgLy8gd2UgY2FuIHVzZSB3aXRob3V0IGEgcHJvbXB0LlxuICAgIHNpemU6IDQ5ODA3MzYsXG4gICAgc3RvcmVOYW1lOiAna2V5dmFsdWVwYWlycycsXG4gICAgdmVyc2lvbjogMS4wXG59O1xuXG5mdW5jdGlvbiBjYWxsV2hlblJlYWR5KGxvY2FsRm9yYWdlSW5zdGFuY2UsIGxpYnJhcnlNZXRob2QpIHtcbiAgICBsb2NhbEZvcmFnZUluc3RhbmNlW2xpYnJhcnlNZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBsb2NhbEZvcmFnZUluc3RhbmNlLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxGb3JhZ2VJbnN0YW5jZVtsaWJyYXJ5TWV0aG9kXS5hcHBseShsb2NhbEZvcmFnZUluc3RhbmNlLCBfYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9rZXkgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShhcmdbX2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF1bX2tleV0gPSBhcmdbX2tleV0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXVtfa2V5XSA9IGFyZ1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcmd1bWVudHNbMF07XG59XG5cbnZhciBMb2NhbEZvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhbEZvcmFnZShvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2NhbEZvcmFnZSk7XG5cbiAgICAgICAgZm9yICh2YXIgZHJpdmVyVHlwZUtleSBpbiBEZWZhdWx0RHJpdmVycykge1xuICAgICAgICAgICAgaWYgKERlZmF1bHREcml2ZXJzLmhhc093blByb3BlcnR5KGRyaXZlclR5cGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyaXZlciA9IERlZmF1bHREcml2ZXJzW2RyaXZlclR5cGVLZXldO1xuICAgICAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gZHJpdmVyLl9kcml2ZXI7XG4gICAgICAgICAgICAgICAgdGhpc1tkcml2ZXJUeXBlS2V5XSA9IGRyaXZlck5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIURlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IGRyaXZlcnMgY2FuIGJlIGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYSBibG9ja2luZyBtYW5uZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmVEcml2ZXIoZHJpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gZXh0ZW5kKHt9LCBEZWZhdWx0Q29uZmlnKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gZXh0ZW5kKHt9LCB0aGlzLl9kZWZhdWx0Q29uZmlnLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZHJpdmVyU2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5pdERyaXZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RiSW5mbyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5KCk7XG4gICAgICAgIHRoaXMuc2V0RHJpdmVyKHRoaXMuX2NvbmZpZy5kcml2ZXIpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgIH1cblxuICAgIC8vIFNldCBhbnkgY29uZmlnIHZhbHVlcyBmb3IgbG9jYWxGb3JhZ2U7IGNhbiBiZSBjYWxsZWQgYW55dGltZSBiZWZvcmVcbiAgICAvLyB0aGUgZmlyc3QgQVBJIGNhbGwgKGUuZy4gYGdldEl0ZW1gLCBgc2V0SXRlbWApLlxuICAgIC8vIFdlIGxvb3AgdGhyb3VnaCBvcHRpb25zIHNvIHdlIGRvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBjb25maWdcbiAgICAvLyB2YWx1ZXMuXG5cblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5jb25maWcgPSBmdW5jdGlvbiBjb25maWcob3B0aW9ucykge1xuICAgICAgICAvLyBJZiB0aGUgb3B0aW9ucyBhcmd1bWVudCBpcyBhbiBvYmplY3QsIHdlIHVzZSBpdCB0byBzZXQgdmFsdWVzLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHJldHVybiBlaXRoZXIgYSBzcGVjaWZpZWQgY29uZmlnIHZhbHVlIG9yIGFsbFxuICAgICAgICAvLyBjb25maWcgdmFsdWVzLlxuICAgICAgICBpZiAoKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRpb25zKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBJZiBsb2NhbGZvcmFnZSBpcyByZWFkeSBhbmQgZnVsbHkgaW5pdGlhbGl6ZWQsIHdlIGNhbid0IHNldFxuICAgICAgICAgICAgLy8gYW55IG5ldyBjb25maWd1cmF0aW9uIHZhbHVlcy4gSW5zdGVhZCwgd2UgcmV0dXJuIGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkNhbid0IGNhbGwgY29uZmlnKCkgYWZ0ZXIgbG9jYWxmb3JhZ2UgXCIgKyAnaGFzIGJlZW4gdXNlZC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09ICdzdG9yZU5hbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbaV0gPSBvcHRpb25zW2ldLnJlcGxhY2UoL1xcVy9nLCAnXycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpID09PSAndmVyc2lvbicgJiYgdHlwZW9mIG9wdGlvbnNbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0RhdGFiYXNlIHZlcnNpb24gbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25maWdbaV0gPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZnRlciBhbGwgY29uZmlnIG9wdGlvbnMgYXJlIHNldCBhbmRcbiAgICAgICAgICAgIC8vIHRoZSBkcml2ZXIgb3B0aW9uIGlzIHVzZWQsIHRyeSBzZXR0aW5nIGl0XG4gICAgICAgICAgICBpZiAoJ2RyaXZlcicgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmRyaXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldERyaXZlcih0aGlzLl9jb25maWcuZHJpdmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnW29wdGlvbnNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVc2VkIHRvIGRlZmluZSBhIGN1c3RvbSBkcml2ZXIsIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcyBvZlxuICAgIC8vIGxvY2FsRm9yYWdlLlxuXG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuZGVmaW5lRHJpdmVyID0gZnVuY3Rpb24gZGVmaW5lRHJpdmVyKGRyaXZlck9iamVjdCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBkcml2ZXJPYmplY3QuX2RyaXZlcjtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxpYW5jZUVycm9yID0gbmV3IEVycm9yKCdDdXN0b20gZHJpdmVyIG5vdCBjb21wbGlhbnQ7IHNlZSAnICsgJ2h0dHBzOi8vbW96aWxsYS5naXRodWIuaW8vbG9jYWxGb3JhZ2UvI2RlZmluZWRyaXZlcicpO1xuXG4gICAgICAgICAgICAgICAgLy8gQSBkcml2ZXIgbmFtZSBzaG91bGQgYmUgZGVmaW5lZCBhbmQgbm90IG92ZXJsYXAgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsaWJyYXJ5LWRlZmluZWQsIGRlZmF1bHQgZHJpdmVycy5cbiAgICAgICAgICAgICAgICBpZiAoIWRyaXZlck9iamVjdC5fZHJpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChjb21wbGlhbmNlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRyaXZlck1ldGhvZHMgPSBMaWJyYXJ5TWV0aG9kcy5jb25jYXQoJ19pbml0U3RvcmFnZScpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkcml2ZXJNZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcml2ZXJNZXRob2ROYW1lID0gZHJpdmVyTWV0aG9kc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBwcm9wZXJ0eSBpcyB0aGVyZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGEgbWV0aG9kIGV2ZW4gd2hlbiBvcHRpb25hbFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSZXF1aXJlZCA9ICFpbmNsdWRlcyhPcHRpb25hbERyaXZlck1ldGhvZHMsIGRyaXZlck1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGlzUmVxdWlyZWQgfHwgZHJpdmVyT2JqZWN0W2RyaXZlck1ldGhvZE5hbWVdKSAmJiB0eXBlb2YgZHJpdmVyT2JqZWN0W2RyaXZlck1ldGhvZE5hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoY29tcGxpYW5jZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb25maWd1cmVNaXNzaW5nTWV0aG9kcyA9IGZ1bmN0aW9uIGNvbmZpZ3VyZU1pc3NpbmdNZXRob2RzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kTm90SW1wbGVtZW50ZWRGYWN0b3J5ID0gZnVuY3Rpb24gbWV0aG9kTm90SW1wbGVtZW50ZWRGYWN0b3J5KG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdNZXRob2QgJyArIG1ldGhvZE5hbWUgKyAnIGlzIG5vdCBpbXBsZW1lbnRlZCBieSB0aGUgY3VycmVudCBkcml2ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UkMS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbGVuID0gT3B0aW9uYWxEcml2ZXJNZXRob2RzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uYWxEcml2ZXJNZXRob2QgPSBPcHRpb25hbERyaXZlck1ldGhvZHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcml2ZXJPYmplY3Rbb3B0aW9uYWxEcml2ZXJNZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJpdmVyT2JqZWN0W29wdGlvbmFsRHJpdmVyTWV0aG9kXSA9IG1ldGhvZE5vdEltcGxlbWVudGVkRmFjdG9yeShvcHRpb25hbERyaXZlck1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY29uZmlndXJlTWlzc2luZ01ldGhvZHMoKTtcblxuICAgICAgICAgICAgICAgIHZhciBzZXREcml2ZXJTdXBwb3J0ID0gZnVuY3Rpb24gc2V0RHJpdmVyU3VwcG9ydChzdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdSZWRlZmluaW5nIExvY2FsRm9yYWdlIGRyaXZlcjogJyArIGRyaXZlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIERlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdID0gZHJpdmVyT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICBEcml2ZXJTdXBwb3J0W2RyaXZlck5hbWVdID0gc3VwcG9ydDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXNlIGEgdGhlbiwgc28gdGhhdCB3ZSBjYW4gZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIGRyaXZlcnMgdGhhdCBoYXZlIHNpbXBsZSBfc3VwcG9ydCBtZXRob2RzXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGEgYmxvY2tpbmcgbWFubmVyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCdfc3VwcG9ydCcgaW4gZHJpdmVyT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcml2ZXJPYmplY3QuX3N1cHBvcnQgJiYgdHlwZW9mIGRyaXZlck9iamVjdC5fc3VwcG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJpdmVyT2JqZWN0Ll9zdXBwb3J0KCkudGhlbihzZXREcml2ZXJTdXBwb3J0LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHJpdmVyU3VwcG9ydCghIWRyaXZlck9iamVjdC5fc3VwcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXREcml2ZXJTdXBwb3J0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3MocHJvbWlzZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmRyaXZlciA9IGZ1bmN0aW9uIGRyaXZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyaXZlciB8fCBudWxsO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuZ2V0RHJpdmVyID0gZnVuY3Rpb24gZ2V0RHJpdmVyKGRyaXZlck5hbWUsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBnZXREcml2ZXJQcm9taXNlID0gRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0gPyBQcm9taXNlJDEucmVzb2x2ZShEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSkgOiBQcm9taXNlJDEucmVqZWN0KG5ldyBFcnJvcignRHJpdmVyIG5vdCBmb3VuZC4nKSk7XG5cbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhnZXREcml2ZXJQcm9taXNlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBnZXREcml2ZXJQcm9taXNlO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuZ2V0U2VyaWFsaXplciA9IGZ1bmN0aW9uIGdldFNlcmlhbGl6ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZXJQcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUobG9jYWxmb3JhZ2VTZXJpYWxpemVyKTtcbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhzZXJpYWxpemVyUHJvbWlzZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplclByb21pc2U7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIHJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuX2RyaXZlclNldC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9yZWFkeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3JlYWR5ID0gc2VsZi5faW5pdERyaXZlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcmVhZHk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3MocHJvbWlzZSwgY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5zZXREcml2ZXIgPSBmdW5jdGlvbiBzZXREcml2ZXIoZHJpdmVycywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNBcnJheShkcml2ZXJzKSkge1xuICAgICAgICAgICAgZHJpdmVycyA9IFtkcml2ZXJzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdXBwb3J0ZWREcml2ZXJzID0gdGhpcy5fZ2V0U3VwcG9ydGVkRHJpdmVycyhkcml2ZXJzKTtcblxuICAgICAgICBmdW5jdGlvbiBzZXREcml2ZXJUb0NvbmZpZygpIHtcbiAgICAgICAgICAgIHNlbGYuX2NvbmZpZy5kcml2ZXIgPSBzZWxmLmRyaXZlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXh0ZW5kU2VsZldpdGhEcml2ZXIoZHJpdmVyKSB7XG4gICAgICAgICAgICBzZWxmLl9leHRlbmQoZHJpdmVyKTtcbiAgICAgICAgICAgIHNldERyaXZlclRvQ29uZmlnKCk7XG5cbiAgICAgICAgICAgIHNlbGYuX3JlYWR5ID0gc2VsZi5faW5pdFN0b3JhZ2Uoc2VsZi5fY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZWFkeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXREcml2ZXIoc3VwcG9ydGVkRHJpdmVycykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudERyaXZlckluZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRyaXZlclByb21pc2VMb29wKCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudERyaXZlckluZGV4IDwgc3VwcG9ydGVkRHJpdmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gc3VwcG9ydGVkRHJpdmVyc1tjdXJyZW50RHJpdmVySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERyaXZlckluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RiSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZWFkeSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldERyaXZlcihkcml2ZXJOYW1lKS50aGVuKGV4dGVuZFNlbGZXaXRoRHJpdmVyKVtcImNhdGNoXCJdKGRyaXZlclByb21pc2VMb29wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNldERyaXZlclRvQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTm8gYXZhaWxhYmxlIHN0b3JhZ2UgbWV0aG9kIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kcml2ZXJTZXQgPSBQcm9taXNlJDEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2RyaXZlclNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZHJpdmVyUHJvbWlzZUxvb3AoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBhIGRyaXZlciBpbml0aWFsaXphdGlvbiBpbiBwcm9ncmVzc1xuICAgICAgICAvLyBzbyB3YWl0IGZvciBpdCB0byBmaW5pc2ggaW4gb3JkZXIgdG8gYXZvaWQgYSBwb3NzaWJsZVxuICAgICAgICAvLyByYWNlIGNvbmRpdGlvbiB0byBzZXQgX2RiSW5mb1xuICAgICAgICB2YXIgb2xkRHJpdmVyU2V0RG9uZSA9IHRoaXMuX2RyaXZlclNldCAhPT0gbnVsbCA/IHRoaXMuX2RyaXZlclNldFtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZSgpO1xuICAgICAgICB9KSA6IFByb21pc2UkMS5yZXNvbHZlKCk7XG5cbiAgICAgICAgdGhpcy5fZHJpdmVyU2V0ID0gb2xkRHJpdmVyU2V0RG9uZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gc3VwcG9ydGVkRHJpdmVyc1swXTtcbiAgICAgICAgICAgIHNlbGYuX2RiSW5mbyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLl9yZWFkeSA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmdldERyaXZlcihkcml2ZXJOYW1lKS50aGVuKGZ1bmN0aW9uIChkcml2ZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9kcml2ZXIgPSBkcml2ZXIuX2RyaXZlcjtcbiAgICAgICAgICAgICAgICBzZXREcml2ZXJUb0NvbmZpZygpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2luaXREcml2ZXIgPSBpbml0RHJpdmVyKHN1cHBvcnRlZERyaXZlcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0RHJpdmVyVG9Db25maWcoKTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTm8gYXZhaWxhYmxlIHN0b3JhZ2UgbWV0aG9kIGZvdW5kLicpO1xuICAgICAgICAgICAgc2VsZi5fZHJpdmVyU2V0ID0gUHJvbWlzZSQxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZHJpdmVyU2V0O1xuICAgICAgICB9KTtcblxuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHRoaXMuX2RyaXZlclNldCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJpdmVyU2V0O1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiBzdXBwb3J0cyhkcml2ZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiAhIURyaXZlclN1cHBvcnRbZHJpdmVyTmFtZV07XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5fZXh0ZW5kID0gZnVuY3Rpb24gX2V4dGVuZChsaWJyYXJ5TWV0aG9kc0FuZFByb3BlcnRpZXMpIHtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGxpYnJhcnlNZXRob2RzQW5kUHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5fZ2V0U3VwcG9ydGVkRHJpdmVycyA9IGZ1bmN0aW9uIF9nZXRTdXBwb3J0ZWREcml2ZXJzKGRyaXZlcnMpIHtcbiAgICAgICAgdmFyIHN1cHBvcnRlZERyaXZlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRyaXZlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gZHJpdmVyc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzKGRyaXZlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkRHJpdmVycy5wdXNoKGRyaXZlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWREcml2ZXJzO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSA9IGZ1bmN0aW9uIF93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkoKSB7XG4gICAgICAgIC8vIEFkZCBhIHN0dWIgZm9yIGVhY2ggZHJpdmVyIEFQSSBtZXRob2QgdGhhdCBkZWxheXMgdGhlIGNhbGwgdG8gdGhlXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZHJpdmVyIG1ldGhvZCB1bnRpbCBsb2NhbEZvcmFnZSBpcyByZWFkeS4gVGhlc2Ugc3R1YnNcbiAgICAgICAgLy8gd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZHJpdmVyIG1ldGhvZHMgYXMgc29vbiBhcyB0aGUgZHJpdmVyIGlzXG4gICAgICAgIC8vIGxvYWRlZCwgc28gdGhlcmUgaXMgbm8gcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gTGlicmFyeU1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGxXaGVuUmVhZHkodGhpcywgTGlicmFyeU1ldGhvZHNbaV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbEZvcmFnZShvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExvY2FsRm9yYWdlO1xufSgpO1xuXG4vLyBUaGUgYWN0dWFsIGxvY2FsRm9yYWdlIG9iamVjdCB0aGF0IHdlIGV4cG9zZSBhcyBhIG1vZHVsZSBvciB2aWEgYVxuLy8gZ2xvYmFsLiBJdCdzIGV4dGVuZGVkIGJ5IHB1bGxpbmcgaW4gb25lIG9mIG91ciBvdGhlciBsaWJyYXJpZXMuXG5cblxudmFyIGxvY2FsZm9yYWdlX2pzID0gbmV3IExvY2FsRm9yYWdlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9jYWxmb3JhZ2VfanM7XG5cbn0se1wiM1wiOjN9XX0se30sWzRdKSg0KVxufSk7XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjExJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG5cdFx0ZXhwb3J0c1tcIkJhc2VFbmNyeXB0aW9uXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJCYXNlRW5jcnlwdGlvblwiXSA9IGZhY3RvcnkoKTtcclxufSkoKHR5cGVvZih3aW5kb3cpID09PSAndW5kZWZpbmVkJz9nbG9iYWw6d2luZG93KSwgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xyXG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxyXG4vKioqKioqLyBcdFx0XHR9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xyXG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxyXG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xyXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xyXG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XHJcbi8qKioqKiovXHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKHtcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvYWVzLmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lbmMtYmFzZTY0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWJhc2U2NC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21kNSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21kNS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2cGtkZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NpcGhlci1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHR2YXIgQyA9IENyeXB0b0pTO1xcblxcdFxcdHZhciBDX2xpYiA9IEMubGliO1xcblxcdFxcdHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xcblxcdFxcdHZhciBDX2FsZ28gPSBDLmFsZ287XFxuXFxuXFx0XFx0Ly8gTG9va3VwIHRhYmxlc1xcblxcdFxcdHZhciBTQk9YID0gW107XFxuXFx0XFx0dmFyIElOVl9TQk9YID0gW107XFxuXFx0XFx0dmFyIFNVQl9NSVhfMCA9IFtdO1xcblxcdFxcdHZhciBTVUJfTUlYXzEgPSBbXTtcXG5cXHRcXHR2YXIgU1VCX01JWF8yID0gW107XFxuXFx0XFx0dmFyIFNVQl9NSVhfMyA9IFtdO1xcblxcdFxcdHZhciBJTlZfU1VCX01JWF8wID0gW107XFxuXFx0XFx0dmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcXG5cXHRcXHR2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xcblxcdFxcdHZhciBJTlZfU1VCX01JWF8zID0gW107XFxuXFxuXFx0XFx0Ly8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXFxuXFx0XFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHQvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxcblxcdFxcdFxcdHZhciBkID0gW107XFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChpIDwgMTI4KSB7XFxuXFx0XFx0XFx0XFx0XFx0ZFtpXSA9IGkgPDwgMTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGRbaV0gPSBpIDw8IDEgXiAweDExYjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFdhbGsgR0YoMl44KVxcblxcdFxcdFxcdHZhciB4ID0gMDtcXG5cXHRcXHRcXHR2YXIgeGkgPSAwO1xcblxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcXG5cXHRcXHRcXHRcXHQvLyBDb21wdXRlIHNib3hcXG5cXHRcXHRcXHRcXHR2YXIgc3ggPSB4aSBeIHhpIDw8IDEgXiB4aSA8PCAyIF4geGkgPDwgMyBeIHhpIDw8IDQ7XFxuXFx0XFx0XFx0XFx0c3ggPSBzeCA+Pj4gOCBeIHN4ICYgMHhmZiBeIDB4NjM7XFxuXFx0XFx0XFx0XFx0U0JPWFt4XSA9IHN4O1xcblxcdFxcdFxcdFxcdElOVl9TQk9YW3N4XSA9IHg7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxcblxcdFxcdFxcdFxcdHZhciB4MiA9IGRbeF07XFxuXFx0XFx0XFx0XFx0dmFyIHg0ID0gZFt4Ml07XFxuXFx0XFx0XFx0XFx0dmFyIHg4ID0gZFt4NF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xcblxcdFxcdFxcdFxcdHZhciB0ID0gZFtzeF0gKiAweDEwMSBeIHN4ICogMHgxMDEwMTAwO1xcblxcdFxcdFxcdFxcdFNVQl9NSVhfMFt4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xcblxcdFxcdFxcdFxcdFNVQl9NSVhfMVt4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcXG5cXHRcXHRcXHRcXHRTVUJfTUlYXzJbeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcXG5cXHRcXHRcXHRcXHRTVUJfTUlYXzNbeF0gPSB0O1xcblxcblxcdFxcdFxcdFxcdC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xcblxcdFxcdFxcdFxcdHZhciB0ID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcXG5cXHRcXHRcXHRcXHRJTlZfU1VCX01JWF8wW3N4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xcblxcdFxcdFxcdFxcdElOVl9TVUJfTUlYXzFbc3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xcblxcdFxcdFxcdFxcdElOVl9TVUJfTUlYXzJbc3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XFxuXFx0XFx0XFx0XFx0SU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xcblxcblxcdFxcdFxcdFxcdC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXFxuXFx0XFx0XFx0XFx0aWYgKCF4KSB7XFxuXFx0XFx0XFx0XFx0XFx0eCA9IHhpID0gMTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XFxuXFx0XFx0XFx0XFx0XFx0eGkgXj0gZFtkW3hpXV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9KSgpO1xcblxcblxcdFxcdC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXFxuXFx0XFx0dmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cXG4gICAqL1xcblxcdFxcdHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcXG5cXHRcXHRcXHRfZG9SZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNraXAgcmVzZXQgb2YgblJvdW5kcyBoYXMgYmVlbiBzZXQgYmVmb3JlIGFuZCBrZXkgZGlkIG5vdCBjaGFuZ2VcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBrZXkgPSB0aGlzLl9rZXlQcmlvclJlc2V0ID0gdGhpcy5fa2V5O1xcblxcdFxcdFxcdFxcdHZhciBrZXlXb3JkcyA9IGtleS53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXFxuXFx0XFx0XFx0XFx0dmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDY7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3NcXG5cXHRcXHRcXHRcXHR2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcXG5cXHRcXHRcXHRcXHR2YXIga2V5U2NoZWR1bGUgPSB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoa3NSb3cgPCBrZXlTaXplKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0a2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSb3Qgd29yZFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHQgPSB0IDw8IDggfCB0ID4+PiAyNDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdWIgd29yZFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHQgPSBTQk9YW3QgPj4+IDI0XSA8PCAyNCB8IFNCT1hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IFNCT1hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBTQk9YW3QgJiAweGZmXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBNaXggUmNvblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHQgXj0gUkNPTltrc1JvdyAvIGtleVNpemUgfCAwXSA8PCAyNDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PSA0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3ViIHdvcmRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0ID0gU0JPWFt0ID4+PiAyNF0gPDwgMjQgfCBTQk9YW3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBTQk9YW3QgPj4+IDggJiAweGZmXSA8PCA4IHwgU0JPWFt0ICYgMHhmZl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXFxuXFx0XFx0XFx0XFx0dmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGludktzUm93ICUgNCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbdCA+Pj4gMTYgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8yW1NCT1hbdCA+Pj4gOCAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xcblxcdFxcdFxcdFxcdHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcXG5cXHRcXHRcXHRcXHRNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcXG5cXHRcXHRcXHRcXHRNW29mZnNldCArIDNdID0gdDtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xcblxcblxcdFxcdFxcdFxcdC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3NcXG5cXHRcXHRcXHRcXHR2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XFxuXFx0XFx0XFx0XFx0TVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XFxuXFx0XFx0XFx0XFx0TVtvZmZzZXQgKyAzXSA9IHQ7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2V0IGlucHV0LCBhZGQgcm91bmQga2V5XFxuXFx0XFx0XFx0XFx0dmFyIHMwID0gTVtvZmZzZXRdIF4ga2V5U2NoZWR1bGVbMF07XFxuXFx0XFx0XFx0XFx0dmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xcblxcdFxcdFxcdFxcdHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcXG5cXHRcXHRcXHRcXHR2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXFxuXFx0XFx0XFx0XFx0dmFyIGtzUm93ID0gNDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSb3VuZHNcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XSBeIFNVQl9NSVhfMVtzMSA+Pj4gMTYgJiAweGZmXSBeIFNVQl9NSVhfMltzMiA+Pj4gOCAmIDB4ZmZdIF4gU1VCX01JWF8zW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVtzMiA+Pj4gMTYgJiAweGZmXSBeIFNVQl9NSVhfMltzMyA+Pj4gOCAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVtzMyA+Pj4gMTYgJiAweGZmXSBeIFNVQl9NSVhfMltzMCA+Pj4gOCAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XSBeIFNVQl9NSVhfMVtzMCA+Pj4gMTYgJiAweGZmXSBeIFNVQl9NSVhfMltzMSA+Pj4gOCAmIDB4ZmZdIF4gU1VCX01JWF8zW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBVcGRhdGUgc3RhdGVcXG5cXHRcXHRcXHRcXHRcXHRzMCA9IHQwO1xcblxcdFxcdFxcdFxcdFxcdHMxID0gdDE7XFxuXFx0XFx0XFx0XFx0XFx0czIgPSB0MjtcXG5cXHRcXHRcXHRcXHRcXHRzMyA9IHQzO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcXG5cXHRcXHRcXHRcXHR2YXIgdDAgPSAoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0IHwgU0JPWFtzMSA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IFNCT1hbczIgPj4+IDggJiAweGZmXSA8PCA4IHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xcblxcdFxcdFxcdFxcdHZhciB0MSA9IChTQk9YW3MxID4+PiAyNF0gPDwgMjQgfCBTQk9YW3MyID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgU0JPWFtzMyA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XFxuXFx0XFx0XFx0XFx0dmFyIHQyID0gKFNCT1hbczIgPj4+IDI0XSA8PCAyNCB8IFNCT1hbczMgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBTQk9YW3MwID4+PiA4ICYgMHhmZl0gPDwgOCB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcXG5cXHRcXHRcXHRcXHR2YXIgdDMgPSAoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0IHwgU0JPWFtzMCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IFNCT1hbczEgPj4+IDggJiAweGZmXSA8PCA4IHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xcblxcblxcdFxcdFxcdFxcdC8vIFNldCBvdXRwdXRcXG5cXHRcXHRcXHRcXHRNW29mZnNldF0gPSB0MDtcXG5cXHRcXHRcXHRcXHRNW29mZnNldCArIDFdID0gdDE7XFxuXFx0XFx0XFx0XFx0TVtvZmZzZXQgKyAyXSA9IHQyO1xcblxcdFxcdFxcdFxcdE1bb2Zmc2V0ICsgM10gPSB0MztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGtleVNpemU6IDI1NiAvIDMyXFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XFxuICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XFxuICAgKi9cXG5cXHRcXHRDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcXG5cXHR9KSgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5BRVM7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2cGtkZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQvKipcXG4gICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cXG4gICovXFxuXFx0Q3J5cHRvSlMubGliLkNpcGhlciB8fCBmdW5jdGlvbiAodW5kZWZpbmVkKSB7XFxuXFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0dmFyIEMgPSBDcnlwdG9KUztcXG5cXHRcXHR2YXIgQ19saWIgPSBDLmxpYjtcXG5cXHRcXHR2YXIgQmFzZSA9IENfbGliLkJhc2U7XFxuXFx0XFx0dmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcXG5cXHRcXHR2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XFxuXFx0XFx0dmFyIENfZW5jID0gQy5lbmM7XFxuXFx0XFx0dmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xcblxcdFxcdHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XFxuXFx0XFx0dmFyIENfYWxnbyA9IEMuYWxnbztcXG5cXHRcXHR2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxcbiAgICpcXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cXG4gICAqL1xcblxcdFxcdHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxcbiAgICAqXFxuICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxcbiAgICAqL1xcblxcdFxcdFxcdGNmZzogQmFzZS5leHRlbmQoKSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cXG4gICAgKlxcbiAgICAqIEBzdGF0aWNcXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xcbiAgICAqL1xcblxcdFxcdFxcdGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cXG4gICAgKlxcbiAgICAqIEBzdGF0aWNcXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xcbiAgICAqL1xcblxcdFxcdFxcdGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xcbiAgICAqL1xcblxcdFxcdFxcdGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXFxuXFx0XFx0XFx0XFx0dGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XFxuXFx0XFx0XFx0XFx0dGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xcblxcdFxcdFxcdFxcdHRoaXMuX2tleSA9IGtleTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHR0aGlzLnJlc2V0KCk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIGNpcGhlci5yZXNldCgpO1xcbiAgICAqL1xcblxcdFxcdFxcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gUmVzZXQgZGF0YSBidWZmZXJcXG5cXHRcXHRcXHRcXHRCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcXG5cXHRcXHRcXHRcXHR0aGlzLl9kb1Jlc2V0KCk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xcbiAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xcblxcdFxcdFxcdFxcdC8vIEFwcGVuZFxcblxcdFxcdFxcdFxcdHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3NcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cXG4gICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xcbiAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XFxuICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRmaW5hbGl6ZTogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcXG5cXHRcXHRcXHRcXHQvLyBGaW5hbCBkYXRhIHVwZGF0ZVxcblxcdFxcdFxcdFxcdGlmIChkYXRhVXBkYXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xcblxcdFxcdFxcdFxcdHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGtleVNpemU6IDEyOCAvIDMyLFxcblxcblxcdFxcdFxcdGl2U2l6ZTogMTI4IC8gMzIsXFxuXFxuXFx0XFx0XFx0X0VOQ19YRk9STV9NT0RFOiAxLFxcblxcblxcdFxcdFxcdF9ERUNfWEZPUk1fTU9ERTogMixcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDcmVhdGVzIHNob3J0Y3V0IGZ1bmN0aW9ucyB0byBhIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBBRVMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5BRVMpO1xcbiAgICAqL1xcblxcdFxcdFxcdF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH0oKVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxcbiAgICpcXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXFxuICAgKi9cXG5cXHRcXHR2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XFxuXFx0XFx0XFx0X2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXFxuXFx0XFx0XFx0XFx0dmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGJsb2NrU2l6ZTogMVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogTW9kZSBuYW1lc3BhY2UuXFxuICAgKi9cXG5cXHRcXHR2YXIgQ19tb2RlID0gQy5tb2RlID0ge307XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciBtb2RlIHRlbXBsYXRlLlxcbiAgICovXFxuXFx0XFx0dmFyIEJsb2NrQ2lwaGVyTW9kZSA9IENfbGliLkJsb2NrQ2lwaGVyTW9kZSA9IEJhc2UuZXh0ZW5kKHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXFxuICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcXG4gICAgKi9cXG5cXHRcXHRcXHRjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBkZWNyeXB0aW9uLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cXG4gICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRGVjcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xcbiAgICAqL1xcblxcdFxcdFxcdGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xcbiAgICAqL1xcblxcdFxcdFxcdGluaXQ6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fY2lwaGVyID0gY2lwaGVyO1xcblxcdFxcdFxcdFxcdHRoaXMuX2l2ID0gaXY7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXFxuICAgKi9cXG5cXHRcXHR2YXIgQ0JDID0gQ19tb2RlLkNCQyA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxcbiAgICAqL1xcblxcdFxcdFxcdHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ0JDIGVuY3J5cHRvci5cXG4gICAgKi9cXG5cXHRcXHRcXHRDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxcbiAgICAgKlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0cHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdFxcdHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gWE9SIGFuZCBlbmNyeXB0XFxuXFx0XFx0XFx0XFx0XFx0eG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xcblxcdFxcdFxcdFxcdFxcdGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDQkMgZGVjcnlwdG9yLlxcbiAgICAqL1xcblxcdFxcdFxcdENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXFxuICAgICAqXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHRwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERlY3J5cHQgYW5kIFhPUlxcblxcdFxcdFxcdFxcdFxcdGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XFxuXFx0XFx0XFx0XFx0XFx0eG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0dmFyIGl2ID0gdGhpcy5faXY7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2hvb3NlIG1peGluZyBibG9ja1xcblxcdFxcdFxcdFxcdGlmIChpdikge1xcblxcdFxcdFxcdFxcdFxcdHZhciBibG9jayA9IGl2O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9pdiA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHZhciBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gWE9SIGJsb2Nrc1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBDQkM7XFxuXFx0XFx0fSgpO1xcblxcblxcdFxcdC8qKlxcbiAgICogUGFkZGluZyBuYW1lc3BhY2UuXFxuICAgKi9cXG5cXHRcXHR2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXFxuICAgKi9cXG5cXHRcXHR2YXIgUGtjczcgPSBDX3BhZC5Qa2NzNyA9IHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dFxcblxcdFxcdFxcdFxcdHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ291bnQgcGFkZGluZyBieXRlc1xcblxcdFxcdFxcdFxcdHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ3JlYXRlIHBhZGRpbmcgd29yZFxcblxcdFxcdFxcdFxcdHZhciBwYWRkaW5nV29yZCA9IG5QYWRkaW5nQnl0ZXMgPDwgMjQgfCBuUGFkZGluZ0J5dGVzIDw8IDE2IHwgblBhZGRpbmdCeXRlcyA8PCA4IHwgblBhZGRpbmdCeXRlcztcXG5cXG5cXHRcXHRcXHRcXHQvLyBDcmVhdGUgcGFkZGluZ1xcblxcdFxcdFxcdFxcdHZhciBwYWRkaW5nV29yZHMgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xcblxcdFxcdFxcdFxcdFxcdHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRkIHBhZGRpbmdcXG5cXHRcXHRcXHRcXHRkYXRhLmNvbmNhdChwYWRkaW5nKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cXG4gICAgKlxcbiAgICAqIEBzdGF0aWNcXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XFxuICAgICovXFxuXFx0XFx0XFx0dW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XFxuXFx0XFx0XFx0XFx0Ly8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXFxuXFx0XFx0XFx0XFx0dmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzW2RhdGEuc2lnQnl0ZXMgLSAxID4+PiAyXSAmIDB4ZmY7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIHBhZGRpbmdcXG5cXHRcXHRcXHRcXHRkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cXG4gICAqXFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcXG4gICAqL1xcblxcdFxcdHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxcbiAgICAqXFxuICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXFxuICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcXG4gICAgKi9cXG5cXHRcXHRcXHRjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcXG5cXHRcXHRcXHRcXHRtb2RlOiBDQkMsXFxuXFx0XFx0XFx0XFx0cGFkZGluZzogUGtjczdcXG5cXHRcXHRcXHR9KSxcXG5cXG5cXHRcXHRcXHRyZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFJlc2V0IGNpcGhlclxcblxcdFxcdFxcdFxcdENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xcblxcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBjZmcgPSB0aGlzLmNmZztcXG5cXHRcXHRcXHRcXHR2YXIgaXYgPSBjZmcuaXY7XFxuXFx0XFx0XFx0XFx0dmFyIG1vZGUgPSBjZmcubW9kZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXNldCBibG9jayBtb2RlXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xcblxcdFxcdFxcdFxcdH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqL3tcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGUgJiYgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPT0gbW9kZUNyZWF0b3IpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9tb2RlLmluaXQodGhpcywgaXYgJiYgaXYud29yZHMpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX21vZGUuX19jcmVhdG9yID0gbW9kZUNyZWF0b3I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dFxcblxcdFxcdFxcdFxcdHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaW5hbGl6ZVxcblxcdFxcdFxcdFxcdGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBQYWQgZGF0YVxcblxcdFxcdFxcdFxcdFxcdHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xcblxcdFxcdFxcdFxcdFxcdHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi97XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUHJvY2VzcyBmaW5hbCBibG9ja3NcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gVW5wYWQgZGF0YVxcblxcdFxcdFxcdFxcdFxcdFxcdHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRibG9ja1NpemU6IDEyOCAvIDMyXFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXFxuICAgKlxcbiAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxcbiAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cXG4gICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cXG4gICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxcbiAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cXG4gICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxcbiAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxcbiAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cXG4gICAqL1xcblxcdFxcdHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xcbiAgICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcXG4gICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxcbiAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxcbiAgICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcXG4gICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXFxuICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcXG4gICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcXG4gICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcXG4gICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcXG4gICAgKiAgICAgfSk7XFxuICAgICovXFxuXFx0XFx0XFx0aW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xcblxcdFxcdFxcdFxcdHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cXG4gICAgKlxcbiAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XFxuICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcXG4gICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XFxuICAgICovXFxuXFx0XFx0XFx0dG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEZvcm1hdCBuYW1lc3BhY2UuXFxuICAgKi9cXG5cXHRcXHR2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxcbiAgICovXFxuXFx0XFx0dmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxcbiAgICAqXFxuICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEBzdGF0aWNcXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcXG4gICAgKi9cXG5cXHRcXHRcXHRzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgY2lwaGVydGV4dCA9IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O1xcblxcdFxcdFxcdFxcdHZhciBzYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRm9ybWF0XFxuXFx0XFx0XFx0XFx0aWYgKHNhbHQpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cXG4gICAgKlxcbiAgICAqIEBzdGF0aWNcXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xcbiAgICAqL1xcblxcdFxcdFxcdHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xcblxcdFxcdFxcdFxcdC8vIFBhcnNlIGJhc2U2NFxcblxcdFxcdFxcdFxcdHZhciBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO1xcblxcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0dmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVGVzdCBmb3Igc2FsdFxcblxcdFxcdFxcdFxcdGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xcblxcdFxcdFxcdFxcdFxcdC8vIEV4dHJhY3Qgc2FsdFxcblxcdFxcdFxcdFxcdFxcdHZhciBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxcblxcdFxcdFxcdFxcdFxcdGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XFxuXFx0XFx0XFx0XFx0XFx0Y2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cXG4gICAqL1xcblxcdFxcdHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxcbiAgICAqXFxuICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXFxuICAgICovXFxuXFx0XFx0XFx0Y2ZnOiBCYXNlLmV4dGVuZCh7XFxuXFx0XFx0XFx0XFx0Zm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXFxuXFx0XFx0XFx0fSksXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xcbiAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcXG4gICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XFxuICAgICovXFxuXFx0XFx0XFx0ZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcXG5cXHRcXHRcXHRcXHQvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcXG5cXHRcXHRcXHRcXHRjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbmNyeXB0XFxuXFx0XFx0XFx0XFx0dmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xcblxcdFxcdFxcdFxcdHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xcblxcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0dmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcXG5cXHRcXHRcXHRcXHRyZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XFxuXFx0XFx0XFx0XFx0XFx0Y2lwaGVydGV4dDogY2lwaGVydGV4dCxcXG5cXHRcXHRcXHRcXHRcXHRrZXk6IGtleSxcXG5cXHRcXHRcXHRcXHRcXHRpdjogY2lwaGVyQ2ZnLml2LFxcblxcdFxcdFxcdFxcdFxcdGFsZ29yaXRobTogY2lwaGVyLFxcblxcdFxcdFxcdFxcdFxcdG1vZGU6IGNpcGhlckNmZy5tb2RlLFxcblxcdFxcdFxcdFxcdFxcdHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxcblxcdFxcdFxcdFxcdFxcdGJsb2NrU2l6ZTogY2lwaGVyLmJsb2NrU2l6ZSxcXG5cXHRcXHRcXHRcXHRcXHRmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxcbiAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xcbiAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xcbiAgICAqL1xcblxcdFxcdFxcdGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXFxuXFx0XFx0XFx0XFx0Y2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXFxuXFx0XFx0XFx0XFx0Y2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xcblxcblxcdFxcdFxcdFxcdC8vIERlY3J5cHRcXG5cXHRcXHRcXHRcXHR2YXIgcGxhaW50ZXh0ID0gY2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksIGNmZykuZmluYWxpemUoY2lwaGVydGV4dC5jaXBoZXJ0ZXh0KTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcGxhaW50ZXh0O1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcXG4gICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXFxuICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxcbiAgICAqXFxuICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xcbiAgICAqL1xcblxcdFxcdFxcdF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xcblxcdFxcdFxcdFxcdGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY2lwaGVydGV4dDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogS2V5IGRlcml2YXRpb24gZnVuY3Rpb24gbmFtZXNwYWNlLlxcbiAgICovXFxuXFx0XFx0dmFyIENfa2RmID0gQy5rZGYgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXFxuICAgKi9cXG5cXHRcXHR2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XFxuICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XFxuICAgICovXFxuXFx0XFx0XFx0ZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcXG5cXHRcXHRcXHRcXHQvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxcblxcdFxcdFxcdFxcdGlmICghc2FsdCkge1xcblxcdFxcdFxcdFxcdFxcdHNhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0IC8gOCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIERlcml2ZSBrZXkgYW5kIElWXFxuXFx0XFx0XFx0XFx0dmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xcblxcblxcdFxcdFxcdFxcdC8vIFNlcGFyYXRlIGtleSBhbmQgSVZcXG5cXHRcXHRcXHRcXHR2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XFxuXFx0XFx0XFx0XFx0a2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmV0dXJuIHBhcmFtc1xcblxcdFxcdFxcdFxcdHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcXG4gICAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXFxuICAgKi9cXG5cXHRcXHR2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXFxuICAgICpcXG4gICAgKiBAcHJvcGVydHkge0tERn0ga2RmIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC4gRGVmYXVsdDogT3BlblNTTFxcbiAgICAqL1xcblxcdFxcdFxcdGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xcblxcdFxcdFxcdFxcdGtkZjogT3BlblNTTEtkZlxcblxcdFxcdFxcdH0pLFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xcbiAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXFxuXFx0XFx0XFx0XFx0Y2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXFxuXFx0XFx0XFx0XFx0dmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgSVYgdG8gY29uZmlnXFxuXFx0XFx0XFx0XFx0Y2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbmNyeXB0XFxuXFx0XFx0XFx0XFx0dmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXFxuXFx0XFx0XFx0XFx0Y2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2lwaGVydGV4dDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXFxuICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xcbiAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xcbiAgICAqL1xcblxcdFxcdFxcdGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcXG5cXHRcXHRcXHRcXHQvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcXG5cXHRcXHRcXHRcXHRjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcXG5cXHRcXHRcXHRcXHRjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXFxuXFx0XFx0XFx0XFx0dmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xcblxcblxcdFxcdFxcdFxcdC8vIEFkZCBJViB0byBjb25maWdcXG5cXHRcXHRcXHRcXHRjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xcblxcblxcdFxcdFxcdFxcdC8vIERlY3J5cHRcXG5cXHRcXHRcXHRcXHR2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBwbGFpbnRleHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH0oKTtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeSgpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHQvKipcXG4gICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxcbiAgKi9cXG5cXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCBmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XFxuXFx0XFx0LypcXG4gICAqIExvY2FsIHBvbHlmaWwgb2YgT2JqZWN0LmNyZWF0ZVxcbiAgICovXFxuXFx0XFx0dmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGZ1bmN0aW9uIEYoKSB7fTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKG9iaikge1xcblxcdFxcdFxcdFxcdHZhciBzdWJ0eXBlO1xcblxcblxcdFxcdFxcdFxcdEYucHJvdG90eXBlID0gb2JqO1xcblxcblxcdFxcdFxcdFxcdHN1YnR5cGUgPSBuZXcgRigpO1xcblxcblxcdFxcdFxcdFxcdEYucHJvdG90eXBlID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gc3VidHlwZTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0oKTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cXG4gICAqL1xcblxcdFxcdHZhciBDID0ge307XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cXG4gICAqL1xcblxcdFxcdHZhciBDX2xpYiA9IEMubGliID0ge307XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cXG4gICAqL1xcblxcdFxcdHZhciBCYXNlID0gQ19saWIuQmFzZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICpcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xcbiAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxcbiAgICAgKlxcbiAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xcbiAgICAgKiAgICAgICAgIH1cXG4gICAgICogICAgIH0pO1xcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHRleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBTcGF3blxcblxcdFxcdFxcdFxcdFxcdHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEF1Z21lbnRcXG5cXHRcXHRcXHRcXHRcXHRpZiAob3ZlcnJpZGVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxcblxcdFxcdFxcdFxcdFxcdGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3RcXG5cXHRcXHRcXHRcXHRcXHRzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXFxuXFx0XFx0XFx0XFx0XFx0c3VidHlwZS4kc3VwZXIgPSB0aGlzO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzdWJ0eXBlO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxcbiAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxcbiAgICAgKlxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XFxuICAgICAqL1xcblxcdFxcdFxcdFxcdGNyZWF0ZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XFxuXFx0XFx0XFx0XFx0XFx0aW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gaW5zdGFuY2U7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXFxuICAgICAqXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcXG4gICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAqICAgICAgICAgICAgIC8vIC4uLlxcbiAgICAgKiAgICAgICAgIH1cXG4gICAgICogICAgIH0pO1xcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHRpbml0OiBmdW5jdGlvbiAoKSB7fSxcXG5cXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxcbiAgICAgKlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcXG4gICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xcbiAgICAgKiAgICAgfSk7XFxuICAgICAqL1xcblxcdFxcdFxcdFxcdG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xcblxcdFxcdFxcdFxcdFxcdGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcXG5cXHRcXHRcXHRcXHRcXHRpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXFxuICAgICAqXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KCk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXFxuICAgKlxcbiAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cXG4gICAqL1xcblxcdFxcdHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XFxuICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xcbiAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XFxuXFx0XFx0XFx0XFx0d29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcXG4gICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xcbiAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXG4gICAgKi9cXG5cXHRcXHRcXHR0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xcbiAgICAqL1xcblxcdFxcdFxcdGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xcblxcdFxcdFxcdFxcdHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XFxuXFx0XFx0XFx0XFx0dmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XFxuXFx0XFx0XFx0XFx0dmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcXG5cXG5cXHRcXHRcXHRcXHQvLyBDbGFtcCBleGNlc3MgYml0c1xcblxcdFxcdFxcdFxcdHRoaXMuY2xhbXAoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDb25jYXRcXG5cXHRcXHRcXHRcXHRpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB0aGF0Qnl0ZSA9IHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gMjQgLSBpICUgNCAqIDggJiAweGZmO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXNXb3Jkc1t0aGlzU2lnQnl0ZXMgKyBpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAyNCAtICh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQgKiA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXNXb3Jkc1t0aGlzU2lnQnl0ZXMgKyBpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xcblxcblxcdFxcdFxcdFxcdC8vIENoYWluYWJsZVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xcbiAgICAqL1xcblxcdFxcdFxcdGNsYW1wOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIHdvcmRzID0gdGhpcy53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xcblxcblxcdFxcdFxcdFxcdC8vIENsYW1wXFxuXFx0XFx0XFx0XFx0d29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgMzIgLSBzaWdCeXRlcyAlIDQgKiA4O1xcblxcdFxcdFxcdFxcdHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxcbiAgICAqXFxuICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xcbiAgICAqL1xcblxcdFxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xcblxcdFxcdFxcdFxcdGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2xvbmU7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XFxuICAgICovXFxuXFx0XFx0XFx0cmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHdvcmRzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHIgPSBmdW5jdGlvbiAobV93KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1fdyA9IG1fdztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbV96ID0gMHgzYWRlNjhiMTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWFzayA9IDB4ZmZmZmZmZmY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtX3ogPSAweDkwNjkgKiAobV96ICYgMHhGRkZGKSArIChtX3ogPj4gMHgxMCkgJiBtYXNrO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1fdyA9IDB4NDY1MCAqIChtX3cgJiAweEZGRkYpICsgKG1fdyA+PiAweDEwKSAmIG1hc2s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IChtX3ogPDwgMHgxMCkgKyBtX3cgJiBtYXNrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHQgKz0gMC41O1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQgKiAoTWF0aC5yYW5kb20oKSA+IC41ID8gMSA6IC0xKTtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDAsIHJjYWNoZTsgaSA8IG5CeXRlczsgaSArPSA0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIF9yID0gcigocmNhY2hlIHx8IE1hdGgucmFuZG9tKCkpICogMHgxMDAwMDAwMDApO1xcblxcblxcdFxcdFxcdFxcdFxcdHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xcblxcdFxcdFxcdFxcdFxcdHdvcmRzLnB1c2goX3IoKSAqIDB4MTAwMDAwMDAwIHwgMCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogRW5jb2RlciBuYW1lc3BhY2UuXFxuICAgKi9cXG5cXHRcXHR2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxcbiAgICovXFxuXFx0XFx0dmFyIEhleCA9IENfZW5jLkhleCA9IHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xcbiAgICAqL1xcblxcdFxcdFxcdHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29udmVydFxcblxcdFxcdFxcdFxcdHZhciBoZXhDaGFycyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHZhciBiaXRlID0gd29yZHNbaSA+Pj4gMl0gPj4+IDI0IC0gaSAlIDQgKiA4ICYgMHhmZjtcXG5cXHRcXHRcXHRcXHRcXHRoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xcblxcdFxcdFxcdFxcdFxcdGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XFxuICAgICovXFxuXFx0XFx0XFx0cGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dFxcblxcdFxcdFxcdFxcdHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdC8vIENvbnZlcnRcXG5cXHRcXHRcXHRcXHR2YXIgd29yZHMgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XFxuXFx0XFx0XFx0XFx0XFx0d29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8IDI0IC0gaSAlIDggKiA0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cXG4gICAqL1xcblxcdFxcdHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XFxuXFx0XFx0XFx0XFx0dmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xcblxcblxcdFxcdFxcdFxcdC8vIENvbnZlcnRcXG5cXHRcXHRcXHRcXHR2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYml0ZSA9IHdvcmRzW2kgPj4+IDJdID4+PiAyNCAtIGkgJSA0ICogOCAmIDB4ZmY7XFxuXFx0XFx0XFx0XFx0XFx0bGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xcbiAgICAqL1xcblxcdFxcdFxcdHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDb252ZXJ0XFxuXFx0XFx0XFx0XFx0dmFyIHdvcmRzID0gW107XFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8IDI0IC0gaSAlIDQgKiA4O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXFxuICAgKi9cXG5cXHRcXHR2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEBzdGF0aWNcXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcXG4gICAgKi9cXG5cXHRcXHRcXHRwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxcbiAgICpcXG4gICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXFxuICAgKlxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxcbiAgICovXFxuXFx0XFx0dmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XFxuICAgICovXFxuXFx0XFx0XFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQvLyBJbml0aWFsIHZhbHVlc1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9uRGF0YUJ5dGVzID0gMDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xcbiAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xcblxcdFxcdFxcdFxcdC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcXG5cXHRcXHRcXHRcXHRpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXBwZW5kXFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cXG4gICAgKlxcbiAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcXG4gICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XFxuICAgICovXFxuXFx0XFx0XFx0X3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xcblxcdFxcdFxcdFxcdHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xcblxcdFxcdFxcdFxcdHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xcblxcdFxcdFxcdFxcdHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcXG5cXHRcXHRcXHRcXHR2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xcblxcblxcdFxcdFxcdFxcdC8vIENvdW50IGJsb2NrcyByZWFkeVxcblxcdFxcdFxcdFxcdHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcXG5cXHRcXHRcXHRcXHRpZiAoZG9GbHVzaCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3NcXG5cXHRcXHRcXHRcXHRcXHRuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxcblxcdFxcdFxcdFxcdFxcdC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXFxuXFx0XFx0XFx0XFx0XFx0bkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENvdW50IHdvcmRzIHJlYWR5XFxuXFx0XFx0XFx0XFx0dmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xcblxcblxcdFxcdFxcdFxcdC8vIENvdW50IGJ5dGVzIHJlYWR5XFxuXFx0XFx0XFx0XFx0dmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xcblxcblxcdFxcdFxcdFxcdC8vIFByb2Nlc3MgYmxvY2tzXFxuXFx0XFx0XFx0XFx0aWYgKG5Xb3Jkc1JlYWR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xcblxcdFxcdFxcdFxcdFxcdHZhciBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xcblxcdFxcdFxcdFxcdFxcdGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XFxuICAgICovXFxuXFx0XFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0XFx0Y2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsb25lO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X21pbkJ1ZmZlclNpemU6IDBcXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cXG4gICAqXFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXFxuICAgKi9cXG5cXHRcXHR2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cXG4gICAgKi9cXG5cXHRcXHRcXHRjZmc6IEJhc2UuZXh0ZW5kKCksXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XFxuICAgICovXFxuXFx0XFx0XFx0aW5pdDogZnVuY3Rpb24gKGNmZykge1xcblxcdFxcdFxcdFxcdC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xcblxcdFxcdFxcdFxcdHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0IGluaXRpYWwgdmFsdWVzXFxuXFx0XFx0XFx0XFx0dGhpcy5yZXNldCgpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcXG4gICAgKi9cXG5cXHRcXHRcXHRyZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFJlc2V0IGRhdGEgYnVmZmVyXFxuXFx0XFx0XFx0XFx0QnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xcblxcblxcdFxcdFxcdFxcdC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXFxuXFx0XFx0XFx0XFx0dGhpcy5fZG9SZXNldCgpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XFxuICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcXG4gICAgKi9cXG5cXHRcXHRcXHR1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQXBwZW5kXFxuXFx0XFx0XFx0XFx0dGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xcblxcblxcdFxcdFxcdFxcdC8vIFVwZGF0ZSB0aGUgaGFzaFxcblxcdFxcdFxcdFxcdHRoaXMuX3Byb2Nlc3MoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDaGFpbmFibGVcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cXG4gICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XFxuICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XFxuICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XFxuICAgICovXFxuXFx0XFx0XFx0ZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRmluYWwgbWVzc2FnZSB1cGRhdGVcXG5cXHRcXHRcXHRcXHRpZiAobWVzc2FnZVVwZGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcXG5cXHRcXHRcXHRcXHR2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gaGFzaDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGJsb2NrU2l6ZTogNTEyIC8gMzIsXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cXG4gICAgKlxcbiAgICAqIEBzdGF0aWNcXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XFxuICAgICovXFxuXFx0XFx0XFx0X2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cXG4gICAgKlxcbiAgICAqIEBzdGF0aWNcXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXFxuICAgKi9cXG5cXHRcXHR2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XFxuXFxuXFx0XFx0cmV0dXJuIEM7XFxuXFx0fShNYXRoKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlM7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWJhc2U2NC5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0dmFyIEMgPSBDcnlwdG9KUztcXG5cXHRcXHR2YXIgQ19saWIgPSBDLmxpYjtcXG5cXHRcXHR2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xcblxcdFxcdHZhciBDX2VuYyA9IEMuZW5jO1xcblxcblxcdFxcdC8qKlxcbiAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxcbiAgICovXFxuXFx0XFx0dmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xcbiAgICAqL1xcblxcdFxcdFxcdHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XFxuXFx0XFx0XFx0XFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDbGFtcCBleGNlc3MgYml0c1xcblxcdFxcdFxcdFxcdHdvcmRBcnJheS5jbGFtcCgpO1xcblxcblxcdFxcdFxcdFxcdC8vIENvbnZlcnRcXG5cXHRcXHRcXHRcXHR2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYnl0ZTEgPSB3b3Jkc1tpID4+PiAyXSA+Pj4gMjQgLSBpICUgNCAqIDggJiAweGZmO1xcblxcdFxcdFxcdFxcdFxcdHZhciBieXRlMiA9IHdvcmRzW2kgKyAxID4+PiAyXSA+Pj4gMjQgLSAoaSArIDEpICUgNCAqIDggJiAweGZmO1xcblxcdFxcdFxcdFxcdFxcdHZhciBieXRlMyA9IHdvcmRzW2kgKyAyID4+PiAyXSA+Pj4gMjQgLSAoaSArIDIpICUgNCAqIDggJiAweGZmO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0cmlwbGV0ID0gYnl0ZTEgPDwgMTYgfCBieXRlMiA8PCA4IHwgYnl0ZTM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgaiA9IDA7IGogPCA0ICYmIGkgKyBqICogMC43NSA8IHNpZ0J5dGVzOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQodHJpcGxldCA+Pj4gNiAqICgzIC0gaikgJiAweDNmKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgcGFkZGluZ1xcblxcdFxcdFxcdFxcdHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xcblxcdFxcdFxcdFxcdGlmIChwYWRkaW5nQ2hhcikge1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XFxuICAgICovXFxuXFx0XFx0XFx0cGFyc2U6IGZ1bmN0aW9uIChiYXNlNjRTdHIpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHR2YXIgbWFwID0gdGhpcy5fbWFwO1xcblxcdFxcdFxcdFxcdHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIXJldmVyc2VNYXApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV2ZXJzZU1hcFttYXAuY2hhckNvZGVBdChqKV0gPSBqO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWdub3JlIHBhZGRpbmdcXG5cXHRcXHRcXHRcXHR2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcXG5cXHRcXHRcXHRcXHRpZiAocGFkZGluZ0NoYXIpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29udmVydFxcblxcdFxcdFxcdFxcdHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X21hcDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xcblxcdFxcdH07XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSB7XFxuXFx0XFx0XFx0dmFyIHdvcmRzID0gW107XFxuXFx0XFx0XFx0dmFyIG5CeXRlcyA9IDA7XFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChpICUgNCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCBpICUgNCAqIDI7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+IDYgLSBpICUgNCAqIDI7XFxuXFx0XFx0XFx0XFx0XFx0d29yZHNbbkJ5dGVzID4+PiAyXSB8PSAoYml0czEgfCBiaXRzMikgPDwgMjQgLSBuQnl0ZXMgJSA0ICogODtcXG5cXHRcXHRcXHRcXHRcXHRuQnl0ZXMrKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xcblxcdFxcdH1cXG5cXHR9KSgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLXV0ZjE2LmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtdXRmMTYuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0dmFyIEMgPSBDcnlwdG9KUztcXG5cXHRcXHR2YXIgQ19saWIgPSBDLmxpYjtcXG5cXHRcXHR2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xcblxcdFxcdHZhciBDX2VuYyA9IEMuZW5jO1xcblxcblxcdFxcdC8qKlxcbiAgICogVVRGLTE2IEJFIGVuY29kaW5nIHN0cmF0ZWd5LlxcbiAgICovXFxuXFx0XFx0dmFyIFV0ZjE2QkUgPSBDX2VuYy5VdGYxNiA9IENfZW5jLlV0ZjE2QkUgPSB7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IEJFIHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgdXRmMTZTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmMTYuc3RyaW5naWZ5KHdvcmRBcnJheSk7XFxuICAgICovXFxuXFx0XFx0XFx0c3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xcblxcdFxcdFxcdFxcdHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcXG5cXG5cXHRcXHRcXHRcXHQvLyBDb252ZXJ0XFxuXFx0XFx0XFx0XFx0dmFyIHV0ZjE2Q2hhcnMgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY29kZVBvaW50ID0gd29yZHNbaSA+Pj4gMl0gPj4+IDE2IC0gaSAlIDQgKiA4ICYgMHhmZmZmO1xcblxcdFxcdFxcdFxcdFxcdHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbnZlcnRzIGEgVVRGLTE2IEJFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBCRSBzdHJpbmcuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnBhcnNlKHV0ZjE2U3RyaW5nKTtcXG4gICAgKi9cXG5cXHRcXHRcXHRwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29udmVydFxcblxcdFxcdFxcdFxcdHZhciB3b3JkcyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHdvcmRzW2kgPj4+IDFdIHw9IHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgMTYgLSBpICUgMiAqIDE2O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFVURi0xNiBMRSBlbmNvZGluZyBzdHJhdGVneS5cXG4gICAqL1xcblxcdFxcdENfZW5jLlV0ZjE2TEUgPSB7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IExFIHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgdXRmMTZTdHIgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5zdHJpbmdpZnkod29yZEFycmF5KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XFxuXFx0XFx0XFx0XFx0dmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xcblxcblxcdFxcdFxcdFxcdC8vIENvbnZlcnRcXG5cXHRcXHRcXHRcXHR2YXIgdXRmMTZDaGFycyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xcblxcdFxcdFxcdFxcdFxcdHZhciBjb2RlUG9pbnQgPSBzd2FwRW5kaWFuKHdvcmRzW2kgPj4+IDJdID4+PiAxNiAtIGkgJSA0ICogOCAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0dXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYSBVVEYtMTYgTEUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IExFIHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5wYXJzZSh1dGYxNlN0cik7XFxuICAgICovXFxuXFx0XFx0XFx0cGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0dmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdC8vIENvbnZlcnRcXG5cXHRcXHRcXHRcXHR2YXIgd29yZHMgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR3b3Jkc1tpID4+PiAxXSB8PSBzd2FwRW5kaWFuKHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgMTYgLSBpICUgMiAqIDE2KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc3dhcEVuZGlhbih3b3JkKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHdvcmQgPDwgOCAmIDB4ZmYwMGZmMDAgfCB3b3JkID4+PiA4ICYgMHgwMGZmMDBmZjtcXG5cXHRcXHR9XFxuXFx0fSkoKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0ZjE2O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtdXRmMTYuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2hhMSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9obWFjICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xcblxcdFxcdHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XFxuXFx0XFx0dmFyIENfYWxnbyA9IEMuYWxnbztcXG5cXHRcXHR2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxcbiAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcXG4gICAqL1xcblxcdFxcdHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cXG4gICAgKlxcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXFxuICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxcbiAgICAqL1xcblxcdFxcdFxcdGNmZzogQmFzZS5leHRlbmQoe1xcblxcdFxcdFxcdFxcdGtleVNpemU6IDEyOCAvIDMyLFxcblxcdFxcdFxcdFxcdGhhc2hlcjogTUQ1LFxcblxcdFxcdFxcdFxcdGl0ZXJhdGlvbnM6IDFcXG5cXHRcXHRcXHR9KSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XFxuICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xcbiAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xcbiAgICAqL1xcblxcdFxcdFxcdGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0dmFyIGNmZyA9IHRoaXMuY2ZnO1xcblxcblxcdFxcdFxcdFxcdC8vIEluaXQgaGFzaGVyXFxuXFx0XFx0XFx0XFx0dmFyIGhhc2hlciA9IGNmZy5oYXNoZXIuY3JlYXRlKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5pdGlhbCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHR2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xcblxcdFxcdFxcdFxcdHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2VuZXJhdGUga2V5XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJsb2NrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFzaGVyLnVwZGF0ZShibG9jayk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHZhciBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xcblxcdFxcdFxcdFxcdFxcdGhhc2hlci5yZXNldCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEl0ZXJhdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYXNoZXIucmVzZXQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRlcml2ZWRLZXk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXFxuICAgKlxcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxcbiAgICpcXG4gICAqIEBzdGF0aWNcXG4gICAqXFxuICAgKiBAZXhhbXBsZVxcbiAgICpcXG4gICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcXG4gICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XFxuICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xcbiAgICovXFxuXFx0XFx0Qy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xcblxcdFxcdFxcdHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XFxuXFx0XFx0fTtcXG5cXHR9KSgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5FdnBLREY7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Zvcm1hdC1oZXguanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9mb3JtYXQtaGV4LmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2lwaGVyLWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcztcXG5cXHRcXHR2YXIgQ19lbmMgPSBDLmVuYztcXG5cXHRcXHR2YXIgSGV4ID0gQ19lbmMuSGV4O1xcblxcdFxcdHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0O1xcblxcblxcdFxcdHZhciBIZXhGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5IZXggPSB7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgdGhlIGNpcGhlcnRleHQgb2YgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXFxuICAgICpcXG4gICAgKiBAc3RhdGljXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xcbiAgICAqL1xcblxcdFxcdFxcdHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xcblxcdFxcdFxcdFxcdHJldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29udmVydHMgYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgY2lwaGVydGV4dCBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxcbiAgICAqXFxuICAgICogQHN0YXRpY1xcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5wYXJzZShoZXhTdHJpbmcpO1xcbiAgICAqL1xcblxcdFxcdFxcdHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQpIHtcXG5cXHRcXHRcXHRcXHR2YXIgY2lwaGVydGV4dCA9IEhleC5wYXJzZShpbnB1dCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0IH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH0pKCk7XFxuXFxuXFx0cmV0dXJuIENyeXB0b0pTLmZvcm1hdC5IZXg7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Zvcm1hdC1oZXguanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0dmFyIEMgPSBDcnlwdG9KUztcXG5cXHRcXHR2YXIgQ19saWIgPSBDLmxpYjtcXG5cXHRcXHR2YXIgQmFzZSA9IENfbGliLkJhc2U7XFxuXFx0XFx0dmFyIENfZW5jID0gQy5lbmM7XFxuXFx0XFx0dmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xcblxcdFxcdHZhciBDX2FsZ28gPSBDLmFsZ287XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBITUFDIGFsZ29yaXRobS5cXG4gICAqL1xcblxcdFxcdHZhciBITUFDID0gQ19hbGdvLkhNQUMgPSBCYXNlLmV4dGVuZCh7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIEhNQUMuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuXFxuICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBobWFjSGFzaGVyID0gQ3J5cHRvSlMuYWxnby5ITUFDLmNyZWF0ZShDcnlwdG9KUy5hbGdvLlNIQTI1Niwga2V5KTtcXG4gICAgKi9cXG5cXHRcXHRcXHRpbml0OiBmdW5jdGlvbiAoaGFzaGVyLCBrZXkpIHtcXG5cXHRcXHRcXHRcXHQvLyBJbml0IGhhc2hlclxcblxcdFxcdFxcdFxcdGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xcblxcblxcdFxcdFxcdFxcdC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcXG5cXHRcXHRcXHRcXHRpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xcblxcdFxcdFxcdFxcdFxcdGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XFxuXFx0XFx0XFx0XFx0dmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcXG5cXHRcXHRcXHRcXHRpZiAoa2V5LnNpZ0J5dGVzID4gaGFzaGVyQmxvY2tTaXplQnl0ZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2xhbXAgZXhjZXNzIGJpdHNcXG5cXHRcXHRcXHRcXHRrZXkuY2xhbXAoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXFxuXFx0XFx0XFx0XFx0dmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XFxuXFx0XFx0XFx0XFx0dmFyIGlLZXkgPSB0aGlzLl9pS2V5ID0ga2V5LmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIG9LZXlXb3JkcyA9IG9LZXkud29yZHM7XFxuXFx0XFx0XFx0XFx0dmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xcblxcdFxcdFxcdFxcdFxcdGlLZXlXb3Jkc1tpXSBePSAweDM2MzYzNjM2O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRvS2V5LnNpZ0J5dGVzID0gaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xcblxcblxcdFxcdFxcdFxcdC8vIFNldCBpbml0aWFsIHZhbHVlc1xcblxcdFxcdFxcdFxcdHRoaXMucmVzZXQoKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIFJlc2V0cyB0aGlzIEhNQUMgdG8gaXRzIGluaXRpYWwgc3RhdGUuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcXG4gICAgKi9cXG5cXHRcXHRcXHRyZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0dmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXNldFxcblxcdFxcdFxcdFxcdGhhc2hlci5yZXNldCgpO1xcblxcdFxcdFxcdFxcdGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBVcGRhdGVzIHRoaXMgSE1BQyB3aXRoIGEgbWVzc2FnZS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtITUFDfSBUaGlzIEhNQUMgaW5zdGFuY2UuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XFxuICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XFxuICAgICovXFxuXFx0XFx0XFx0dXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2hhaW5hYmxlXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXFxuICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcXG4gICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XFxuICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xcbiAgICAqL1xcblxcdFxcdFxcdGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0dmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDb21wdXRlIEhNQUNcXG5cXHRcXHRcXHRcXHR2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xcblxcdFxcdFxcdFxcdGhhc2hlci5yZXNldCgpO1xcblxcdFxcdFxcdFxcdHZhciBobWFjID0gaGFzaGVyLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoaW5uZXJIYXNoKSk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGhtYWM7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH0pKCk7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2htYWMuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9pbmRleC5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9pbmRleC5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi94NjQtY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3g2NC1jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliLXR5cGVkYXJyYXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbGliLXR5cGVkYXJyYXlzLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW5jLXV0ZjE2ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLXV0ZjE2LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW5jLWJhc2U2NCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZDUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zaGExICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NoYTI1NiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTI1Ni5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NoYTIyNCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NoYTUxMiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTUxMi5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NoYTM4NCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTM4NC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NoYTMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmlwZW1kMTYwICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmlwZW1kMTYwLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaG1hYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2htYWMuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYmtkZjIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldnBrZGYgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jaXBoZXItY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kZS1jZmIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWNmYi5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGUtY3RyICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHIuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RlLWN0ci1nbGFkbWFuICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGUtb2ZiICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1vZmIuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RlLWVjYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtZWNiLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFkLWFuc2l4OTIzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWFuc2l4OTIzLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFkLWlzbzEwMTI2ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzEwMTI2LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFkLWlzbzk3OTcxICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzk3OTcxLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFkLXplcm9wYWRkaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLXplcm9wYWRkaW5nLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFkLW5vcGFkZGluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1ub3BhZGRpbmcuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3JtYXQtaGV4ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyaXBsZWRlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3RyaXBsZWRlcy5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JjNCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JjNC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhYmJpdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhYmJpdC1sZWdhY3kgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQtbGVnYWN5LmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdHJldHVybiBDcnlwdG9KUztcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaW5kZXguanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9saWItdHlwZWRhcnJheXMuanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHQvLyBDaGVjayBpZiB0eXBlZCBhcnJheXMgYXJlIHN1cHBvcnRlZFxcblxcdFxcdGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0dmFyIEMgPSBDcnlwdG9KUztcXG5cXHRcXHR2YXIgQ19saWIgPSBDLmxpYjtcXG5cXHRcXHR2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xcblxcblxcdFxcdC8vIFJlZmVyZW5jZSBvcmlnaW5hbCBpbml0XFxuXFx0XFx0dmFyIHN1cGVySW5pdCA9IFdvcmRBcnJheS5pbml0O1xcblxcblxcdFxcdC8vIEF1Z21lbnQgV29yZEFycmF5LmluaXQgdG8gaGFuZGxlIHR5cGVkIGFycmF5c1xcblxcdFxcdHZhciBzdWJJbml0ID0gV29yZEFycmF5LmluaXQgPSBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xcblxcdFxcdFxcdC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxcblxcdFxcdFxcdGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcXG5cXHRcXHRcXHRcXHR0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgb3RoZXIgYXJyYXkgdmlld3MgdG8gdWludDhcXG5cXHRcXHRcXHRpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkge1xcblxcdFxcdFxcdFxcdHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBIYW5kbGUgVWludDhBcnJheVxcblxcdFxcdFxcdGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0dmFyIHR5cGVkQXJyYXlCeXRlTGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdC8vIEV4dHJhY3QgYnl0ZXNcXG5cXHRcXHRcXHRcXHR2YXIgd29yZHMgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR3b3Jkc1tpID4+PiAyXSB8PSB0eXBlZEFycmF5W2ldIDw8IDI0IC0gaSAlIDQgKiA4O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBJbml0aWFsaXplIHRoaXMgd29yZCBhcnJheVxcblxcdFxcdFxcdFxcdHN1cGVySW5pdC5jYWxsKHRoaXMsIHdvcmRzLCB0eXBlZEFycmF5Qnl0ZUxlbmd0aCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcXG5cXHRcXHRcXHRcXHRzdXBlckluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRzdWJJbml0LnByb3RvdHlwZSA9IFdvcmRBcnJheTtcXG5cXHR9KSgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9saWItdHlwZWRhcnJheXMuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21kNS5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0KGZ1bmN0aW9uIChNYXRoKSB7XFxuXFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0dmFyIEMgPSBDcnlwdG9KUztcXG5cXHRcXHR2YXIgQ19saWIgPSBDLmxpYjtcXG5cXHRcXHR2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xcblxcdFxcdHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XFxuXFx0XFx0dmFyIENfYWxnbyA9IEMuYWxnbztcXG5cXG5cXHRcXHQvLyBDb25zdGFudHMgdGFibGVcXG5cXHRcXHR2YXIgVCA9IFtdO1xcblxcblxcdFxcdC8vIENvbXB1dGUgY29uc3RhbnRzXFxuXFx0XFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRUW2ldID0gTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwIHwgMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSkoKTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIE1ENSBoYXNoIGFsZ29yaXRobS5cXG4gICAqL1xcblxcdFxcdHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XFxuXFx0XFx0XFx0X2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XSk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHQvLyBTd2FwIGVuZGlhblxcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdFxcdHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRNW29mZnNldF9pXSA9IChNX29mZnNldF9pIDw8IDggfCBNX29mZnNldF9pID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKE1fb2Zmc2V0X2kgPDwgMjQgfCBNX29mZnNldF9pID4+PiA4KSAmIDB4ZmYwMGZmMDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcXG5cXG5cXHRcXHRcXHRcXHR2YXIgTV9vZmZzZXRfMCA9IE1bb2Zmc2V0ICsgMF07XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzEgPSBNW29mZnNldCArIDFdO1xcblxcdFxcdFxcdFxcdHZhciBNX29mZnNldF8yID0gTVtvZmZzZXQgKyAyXTtcXG5cXHRcXHRcXHRcXHR2YXIgTV9vZmZzZXRfMyA9IE1bb2Zmc2V0ICsgM107XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzQgPSBNW29mZnNldCArIDRdO1xcblxcdFxcdFxcdFxcdHZhciBNX29mZnNldF81ID0gTVtvZmZzZXQgKyA1XTtcXG5cXHRcXHRcXHRcXHR2YXIgTV9vZmZzZXRfNiA9IE1bb2Zmc2V0ICsgNl07XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzcgPSBNW29mZnNldCArIDddO1xcblxcdFxcdFxcdFxcdHZhciBNX29mZnNldF84ID0gTVtvZmZzZXQgKyA4XTtcXG5cXHRcXHRcXHRcXHR2YXIgTV9vZmZzZXRfOSA9IE1bb2Zmc2V0ICsgOV07XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzEwID0gTVtvZmZzZXQgKyAxMF07XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzEzID0gTVtvZmZzZXQgKyAxM107XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XFxuXFx0XFx0XFx0XFx0dmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV29ya2luZyB2YXJpYWxiZXNcXG5cXHRcXHRcXHRcXHR2YXIgYSA9IEhbMF07XFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBIWzFdO1xcblxcdFxcdFxcdFxcdHZhciBjID0gSFsyXTtcXG5cXHRcXHRcXHRcXHR2YXIgZCA9IEhbM107XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0YXRpb25cXG5cXHRcXHRcXHRcXHRhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgNywgVFswXSk7XFxuXFx0XFx0XFx0XFx0ZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsIDEyLCBUWzFdKTtcXG5cXHRcXHRcXHRcXHRjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgMTcsIFRbMl0pO1xcblxcdFxcdFxcdFxcdGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAyMiwgVFszXSk7XFxuXFx0XFx0XFx0XFx0YSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsIDcsIFRbNF0pO1xcblxcdFxcdFxcdFxcdGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAxMiwgVFs1XSk7XFxuXFx0XFx0XFx0XFx0YyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsIDE3LCBUWzZdKTtcXG5cXHRcXHRcXHRcXHRiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgMjIsIFRbN10pO1xcblxcdFxcdFxcdFxcdGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCA3LCBUWzhdKTtcXG5cXHRcXHRcXHRcXHRkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgMTIsIFRbOV0pO1xcblxcdFxcdFxcdFxcdGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcXG5cXHRcXHRcXHRcXHRiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XFxuXFx0XFx0XFx0XFx0YSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCBUWzEyXSk7XFxuXFx0XFx0XFx0XFx0ZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xcblxcdFxcdFxcdFxcdGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcXG5cXHRcXHRcXHRcXHRiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XFxuXFxuXFx0XFx0XFx0XFx0YSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsIDUsIFRbMTZdKTtcXG5cXHRcXHRcXHRcXHRkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfNiwgOSwgVFsxN10pO1xcblxcdFxcdFxcdFxcdGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcXG5cXHRcXHRcXHRcXHRiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgMjAsIFRbMTldKTtcXG5cXHRcXHRcXHRcXHRhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgNSwgVFsyMF0pO1xcblxcdFxcdFxcdFxcdGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgVFsyMV0pO1xcblxcdFxcdFxcdFxcdGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcXG5cXHRcXHRcXHRcXHRiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfNCwgMjAsIFRbMjNdKTtcXG5cXHRcXHRcXHRcXHRhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgNSwgVFsyNF0pO1xcblxcdFxcdFxcdFxcdGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgVFsyNV0pO1xcblxcdFxcdFxcdFxcdGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAxNCwgVFsyNl0pO1xcblxcdFxcdFxcdFxcdGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAyMCwgVFsyN10pO1xcblxcdFxcdFxcdFxcdGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgVFsyOF0pO1xcblxcdFxcdFxcdFxcdGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCA5LCBUWzI5XSk7XFxuXFx0XFx0XFx0XFx0YyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsIDE0LCBUWzMwXSk7XFxuXFx0XFx0XFx0XFx0YiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xcblxcblxcdFxcdFxcdFxcdGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCA0LCBUWzMyXSk7XFxuXFx0XFx0XFx0XFx0ZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsIDExLCBUWzMzXSk7XFxuXFx0XFx0XFx0XFx0YyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xcblxcdFxcdFxcdFxcdGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcXG5cXHRcXHRcXHRcXHRhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgNCwgVFszNl0pO1xcblxcdFxcdFxcdFxcdGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAxMSwgVFszN10pO1xcblxcdFxcdFxcdFxcdGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAxNiwgVFszOF0pO1xcblxcdFxcdFxcdFxcdGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcXG5cXHRcXHRcXHRcXHRhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsIFRbNDBdKTtcXG5cXHRcXHRcXHRcXHRkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgMTEsIFRbNDFdKTtcXG5cXHRcXHRcXHRcXHRjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgMTYsIFRbNDJdKTtcXG5cXHRcXHRcXHRcXHRiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgMjMsIFRbNDNdKTtcXG5cXHRcXHRcXHRcXHRhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgNCwgVFs0NF0pO1xcblxcdFxcdFxcdFxcdGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcXG5cXHRcXHRcXHRcXHRjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XFxuXFx0XFx0XFx0XFx0YiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsIDIzLCBUWzQ3XSk7XFxuXFxuXFx0XFx0XFx0XFx0YSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsIDYsIFRbNDhdKTtcXG5cXHRcXHRcXHRcXHRkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgMTAsIFRbNDldKTtcXG5cXHRcXHRcXHRcXHRjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XFxuXFx0XFx0XFx0XFx0YiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsIDIxLCBUWzUxXSk7XFxuXFx0XFx0XFx0XFx0YSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCBUWzUyXSk7XFxuXFx0XFx0XFx0XFx0ZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsIDEwLCBUWzUzXSk7XFxuXFx0XFx0XFx0XFx0YyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xcblxcdFxcdFxcdFxcdGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAyMSwgVFs1NV0pO1xcblxcdFxcdFxcdFxcdGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCA2LCBUWzU2XSk7XFxuXFx0XFx0XFx0XFx0ZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xcblxcdFxcdFxcdFxcdGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAxNSwgVFs1OF0pO1xcblxcdFxcdFxcdFxcdGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcXG5cXHRcXHRcXHRcXHRhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgNiwgVFs2MF0pO1xcblxcdFxcdFxcdFxcdGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcXG5cXHRcXHRcXHRcXHRjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgMTUsIFRbNjJdKTtcXG5cXHRcXHRcXHRcXHRiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgMjEsIFRbNjNdKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxcblxcdFxcdFxcdFxcdEhbMF0gPSBIWzBdICsgYSB8IDA7XFxuXFx0XFx0XFx0XFx0SFsxXSA9IEhbMV0gKyBiIHwgMDtcXG5cXHRcXHRcXHRcXHRIWzJdID0gSFsyXSArIGMgfCAwO1xcblxcdFxcdFxcdFxcdEhbM10gPSBIWzNdICsgZCB8IDA7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBkYXRhID0gdGhpcy5fZGF0YTtcXG5cXHRcXHRcXHRcXHR2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xcblxcdFxcdFxcdFxcdHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgcGFkZGluZ1xcblxcdFxcdFxcdFxcdGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgMjQgLSBuQml0c0xlZnQgJSAzMjtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XFxuXFx0XFx0XFx0XFx0dmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcXG5cXHRcXHRcXHRcXHRkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTVdID0gKG5CaXRzVG90YWxIIDw8IDggfCBuQml0c1RvdGFsSCA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChuQml0c1RvdGFsSCA8PCAyNCB8IG5CaXRzVG90YWxIID4+PiA4KSAmIDB4ZmYwMGZmMDA7XFxuXFx0XFx0XFx0XFx0ZGF0YVdvcmRzWyhuQml0c0xlZnQgKyA2NCA+Pj4gOSA8PCA0KSArIDE0XSA9IChuQml0c1RvdGFsTCA8PCA4IHwgbkJpdHNUb3RhbEwgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAobkJpdHNUb3RhbEwgPDwgMjQgfCBuQml0c1RvdGFsTCA+Pj4gOCkgJiAweGZmMDBmZjAwO1xcblxcblxcdFxcdFxcdFxcdGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBIYXNoIGZpbmFsIGJsb2Nrc1xcblxcdFxcdFxcdFxcdHRoaXMuX3Byb2Nlc3MoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XFxuXFx0XFx0XFx0XFx0dmFyIEggPSBoYXNoLndvcmRzO1xcblxcblxcdFxcdFxcdFxcdC8vIFN3YXAgZW5kaWFuXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBTaG9ydGN1dFxcblxcdFxcdFxcdFxcdFxcdHZhciBIX2kgPSBIW2ldO1xcblxcblxcdFxcdFxcdFxcdFxcdEhbaV0gPSAoSF9pIDw8IDggfCBIX2kgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoSF9pIDw8IDI0IHwgSF9pID4+PiA4KSAmIDB4ZmYwMGZmMDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGhhc2g7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xcblxcdFxcdFxcdFxcdGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjbG9uZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xcblxcdFxcdFxcdHZhciBuID0gYSArIChiICYgYyB8IH5iICYgZCkgKyB4ICsgdDtcXG5cXHRcXHRcXHRyZXR1cm4gKG4gPDwgcyB8IG4gPj4+IDMyIC0gcykgKyBiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XFxuXFx0XFx0XFx0dmFyIG4gPSBhICsgKGIgJiBkIHwgYyAmIH5kKSArIHggKyB0O1xcblxcdFxcdFxcdHJldHVybiAobiA8PCBzIHwgbiA+Pj4gMzIgLSBzKSArIGI7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcXG5cXHRcXHRcXHR2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xcblxcdFxcdFxcdHJldHVybiAobiA8PCBzIHwgbiA+Pj4gMzIgLSBzKSArIGI7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcXG5cXHRcXHRcXHR2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xcblxcdFxcdFxcdHJldHVybiAobiA8PCBzIHwgbiA+Pj4gMzIgLSBzKSArIGI7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8qKlxcbiAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXFxuICAgKlxcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cXG4gICAqXFxuICAgKiBAc3RhdGljXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcXG4gICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xcbiAgICovXFxuXFx0XFx0Qy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xcblxcblxcdFxcdC8qKlxcbiAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXFxuICAgKlxcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cXG4gICAqXFxuICAgKiBAc3RhdGljXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XFxuICAgKi9cXG5cXHRcXHRDLkhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1KTtcXG5cXHR9KShNYXRoKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMuTUQ1O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWNmYi5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWNmYi5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jaXBoZXItY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdC8qKlxcbiAgKiBDaXBoZXIgRmVlZGJhY2sgYmxvY2sgbW9kZS5cXG4gICovXFxuXFx0Q3J5cHRvSlMubW9kZS5DRkIgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIENGQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XFxuXFxuXFx0XFx0Q0ZCLkVuY3J5cHRvciA9IENGQi5leHRlbmQoe1xcblxcdFxcdFxcdHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xcblxcdFxcdFxcdFxcdHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xcblxcblxcdFxcdFxcdFxcdGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcXG5cXHRcXHRcXHRcXHR0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdENGQi5EZWNyeXB0b3IgPSBDRkIuZXh0ZW5kKHtcXG5cXHRcXHRcXHRwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcXG5cXHRcXHRcXHRcXHR2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcXG5cXHRcXHRcXHRcXHR2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xcblxcblxcdFxcdFxcdFxcdGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXFxuXFx0XFx0XFx0XFx0dGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQod29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpIHtcXG5cXHRcXHRcXHQvLyBTaG9ydGN1dFxcblxcdFxcdFxcdHZhciBpdiA9IHRoaXMuX2l2O1xcblxcblxcdFxcdFxcdC8vIEdlbmVyYXRlIGtleXN0cmVhbVxcblxcdFxcdFxcdGlmIChpdikge1xcblxcdFxcdFxcdFxcdHZhciBrZXlzdHJlYW0gPSBpdi5zbGljZSgwKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXFxuXFx0XFx0XFx0XFx0dGhpcy5faXYgPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR2YXIga2V5c3RyZWFtID0gdGhpcy5fcHJldkJsb2NrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XFxuXFxuXFx0XFx0XFx0Ly8gRW5jcnlwdFxcblxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcXG5cXHRcXHRcXHRcXHR3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gQ0ZCO1xcblxcdH0oKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5DRkI7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtY2ZiLmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtY3RyLWdsYWRtYW4uanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jaXBoZXItY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdC8qKiBAcHJlc2VydmVcXG4gICogQ291bnRlciBibG9jayBtb2RlIGNvbXBhdGlibGUgd2l0aCAgRHIgQnJpYW4gR2xhZG1hbiBmaWxlZW5jLmNcXG4gICogZGVyaXZlZCBmcm9tIENyeXB0b0pTLm1vZGUuQ1RSXFxuICAqIEphbiBIcnVieSBqaHJ1Ynkud2ViQGdtYWlsLmNvbVxcbiAgKi9cXG5cXHRDcnlwdG9KUy5tb2RlLkNUUkdsYWRtYW4gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIENUUkdsYWRtYW4gPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xcblxcblxcdFxcdGZ1bmN0aW9uIGluY1dvcmQod29yZCkge1xcblxcdFxcdFxcdGlmICgod29yZCA+PiAyNCAmIDB4ZmYpID09PSAweGZmKSB7XFxuXFx0XFx0XFx0XFx0Ly9vdmVyZmxvd1xcblxcdFxcdFxcdFxcdHZhciBiMSA9IHdvcmQgPj4gMTYgJiAweGZmO1xcblxcdFxcdFxcdFxcdHZhciBiMiA9IHdvcmQgPj4gOCAmIDB4ZmY7XFxuXFx0XFx0XFx0XFx0dmFyIGIzID0gd29yZCAmIDB4ZmY7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGIxID09PSAweGZmKSAvLyBvdmVyZmxvdyBiMVxcblxcdFxcdFxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiMSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGIyID09PSAweGZmKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YjIgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChiMyA9PT0gMHhmZikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGIzID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCsrYjM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KytiMjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQrK2IxO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR3b3JkID0gMDtcXG5cXHRcXHRcXHRcXHR3b3JkICs9IGIxIDw8IDE2O1xcblxcdFxcdFxcdFxcdHdvcmQgKz0gYjIgPDwgODtcXG5cXHRcXHRcXHRcXHR3b3JkICs9IGIzO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0d29yZCArPSAweDAxIDw8IDI0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gd29yZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaW5jQ291bnRlcihjb3VudGVyKSB7XFxuXFx0XFx0XFx0aWYgKChjb3VudGVyWzBdID0gaW5jV29yZChjb3VudGVyWzBdKSkgPT09IDApIHtcXG5cXHRcXHRcXHRcXHQvLyBlbmNyX2RhdGEgaW4gZmlsZWVuYy5jIGZyb20gIERyIEJyaWFuIEdsYWRtYW4ncyBjb3VudHMgb25seSB3aXRoIERXT1JEIGogPCA4XFxuXFx0XFx0XFx0XFx0Y291bnRlclsxXSA9IGluY1dvcmQoY291bnRlclsxXSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBjb3VudGVyO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgRW5jcnlwdG9yID0gQ1RSR2xhZG1hbi5FbmNyeXB0b3IgPSBDVFJHbGFkbWFuLmV4dGVuZCh7XFxuXFx0XFx0XFx0cHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XFxuXFx0XFx0XFx0XFx0dmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XFxuXFx0XFx0XFx0XFx0dmFyIGl2ID0gdGhpcy5faXY7XFxuXFx0XFx0XFx0XFx0dmFyIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyO1xcblxcblxcdFxcdFxcdFxcdC8vIEdlbmVyYXRlIGtleXN0cmVhbVxcblxcdFxcdFxcdFxcdGlmIChpdikge1xcblxcdFxcdFxcdFxcdFxcdGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyID0gaXYuc2xpY2UoMCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpbmNDb3VudGVyKGNvdW50ZXIpO1xcblxcblxcdFxcdFxcdFxcdHZhciBrZXlzdHJlYW0gPSBjb3VudGVyLnNsaWNlKDApO1xcblxcdFxcdFxcdFxcdGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbmNyeXB0XFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdENUUkdsYWRtYW4uRGVjcnlwdG9yID0gRW5jcnlwdG9yO1xcblxcblxcdFxcdHJldHVybiBDVFJHbGFkbWFuO1xcblxcdH0oKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5DVFJHbGFkbWFuO1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci1nbGFkbWFuLmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHIuanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHIuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2lwaGVyLWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQvKipcXG4gICogQ291bnRlciBibG9jayBtb2RlLlxcbiAgKi9cXG5cXHRDcnlwdG9KUy5tb2RlLkNUUiA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgQ1RSID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcXG5cXG5cXHRcXHR2YXIgRW5jcnlwdG9yID0gQ1RSLkVuY3J5cHRvciA9IENUUi5leHRlbmQoe1xcblxcdFxcdFxcdHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xcblxcdFxcdFxcdFxcdHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xcblxcdFxcdFxcdFxcdHZhciBpdiA9IHRoaXMuX2l2O1xcblxcdFxcdFxcdFxcdHZhciBjb3VudGVyID0gdGhpcy5fY291bnRlcjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cXG5cXHRcXHRcXHRcXHRpZiAoaXYpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb3VudGVyID0gdGhpcy5fY291bnRlciA9IGl2LnNsaWNlKDApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9pdiA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFyIGtleXN0cmVhbSA9IGNvdW50ZXIuc2xpY2UoMCk7XFxuXFx0XFx0XFx0XFx0Y2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xcblxcblxcdFxcdFxcdFxcdC8vIEluY3JlbWVudCBjb3VudGVyXFxuXFx0XFx0XFx0XFx0Y291bnRlcltibG9ja1NpemUgLSAxXSA9IGNvdW50ZXJbYmxvY2tTaXplIC0gMV0gKyAxIHwgMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbmNyeXB0XFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdENUUi5EZWNyeXB0b3IgPSBFbmNyeXB0b3I7XFxuXFxuXFx0XFx0cmV0dXJuIENUUjtcXG5cXHR9KCk7XFxuXFxuXFx0cmV0dXJuIENyeXB0b0pTLm1vZGUuQ1RSO1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtZWNiLmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtZWNiLmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NpcGhlci1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0LyoqXFxuICAqIEVsZWN0cm9uaWMgQ29kZWJvb2sgYmxvY2sgbW9kZS5cXG4gICovXFxuXFx0Q3J5cHRvSlMubW9kZS5FQ0IgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIEVDQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XFxuXFxuXFx0XFx0RUNCLkVuY3J5cHRvciA9IEVDQi5leHRlbmQoe1xcblxcdFxcdFxcdHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRFQ0IuRGVjcnlwdG9yID0gRUNCLmV4dGVuZCh7XFxuXFx0XFx0XFx0cHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdHJldHVybiBFQ0I7XFxuXFx0fSgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5tb2RlLkVDQjtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1lY2IuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jaXBoZXItY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdC8qKlxcbiAgKiBPdXRwdXQgRmVlZGJhY2sgYmxvY2sgbW9kZS5cXG4gICovXFxuXFx0Q3J5cHRvSlMubW9kZS5PRkIgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIE9GQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XFxuXFxuXFx0XFx0dmFyIEVuY3J5cHRvciA9IE9GQi5FbmNyeXB0b3IgPSBPRkIuZXh0ZW5kKHtcXG5cXHRcXHRcXHRwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcXG5cXHRcXHRcXHRcXHR2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcXG5cXHRcXHRcXHRcXHR2YXIgaXYgPSB0aGlzLl9pdjtcXG5cXHRcXHRcXHRcXHR2YXIga2V5c3RyZWFtID0gdGhpcy5fa2V5c3RyZWFtO1xcblxcblxcdFxcdFxcdFxcdC8vIEdlbmVyYXRlIGtleXN0cmVhbVxcblxcdFxcdFxcdFxcdGlmIChpdikge1xcblxcdFxcdFxcdFxcdFxcdGtleXN0cmVhbSA9IHRoaXMuX2tleXN0cmVhbSA9IGl2LnNsaWNlKDApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9pdiA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xcblxcblxcdFxcdFxcdFxcdC8vIEVuY3J5cHRcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0d29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0T0ZCLkRlY3J5cHRvciA9IEVuY3J5cHRvcjtcXG5cXG5cXHRcXHRyZXR1cm4gT0ZCO1xcblxcdH0oKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5PRkI7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtb2ZiLmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWFuc2l4OTIzLmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtYW5zaXg5MjMuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NpcGhlci1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0LyoqXFxuICAqIEFOU0kgWC45MjMgcGFkZGluZyBzdHJhdGVneS5cXG4gICovXFxuXFx0Q3J5cHRvSlMucGFkLkFuc2lYOTIzID0ge1xcblxcdFxcdHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xcblxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xcblxcdFxcdFxcdHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XFxuXFxuXFx0XFx0XFx0Ly8gQ291bnQgcGFkZGluZyBieXRlc1xcblxcdFxcdFxcdHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhU2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcXG5cXG5cXHRcXHRcXHQvLyBDb21wdXRlIGxhc3QgYnl0ZSBwb3NpdGlvblxcblxcdFxcdFxcdHZhciBsYXN0Qnl0ZVBvcyA9IGRhdGFTaWdCeXRlcyArIG5QYWRkaW5nQnl0ZXMgLSAxO1xcblxcblxcdFxcdFxcdC8vIFBhZFxcblxcdFxcdFxcdGRhdGEuY2xhbXAoKTtcXG5cXHRcXHRcXHRkYXRhLndvcmRzW2xhc3RCeXRlUG9zID4+PiAyXSB8PSBuUGFkZGluZ0J5dGVzIDw8IDI0IC0gbGFzdEJ5dGVQb3MgJSA0ICogODtcXG5cXHRcXHRcXHRkYXRhLnNpZ0J5dGVzICs9IG5QYWRkaW5nQnl0ZXM7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcXG5cXHRcXHRcXHQvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcXG5cXHRcXHRcXHR2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbZGF0YS5zaWdCeXRlcyAtIDEgPj4+IDJdICYgMHhmZjtcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgcGFkZGluZ1xcblxcdFxcdFxcdGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMucGFkLkFuc2l4OTIzO1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtYW5zaXg5MjMuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvMTAxMjYuanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc28xMDEyNi5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2lwaGVyLWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQvKipcXG4gICogSVNPIDEwMTI2IHBhZGRpbmcgc3RyYXRlZ3kuXFxuICAqL1xcblxcdENyeXB0b0pTLnBhZC5Jc28xMDEyNiA9IHtcXG5cXHRcXHRwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcXG5cXHRcXHRcXHQvLyBTaG9ydGN1dFxcblxcdFxcdFxcdHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XFxuXFxuXFx0XFx0XFx0Ly8gQ291bnQgcGFkZGluZyBieXRlc1xcblxcdFxcdFxcdHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XFxuXFxuXFx0XFx0XFx0Ly8gUGFkXFxuXFx0XFx0XFx0ZGF0YS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oblBhZGRpbmdCeXRlcyAtIDEpKS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoW25QYWRkaW5nQnl0ZXMgPDwgMjRdLCAxKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcXG5cXHRcXHRcXHQvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcXG5cXHRcXHRcXHR2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbZGF0YS5zaWdCeXRlcyAtIDEgPj4+IDJdICYgMHhmZjtcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgcGFkZGluZ1xcblxcdFxcdFxcdGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMucGFkLklzbzEwMTI2O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvMTAxMjYuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvOTc5NzEuanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2lwaGVyLWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQvKipcXG4gICogSVNPL0lFQyA5Nzk3LTEgUGFkZGluZyBNZXRob2QgMi5cXG4gICovXFxuXFx0Q3J5cHRvSlMucGFkLklzbzk3OTcxID0ge1xcblxcdFxcdHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xcblxcdFxcdFxcdC8vIEFkZCAweDgwIGJ5dGVcXG5cXHRcXHRcXHRkYXRhLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHg4MDAwMDAwMF0sIDEpKTtcXG5cXG5cXHRcXHRcXHQvLyBaZXJvIHBhZCB0aGUgcmVzdFxcblxcdFxcdFxcdENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZy5wYWQoZGF0YSwgYmxvY2tTaXplKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xcblxcdFxcdFxcdC8vIFJlbW92ZSB6ZXJvIHBhZGRpbmdcXG5cXHRcXHRcXHRDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcudW5wYWQoZGF0YSk7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIG9uZSBtb3JlIGJ5dGUgLS0gdGhlIDB4ODAgYnl0ZVxcblxcdFxcdFxcdGRhdGEuc2lnQnl0ZXMtLTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMucGFkLklzbzk3OTcxO1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvOTc5NzEuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtbm9wYWRkaW5nLmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLW5vcGFkZGluZy5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NpcGhlci1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0LyoqXFxuICAqIEEgbm9vcCBwYWRkaW5nIHN0cmF0ZWd5LlxcbiAgKi9cXG5cXHRDcnlwdG9KUy5wYWQuTm9QYWRkaW5nID0ge1xcblxcdFxcdHBhZDogZnVuY3Rpb24gKCkge30sXFxuXFxuXFx0XFx0dW5wYWQ6IGZ1bmN0aW9uICgpIHt9XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMucGFkLk5vUGFkZGluZztcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLW5vcGFkZGluZy5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC16ZXJvcGFkZGluZy5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLXplcm9wYWRkaW5nLmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jaXBoZXItY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdC8qKlxcbiAgKiBaZXJvIHBhZGRpbmcgc3RyYXRlZ3kuXFxuICAqL1xcblxcdENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZyA9IHtcXG5cXHRcXHRwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcXG5cXHRcXHRcXHQvLyBTaG9ydGN1dFxcblxcdFxcdFxcdHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XFxuXFxuXFx0XFx0XFx0Ly8gUGFkXFxuXFx0XFx0XFx0ZGF0YS5jbGFtcCgpO1xcblxcdFxcdFxcdGRhdGEuc2lnQnl0ZXMgKz0gYmxvY2tTaXplQnl0ZXMgLSAoZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzIHx8IGJsb2NrU2l6ZUJ5dGVzKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xcblxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0dmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XFxuXFxuXFx0XFx0XFx0Ly8gVW5wYWRcXG5cXHRcXHRcXHR2YXIgaSA9IGRhdGEuc2lnQnl0ZXMgLSAxO1xcblxcdFxcdFxcdHdoaWxlICghKGRhdGFXb3Jkc1tpID4+PiAyXSA+Pj4gMjQgLSBpICUgNCAqIDggJiAweGZmKSkge1xcblxcdFxcdFxcdFxcdGktLTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZGF0YS5zaWdCeXRlcyA9IGkgKyAxO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmc7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC16ZXJvcGFkZGluZy5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3Bia2RmMi5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGJrZGYyLmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zaGExICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2htYWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0dmFyIEMgPSBDcnlwdG9KUztcXG5cXHRcXHR2YXIgQ19saWIgPSBDLmxpYjtcXG5cXHRcXHR2YXIgQmFzZSA9IENfbGliLkJhc2U7XFxuXFx0XFx0dmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcXG5cXHRcXHR2YXIgQ19hbGdvID0gQy5hbGdvO1xcblxcdFxcdHZhciBTSEExID0gQ19hbGdvLlNIQTE7XFxuXFx0XFx0dmFyIEhNQUMgPSBDX2FsZ28uSE1BQztcXG5cXG5cXHRcXHQvKipcXG4gICAqIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIgYWxnb3JpdGhtLlxcbiAgICovXFxuXFx0XFx0dmFyIFBCS0RGMiA9IENfYWxnby5QQktERjIgPSBCYXNlLmV4dGVuZCh7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxcbiAgICAqXFxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcXG4gICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlLiBEZWZhdWx0OiBTSEExXFxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcXG4gICAgKi9cXG5cXHRcXHRcXHRjZmc6IEJhc2UuZXh0ZW5kKHtcXG5cXHRcXHRcXHRcXHRrZXlTaXplOiAxMjggLyAzMixcXG5cXHRcXHRcXHRcXHRoYXNoZXI6IFNIQTEsXFxuXFx0XFx0XFx0XFx0aXRlcmF0aW9uczogMVxcblxcdFxcdFxcdH0pLFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoKTtcXG4gICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XFxuICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xcbiAgICAqL1xcblxcdFxcdFxcdGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQ29tcHV0ZXMgdGhlIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cXG4gICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxcbiAgICAqXFxuICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XFxuICAgICovXFxuXFx0XFx0XFx0Y29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgY2ZnID0gdGhpcy5jZmc7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5pdCBITUFDXFxuXFx0XFx0XFx0XFx0dmFyIGhtYWMgPSBITUFDLmNyZWF0ZShjZmcuaGFzaGVyLCBwYXNzd29yZCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5pdGlhbCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHR2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcXG5cXHRcXHRcXHRcXHR2YXIgYmxvY2tJbmRleCA9IFdvcmRBcnJheS5jcmVhdGUoWzB4MDAwMDAwMDFdKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIgYmxvY2tJbmRleFdvcmRzID0gYmxvY2tJbmRleC53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xcblxcdFxcdFxcdFxcdHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2VuZXJhdGUga2V5XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJsb2NrID0gaG1hYy51cGRhdGUoc2FsdCkuZmluYWxpemUoYmxvY2tJbmRleCk7XFxuXFx0XFx0XFx0XFx0XFx0aG1hYy5yZXNldCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdFxcdHZhciBibG9ja1dvcmRzID0gYmxvY2sud29yZHM7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJsb2NrV29yZHNMZW5ndGggPSBibG9ja1dvcmRzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJdGVyYXRpb25zXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGludGVybWVkaWF0ZSA9IGJsb2NrO1xcblxcdFxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJtZWRpYXRlID0gaG1hYy5maW5hbGl6ZShpbnRlcm1lZGlhdGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGhtYWMucmVzZXQoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTaG9ydGN1dFxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbnRlcm1lZGlhdGVXb3JkcyA9IGludGVybWVkaWF0ZS53b3JkcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBYT1IgaW50ZXJtZWRpYXRlIHdpdGggYmxvY2tcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKHZhciBqID0gMDsgaiA8IGJsb2NrV29yZHNMZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsb2NrV29yZHNbal0gXj0gaW50ZXJtZWRpYXRlV29yZHNbal07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XFxuXFx0XFx0XFx0XFx0XFx0YmxvY2tJbmRleFdvcmRzWzBdKys7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGVyaXZlZEtleTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBDb21wdXRlcyB0aGUgUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMi5cXG4gICAqXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXFxuICAgKlxcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQpO1xcbiAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcXG4gICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XFxuICAgKi9cXG5cXHRcXHRDLlBCS0RGMiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XFxuXFx0XFx0XFx0cmV0dXJuIFBCS0RGMi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcXG5cXHRcXHR9O1xcblxcdH0pKCk7XFxuXFxuXFx0cmV0dXJuIENyeXB0b0pTLlBCS0RGMjtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGJrZGYyLmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LWxlZ2FjeS5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC1sZWdhY3kuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lbmMtYmFzZTY0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWJhc2U2NC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21kNSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21kNS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2cGtkZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NpcGhlci1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHR2YXIgQyA9IENyeXB0b0pTO1xcblxcdFxcdHZhciBDX2xpYiA9IEMubGliO1xcblxcdFxcdHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXI7XFxuXFx0XFx0dmFyIENfYWxnbyA9IEMuYWxnbztcXG5cXG5cXHRcXHQvLyBSZXVzYWJsZSBvYmplY3RzXFxuXFx0XFx0dmFyIFMgPSBbXTtcXG5cXHRcXHR2YXIgQ18gPSBbXTtcXG5cXHRcXHR2YXIgRyA9IFtdO1xcblxcblxcdFxcdC8qKlxcbiAgICogUmFiYml0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxcbiAgICpcXG4gICAqIFRoaXMgaXMgYSBsZWdhY3kgdmVyc2lvbiB0aGF0IG5lZ2xlY3RlZCB0byBjb252ZXJ0IHRoZSBrZXkgdG8gbGl0dGxlLWVuZGlhbi5cXG4gICAqIFRoaXMgZXJyb3IgZG9lc24ndCBhZmZlY3QgdGhlIGNpcGhlcidzIHNlY3VyaXR5LFxcbiAgICogYnV0IGl0IGRvZXMgYWZmZWN0IGl0cyBjb21wYXRpYmlsaXR5IHdpdGggb3RoZXIgaW1wbGVtZW50YXRpb25zLlxcbiAgICovXFxuXFx0XFx0dmFyIFJhYmJpdExlZ2FjeSA9IENfYWxnby5SYWJiaXRMZWdhY3kgPSBTdHJlYW1DaXBoZXIuZXh0ZW5kKHtcXG5cXHRcXHRcXHRfZG9SZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBLID0gdGhpcy5fa2V5LndvcmRzO1xcblxcdFxcdFxcdFxcdHZhciBpdiA9IHRoaXMuY2ZnLml2O1xcblxcblxcdFxcdFxcdFxcdC8vIEdlbmVyYXRlIGluaXRpYWwgc3RhdGUgdmFsdWVzXFxuXFx0XFx0XFx0XFx0dmFyIFggPSB0aGlzLl9YID0gW0tbMF0sIEtbM10gPDwgMTYgfCBLWzJdID4+PiAxNiwgS1sxXSwgS1swXSA8PCAxNiB8IEtbM10gPj4+IDE2LCBLWzJdLCBLWzFdIDw8IDE2IHwgS1swXSA+Pj4gMTYsIEtbM10sIEtbMl0gPDwgMTYgfCBLWzFdID4+PiAxNl07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2VuZXJhdGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlc1xcblxcdFxcdFxcdFxcdHZhciBDID0gdGhpcy5fQyA9IFtLWzJdIDw8IDE2IHwgS1syXSA+Pj4gMTYsIEtbMF0gJiAweGZmZmYwMDAwIHwgS1sxXSAmIDB4MDAwMGZmZmYsIEtbM10gPDwgMTYgfCBLWzNdID4+PiAxNiwgS1sxXSAmIDB4ZmZmZjAwMDAgfCBLWzJdICYgMHgwMDAwZmZmZiwgS1swXSA8PCAxNiB8IEtbMF0gPj4+IDE2LCBLWzJdICYgMHhmZmZmMDAwMCB8IEtbM10gJiAweDAwMDBmZmZmLCBLWzFdIDw8IDE2IHwgS1sxXSA+Pj4gMTYsIEtbM10gJiAweGZmZmYwMDAwIHwgS1swXSAmIDB4MDAwMGZmZmZdO1xcblxcblxcdFxcdFxcdFxcdC8vIENhcnJ5IGJpdFxcblxcdFxcdFxcdFxcdHRoaXMuX2IgPSAwO1xcblxcblxcdFxcdFxcdFxcdC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRuZXh0U3RhdGUuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTW9kaWZ5IHRoZSBjb3VudGVyc1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0Q1tpXSBePSBYW2kgKyA0ICYgN107XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElWIHNldHVwXFxuXFx0XFx0XFx0XFx0aWYgKGl2KSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0XFx0dmFyIElWID0gaXYud29yZHM7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIElWXzAgPSBJVlswXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgSVZfMSA9IElWWzFdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEdlbmVyYXRlIGZvdXIgc3VidmVjdG9yc1xcblxcdFxcdFxcdFxcdFxcdHZhciBpMCA9IChJVl8wIDw8IDggfCBJVl8wID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKElWXzAgPDwgMjQgfCBJVl8wID4+PiA4KSAmIDB4ZmYwMGZmMDA7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGkyID0gKElWXzEgPDwgOCB8IElWXzEgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoSVZfMSA8PCAyNCB8IElWXzEgPj4+IDgpICYgMHhmZjAwZmYwMDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaTEgPSBpMCA+Pj4gMTYgfCBpMiAmIDB4ZmZmZjAwMDA7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGkzID0gaTIgPDwgMTYgfCBpMCAmIDB4MDAwMGZmZmY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTW9kaWZ5IGNvdW50ZXIgdmFsdWVzXFxuXFx0XFx0XFx0XFx0XFx0Q1swXSBePSBpMDtcXG5cXHRcXHRcXHRcXHRcXHRDWzFdIF49IGkxO1xcblxcdFxcdFxcdFxcdFxcdENbMl0gXj0gaTI7XFxuXFx0XFx0XFx0XFx0XFx0Q1szXSBePSBpMztcXG5cXHRcXHRcXHRcXHRcXHRDWzRdIF49IGkwO1xcblxcdFxcdFxcdFxcdFxcdENbNV0gXj0gaTE7XFxuXFx0XFx0XFx0XFx0XFx0Q1s2XSBePSBpMjtcXG5cXHRcXHRcXHRcXHRcXHRDWzddIF49IGkzO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXh0U3RhdGUuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgWCA9IHRoaXMuX1g7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSXRlcmF0ZSB0aGUgc3lzdGVtXFxuXFx0XFx0XFx0XFx0bmV4dFN0YXRlLmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2VuZXJhdGUgZm91ciBrZXlzdHJlYW0gd29yZHNcXG5cXHRcXHRcXHRcXHRTWzBdID0gWFswXSBeIFhbNV0gPj4+IDE2IF4gWFszXSA8PCAxNjtcXG5cXHRcXHRcXHRcXHRTWzFdID0gWFsyXSBeIFhbN10gPj4+IDE2IF4gWFs1XSA8PCAxNjtcXG5cXHRcXHRcXHRcXHRTWzJdID0gWFs0XSBeIFhbMV0gPj4+IDE2IF4gWFs3XSA8PCAxNjtcXG5cXHRcXHRcXHRcXHRTWzNdID0gWFs2XSBeIFhbM10gPj4+IDE2IF4gWFsxXSA8PCAxNjtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIFN3YXAgZW5kaWFuXFxuXFx0XFx0XFx0XFx0XFx0U1tpXSA9IChTW2ldIDw8IDggfCBTW2ldID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKFNbaV0gPDwgMjQgfCBTW2ldID4+PiA4KSAmIDB4ZmYwMGZmMDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRW5jcnlwdFxcblxcdFxcdFxcdFxcdFxcdE1bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRibG9ja1NpemU6IDEyOCAvIDMyLFxcblxcblxcdFxcdFxcdGl2U2l6ZTogNjQgLyAzMlxcblxcdFxcdH0pO1xcblxcblxcdFxcdGZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcXG5cXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHR2YXIgWCA9IHRoaXMuX1g7XFxuXFx0XFx0XFx0dmFyIEMgPSB0aGlzLl9DO1xcblxcblxcdFxcdFxcdC8vIFNhdmUgb2xkIGNvdW50ZXIgdmFsdWVzXFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRDX1tpXSA9IENbaV07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENhbGN1bGF0ZSBuZXcgY291bnRlciB2YWx1ZXNcXG5cXHRcXHRcXHRDWzBdID0gQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iIHwgMDtcXG5cXHRcXHRcXHRDWzFdID0gQ1sxXSArIDB4ZDM0ZDM0ZDMgKyAoQ1swXSA+Pj4gMCA8IENfWzBdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzJdID0gQ1syXSArIDB4MzRkMzRkMzQgKyAoQ1sxXSA+Pj4gMCA8IENfWzFdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzNdID0gQ1szXSArIDB4NGQzNGQzNGQgKyAoQ1syXSA+Pj4gMCA8IENfWzJdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzRdID0gQ1s0XSArIDB4ZDM0ZDM0ZDMgKyAoQ1szXSA+Pj4gMCA8IENfWzNdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzVdID0gQ1s1XSArIDB4MzRkMzRkMzQgKyAoQ1s0XSA+Pj4gMCA8IENfWzRdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzZdID0gQ1s2XSArIDB4NGQzNGQzNGQgKyAoQ1s1XSA+Pj4gMCA8IENfWzVdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzddID0gQ1s3XSArIDB4ZDM0ZDM0ZDMgKyAoQ1s2XSA+Pj4gMCA8IENfWzZdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHR0aGlzLl9iID0gQ1s3XSA+Pj4gMCA8IENfWzddID4+PiAwID8gMSA6IDA7XFxuXFxuXFx0XFx0XFx0Ly8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xcblxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGd4ID0gWFtpXSArIENbaV07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcXG5cXHRcXHRcXHRcXHR2YXIgZ2EgPSBneCAmIDB4ZmZmZjtcXG5cXHRcXHRcXHRcXHR2YXIgZ2IgPSBneCA+Pj4gMTY7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcXG5cXHRcXHRcXHRcXHR2YXIgZ2ggPSAoKGdhICogZ2EgPj4+IDE3KSArIGdhICogZ2IgPj4+IDE1KSArIGdiICogZ2I7XFxuXFx0XFx0XFx0XFx0dmFyIGdsID0gKChneCAmIDB4ZmZmZjAwMDApICogZ3ggfCAwKSArICgoZ3ggJiAweDAwMDBmZmZmKSAqIGd4IHwgMCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGlnaCBYT1IgbG93XFxuXFx0XFx0XFx0XFx0R1tpXSA9IGdoIF4gZ2w7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXFxuXFx0XFx0XFx0WFswXSA9IEdbMF0gKyAoR1s3XSA8PCAxNiB8IEdbN10gPj4+IDE2KSArIChHWzZdIDw8IDE2IHwgR1s2XSA+Pj4gMTYpIHwgMDtcXG5cXHRcXHRcXHRYWzFdID0gR1sxXSArIChHWzBdIDw8IDggfCBHWzBdID4+PiAyNCkgKyBHWzddIHwgMDtcXG5cXHRcXHRcXHRYWzJdID0gR1syXSArIChHWzFdIDw8IDE2IHwgR1sxXSA+Pj4gMTYpICsgKEdbMF0gPDwgMTYgfCBHWzBdID4+PiAxNikgfCAwO1xcblxcdFxcdFxcdFhbM10gPSBHWzNdICsgKEdbMl0gPDwgOCB8IEdbMl0gPj4+IDI0KSArIEdbMV0gfCAwO1xcblxcdFxcdFxcdFhbNF0gPSBHWzRdICsgKEdbM10gPDwgMTYgfCBHWzNdID4+PiAxNikgKyAoR1syXSA8PCAxNiB8IEdbMl0gPj4+IDE2KSB8IDA7XFxuXFx0XFx0XFx0WFs1XSA9IEdbNV0gKyAoR1s0XSA8PCA4IHwgR1s0XSA+Pj4gMjQpICsgR1szXSB8IDA7XFxuXFx0XFx0XFx0WFs2XSA9IEdbNl0gKyAoR1s1XSA8PCAxNiB8IEdbNV0gPj4+IDE2KSArIChHWzRdIDw8IDE2IHwgR1s0XSA+Pj4gMTYpIHwgMDtcXG5cXHRcXHRcXHRYWzddID0gR1s3XSArIChHWzZdIDw8IDggfCBHWzZdID4+PiAyNCkgKyBHWzVdIHwgMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXRMZWdhY3kuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XFxuICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXRMZWdhY3kuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XFxuICAgKi9cXG5cXHRcXHRDLlJhYmJpdExlZ2FjeSA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdExlZ2FjeSk7XFxuXFx0fSkoKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMuUmFiYml0TGVnYWN5O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQtbGVnYWN5LmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VuYy1iYXNlNjQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWQ1ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXZwa2RmICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZXZwa2RmLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2lwaGVyLWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlcjtcXG5cXHRcXHR2YXIgQ19hbGdvID0gQy5hbGdvO1xcblxcblxcdFxcdC8vIFJldXNhYmxlIG9iamVjdHNcXG5cXHRcXHR2YXIgUyA9IFtdO1xcblxcdFxcdHZhciBDXyA9IFtdO1xcblxcdFxcdHZhciBHID0gW107XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBSYWJiaXQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG1cXG4gICAqL1xcblxcdFxcdHZhciBSYWJiaXQgPSBDX2FsZ28uUmFiYml0ID0gU3RyZWFtQ2lwaGVyLmV4dGVuZCh7XFxuXFx0XFx0XFx0X2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgSyA9IHRoaXMuX2tleS53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIgaXYgPSB0aGlzLmNmZy5pdjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTd2FwIGVuZGlhblxcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0S1tpXSA9IChLW2ldIDw8IDggfCBLW2ldID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKEtbaV0gPDwgMjQgfCBLW2ldID4+PiA4KSAmIDB4ZmYwMGZmMDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEdlbmVyYXRlIGluaXRpYWwgc3RhdGUgdmFsdWVzXFxuXFx0XFx0XFx0XFx0dmFyIFggPSB0aGlzLl9YID0gW0tbMF0sIEtbM10gPDwgMTYgfCBLWzJdID4+PiAxNiwgS1sxXSwgS1swXSA8PCAxNiB8IEtbM10gPj4+IDE2LCBLWzJdLCBLWzFdIDw8IDE2IHwgS1swXSA+Pj4gMTYsIEtbM10sIEtbMl0gPDwgMTYgfCBLWzFdID4+PiAxNl07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2VuZXJhdGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlc1xcblxcdFxcdFxcdFxcdHZhciBDID0gdGhpcy5fQyA9IFtLWzJdIDw8IDE2IHwgS1syXSA+Pj4gMTYsIEtbMF0gJiAweGZmZmYwMDAwIHwgS1sxXSAmIDB4MDAwMGZmZmYsIEtbM10gPDwgMTYgfCBLWzNdID4+PiAxNiwgS1sxXSAmIDB4ZmZmZjAwMDAgfCBLWzJdICYgMHgwMDAwZmZmZiwgS1swXSA8PCAxNiB8IEtbMF0gPj4+IDE2LCBLWzJdICYgMHhmZmZmMDAwMCB8IEtbM10gJiAweDAwMDBmZmZmLCBLWzFdIDw8IDE2IHwgS1sxXSA+Pj4gMTYsIEtbM10gJiAweGZmZmYwMDAwIHwgS1swXSAmIDB4MDAwMGZmZmZdO1xcblxcblxcdFxcdFxcdFxcdC8vIENhcnJ5IGJpdFxcblxcdFxcdFxcdFxcdHRoaXMuX2IgPSAwO1xcblxcblxcdFxcdFxcdFxcdC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRuZXh0U3RhdGUuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTW9kaWZ5IHRoZSBjb3VudGVyc1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0Q1tpXSBePSBYW2kgKyA0ICYgN107XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElWIHNldHVwXFxuXFx0XFx0XFx0XFx0aWYgKGl2KSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0XFx0dmFyIElWID0gaXYud29yZHM7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIElWXzAgPSBJVlswXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgSVZfMSA9IElWWzFdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEdlbmVyYXRlIGZvdXIgc3VidmVjdG9yc1xcblxcdFxcdFxcdFxcdFxcdHZhciBpMCA9IChJVl8wIDw8IDggfCBJVl8wID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKElWXzAgPDwgMjQgfCBJVl8wID4+PiA4KSAmIDB4ZmYwMGZmMDA7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGkyID0gKElWXzEgPDwgOCB8IElWXzEgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoSVZfMSA8PCAyNCB8IElWXzEgPj4+IDgpICYgMHhmZjAwZmYwMDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaTEgPSBpMCA+Pj4gMTYgfCBpMiAmIDB4ZmZmZjAwMDA7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGkzID0gaTIgPDwgMTYgfCBpMCAmIDB4MDAwMGZmZmY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTW9kaWZ5IGNvdW50ZXIgdmFsdWVzXFxuXFx0XFx0XFx0XFx0XFx0Q1swXSBePSBpMDtcXG5cXHRcXHRcXHRcXHRcXHRDWzFdIF49IGkxO1xcblxcdFxcdFxcdFxcdFxcdENbMl0gXj0gaTI7XFxuXFx0XFx0XFx0XFx0XFx0Q1szXSBePSBpMztcXG5cXHRcXHRcXHRcXHRcXHRDWzRdIF49IGkwO1xcblxcdFxcdFxcdFxcdFxcdENbNV0gXj0gaTE7XFxuXFx0XFx0XFx0XFx0XFx0Q1s2XSBePSBpMjtcXG5cXHRcXHRcXHRcXHRcXHRDWzddIF49IGkzO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXh0U3RhdGUuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgWCA9IHRoaXMuX1g7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSXRlcmF0ZSB0aGUgc3lzdGVtXFxuXFx0XFx0XFx0XFx0bmV4dFN0YXRlLmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2VuZXJhdGUgZm91ciBrZXlzdHJlYW0gd29yZHNcXG5cXHRcXHRcXHRcXHRTWzBdID0gWFswXSBeIFhbNV0gPj4+IDE2IF4gWFszXSA8PCAxNjtcXG5cXHRcXHRcXHRcXHRTWzFdID0gWFsyXSBeIFhbN10gPj4+IDE2IF4gWFs1XSA8PCAxNjtcXG5cXHRcXHRcXHRcXHRTWzJdID0gWFs0XSBeIFhbMV0gPj4+IDE2IF4gWFs3XSA8PCAxNjtcXG5cXHRcXHRcXHRcXHRTWzNdID0gWFs2XSBeIFhbM10gPj4+IDE2IF4gWFsxXSA8PCAxNjtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIFN3YXAgZW5kaWFuXFxuXFx0XFx0XFx0XFx0XFx0U1tpXSA9IChTW2ldIDw8IDggfCBTW2ldID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKFNbaV0gPDwgMjQgfCBTW2ldID4+PiA4KSAmIDB4ZmYwMGZmMDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRW5jcnlwdFxcblxcdFxcdFxcdFxcdFxcdE1bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRibG9ja1NpemU6IDEyOCAvIDMyLFxcblxcblxcdFxcdFxcdGl2U2l6ZTogNjQgLyAzMlxcblxcdFxcdH0pO1xcblxcblxcdFxcdGZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcXG5cXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHR2YXIgWCA9IHRoaXMuX1g7XFxuXFx0XFx0XFx0dmFyIEMgPSB0aGlzLl9DO1xcblxcblxcdFxcdFxcdC8vIFNhdmUgb2xkIGNvdW50ZXIgdmFsdWVzXFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRDX1tpXSA9IENbaV07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENhbGN1bGF0ZSBuZXcgY291bnRlciB2YWx1ZXNcXG5cXHRcXHRcXHRDWzBdID0gQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iIHwgMDtcXG5cXHRcXHRcXHRDWzFdID0gQ1sxXSArIDB4ZDM0ZDM0ZDMgKyAoQ1swXSA+Pj4gMCA8IENfWzBdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzJdID0gQ1syXSArIDB4MzRkMzRkMzQgKyAoQ1sxXSA+Pj4gMCA8IENfWzFdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzNdID0gQ1szXSArIDB4NGQzNGQzNGQgKyAoQ1syXSA+Pj4gMCA8IENfWzJdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzRdID0gQ1s0XSArIDB4ZDM0ZDM0ZDMgKyAoQ1szXSA+Pj4gMCA8IENfWzNdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzVdID0gQ1s1XSArIDB4MzRkMzRkMzQgKyAoQ1s0XSA+Pj4gMCA8IENfWzRdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzZdID0gQ1s2XSArIDB4NGQzNGQzNGQgKyAoQ1s1XSA+Pj4gMCA8IENfWzVdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRDWzddID0gQ1s3XSArIDB4ZDM0ZDM0ZDMgKyAoQ1s2XSA+Pj4gMCA8IENfWzZdID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHR0aGlzLl9iID0gQ1s3XSA+Pj4gMCA8IENfWzddID4+PiAwID8gMSA6IDA7XFxuXFxuXFx0XFx0XFx0Ly8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xcblxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGd4ID0gWFtpXSArIENbaV07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcXG5cXHRcXHRcXHRcXHR2YXIgZ2EgPSBneCAmIDB4ZmZmZjtcXG5cXHRcXHRcXHRcXHR2YXIgZ2IgPSBneCA+Pj4gMTY7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcXG5cXHRcXHRcXHRcXHR2YXIgZ2ggPSAoKGdhICogZ2EgPj4+IDE3KSArIGdhICogZ2IgPj4+IDE1KSArIGdiICogZ2I7XFxuXFx0XFx0XFx0XFx0dmFyIGdsID0gKChneCAmIDB4ZmZmZjAwMDApICogZ3ggfCAwKSArICgoZ3ggJiAweDAwMDBmZmZmKSAqIGd4IHwgMCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGlnaCBYT1IgbG93XFxuXFx0XFx0XFx0XFx0R1tpXSA9IGdoIF4gZ2w7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXFxuXFx0XFx0XFx0WFswXSA9IEdbMF0gKyAoR1s3XSA8PCAxNiB8IEdbN10gPj4+IDE2KSArIChHWzZdIDw8IDE2IHwgR1s2XSA+Pj4gMTYpIHwgMDtcXG5cXHRcXHRcXHRYWzFdID0gR1sxXSArIChHWzBdIDw8IDggfCBHWzBdID4+PiAyNCkgKyBHWzddIHwgMDtcXG5cXHRcXHRcXHRYWzJdID0gR1syXSArIChHWzFdIDw8IDE2IHwgR1sxXSA+Pj4gMTYpICsgKEdbMF0gPDwgMTYgfCBHWzBdID4+PiAxNikgfCAwO1xcblxcdFxcdFxcdFhbM10gPSBHWzNdICsgKEdbMl0gPDwgOCB8IEdbMl0gPj4+IDI0KSArIEdbMV0gfCAwO1xcblxcdFxcdFxcdFhbNF0gPSBHWzRdICsgKEdbM10gPDwgMTYgfCBHWzNdID4+PiAxNikgKyAoR1syXSA8PCAxNiB8IEdbMl0gPj4+IDE2KSB8IDA7XFxuXFx0XFx0XFx0WFs1XSA9IEdbNV0gKyAoR1s0XSA8PCA4IHwgR1s0XSA+Pj4gMjQpICsgR1szXSB8IDA7XFxuXFx0XFx0XFx0WFs2XSA9IEdbNl0gKyAoR1s1XSA8PCAxNiB8IEdbNV0gPj4+IDE2KSArIChHWzRdIDw8IDE2IHwgR1s0XSA+Pj4gMTYpIHwgMDtcXG5cXHRcXHRcXHRYWzddID0gR1s3XSArIChHWzZdIDw8IDggfCBHWzZdID4+PiAyNCkgKyBHWzVdIHwgMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXQuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XFxuICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXQuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XFxuICAgKi9cXG5cXHRcXHRDLlJhYmJpdCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdCk7XFxuXFx0fSkoKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMuUmFiYml0O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYzQuanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JjNC5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW5jLWJhc2U2NCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZDUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldnBrZGYgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jaXBoZXItY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0dmFyIEMgPSBDcnlwdG9KUztcXG5cXHRcXHR2YXIgQ19saWIgPSBDLmxpYjtcXG5cXHRcXHR2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyO1xcblxcdFxcdHZhciBDX2FsZ28gPSBDLmFsZ287XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBSQzQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXFxuICAgKi9cXG5cXHRcXHR2YXIgUkM0ID0gQ19hbGdvLlJDNCA9IFN0cmVhbUNpcGhlci5leHRlbmQoe1xcblxcdFxcdFxcdF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIGtleSA9IHRoaXMuX2tleTtcXG5cXHRcXHRcXHRcXHR2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XFxuXFx0XFx0XFx0XFx0dmFyIGtleVNpZ0J5dGVzID0ga2V5LnNpZ0J5dGVzO1xcblxcblxcdFxcdFxcdFxcdC8vIEluaXQgc2JveFxcblxcdFxcdFxcdFxcdHZhciBTID0gdGhpcy5fUyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRTW2ldID0gaTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2V5IHNldHVwXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgMjU2OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIga2V5Qnl0ZUluZGV4ID0gaSAlIGtleVNpZ0J5dGVzO1xcblxcdFxcdFxcdFxcdFxcdHZhciBrZXlCeXRlID0ga2V5V29yZHNba2V5Qnl0ZUluZGV4ID4+PiAyXSA+Pj4gMjQgLSBrZXlCeXRlSW5kZXggJSA0ICogOCAmIDB4ZmY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aiA9IChqICsgU1tpXSArIGtleUJ5dGUpICUgMjU2O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN3YXBcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdCA9IFNbaV07XFxuXFx0XFx0XFx0XFx0XFx0U1tpXSA9IFNbal07XFxuXFx0XFx0XFx0XFx0XFx0U1tqXSA9IHQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENvdW50ZXJzXFxuXFx0XFx0XFx0XFx0dGhpcy5faSA9IHRoaXMuX2ogPSAwO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0TVtvZmZzZXRdIF49IGdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0a2V5U2l6ZTogMjU2IC8gMzIsXFxuXFxuXFx0XFx0XFx0aXZTaXplOiAwXFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkKCkge1xcblxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdHZhciBTID0gdGhpcy5fUztcXG5cXHRcXHRcXHR2YXIgaSA9IHRoaXMuX2k7XFxuXFx0XFx0XFx0dmFyIGogPSB0aGlzLl9qO1xcblxcblxcdFxcdFxcdC8vIEdlbmVyYXRlIGtleXN0cmVhbSB3b3JkXFxuXFx0XFx0XFx0dmFyIGtleXN0cmVhbVdvcmQgPSAwO1xcblxcdFxcdFxcdGZvciAodmFyIG4gPSAwOyBuIDwgNDsgbisrKSB7XFxuXFx0XFx0XFx0XFx0aSA9IChpICsgMSkgJSAyNTY7XFxuXFx0XFx0XFx0XFx0aiA9IChqICsgU1tpXSkgJSAyNTY7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3dhcFxcblxcdFxcdFxcdFxcdHZhciB0ID0gU1tpXTtcXG5cXHRcXHRcXHRcXHRTW2ldID0gU1tqXTtcXG5cXHRcXHRcXHRcXHRTW2pdID0gdDtcXG5cXG5cXHRcXHRcXHRcXHRrZXlzdHJlYW1Xb3JkIHw9IFNbKFNbaV0gKyBTW2pdKSAlIDI1Nl0gPDwgMjQgLSBuICogODtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVXBkYXRlIGNvdW50ZXJzXFxuXFx0XFx0XFx0dGhpcy5faSA9IGk7XFxuXFx0XFx0XFx0dGhpcy5faiA9IGo7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGtleXN0cmVhbVdvcmQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8qKlxcbiAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xcbiAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUkM0LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xcbiAgICovXFxuXFx0XFx0Qy5SQzQgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzQpO1xcblxcblxcdFxcdC8qKlxcbiAgICogTW9kaWZpZWQgUkM0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxcbiAgICovXFxuXFx0XFx0dmFyIFJDNERyb3AgPSBDX2FsZ28uUkM0RHJvcCA9IFJDNC5leHRlbmQoe1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cXG4gICAgKlxcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcm9wIFRoZSBudW1iZXIgb2Yga2V5c3RyZWFtIHdvcmRzIHRvIGRyb3AuIERlZmF1bHQgMTkyXFxuICAgICovXFxuXFx0XFx0XFx0Y2ZnOiBSQzQuY2ZnLmV4dGVuZCh7XFxuXFx0XFx0XFx0XFx0ZHJvcDogMTkyXFxuXFx0XFx0XFx0fSksXFxuXFxuXFx0XFx0XFx0X2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRSQzQuX2RvUmVzZXQuY2FsbCh0aGlzKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEcm9wXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IHRoaXMuY2ZnLmRyb3A7IGkgPiAwOyBpLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRnZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0RHJvcC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcXG4gICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJDNERyb3AuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XFxuICAgKi9cXG5cXHRcXHRDLlJDNERyb3AgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzREcm9wKTtcXG5cXHR9KSgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5SQzQ7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JjNC5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JpcGVtZDE2MC5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmlwZW1kMTYwLmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQvKiogQHByZXNlcnZlXFxuIChjKSAyMDEyIGJ5IEPDqWRyaWMgTWVzbmlsLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiBcXHRSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XFxuIFxcdCAgICAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cXG4gICAgIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcbiBcXHRUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFxcXCJBUyBJU1xcXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcbiAqL1xcblxcblxcdChmdW5jdGlvbiAoTWF0aCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcXG5cXHRcXHR2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xcblxcdFxcdHZhciBDX2FsZ28gPSBDLmFsZ287XFxuXFxuXFx0XFx0Ly8gQ29uc3RhbnRzIHRhYmxlXFxuXFx0XFx0dmFyIF96bCA9IFdvcmRBcnJheS5jcmVhdGUoWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNdKTtcXG5cXHRcXHR2YXIgX3pyID0gV29yZEFycmF5LmNyZWF0ZShbNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMiwgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMiwgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMywgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCwgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMV0pO1xcblxcdFxcdHZhciBfc2wgPSBXb3JkQXJyYXkuY3JlYXRlKFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMiwgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LCAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNl0pO1xcblxcdFxcdHZhciBfc3IgPSBXb3JkQXJyYXkuY3JlYXRlKFs4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSwgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LCAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMV0pO1xcblxcblxcdFxcdHZhciBfaGwgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXSk7XFxuXFx0XFx0dmFyIF9ociA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTBBMjhCRTYsIDB4NUM0REQxMjQsIDB4NkQ3MDNFRjMsIDB4N0E2RDc2RTksIDB4MDAwMDAwMDBdKTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFJJUEVNRDE2MCBoYXNoIGFsZ29yaXRobS5cXG4gICAqL1xcblxcdFxcdHZhciBSSVBFTUQxNjAgPSBDX2FsZ28uUklQRU1EMTYwID0gSGFzaGVyLmV4dGVuZCh7XFxuXFx0XFx0XFx0X2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9oYXNoID0gV29yZEFycmF5LmNyZWF0ZShbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3NiwgMHhDM0QyRTFGMF0pO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3dhcCBlbmRpYW5cXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xcblxcdFxcdFxcdFxcdFxcdHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3dhcFxcblxcdFxcdFxcdFxcdFxcdE1bb2Zmc2V0X2ldID0gKE1fb2Zmc2V0X2kgPDwgOCB8IE1fb2Zmc2V0X2kgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoTV9vZmZzZXRfaSA8PCAyNCB8IE1fb2Zmc2V0X2kgPj4+IDgpICYgMHhmZjAwZmYwMDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XFxuXFx0XFx0XFx0XFx0dmFyIGhsID0gX2hsLndvcmRzO1xcblxcdFxcdFxcdFxcdHZhciBociA9IF9oci53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIgemwgPSBfemwud29yZHM7XFxuXFx0XFx0XFx0XFx0dmFyIHpyID0gX3pyLndvcmRzO1xcblxcdFxcdFxcdFxcdHZhciBzbCA9IF9zbC53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIgc3IgPSBfc3Iud29yZHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV29ya2luZyB2YXJpYWJsZXNcXG5cXHRcXHRcXHRcXHR2YXIgYWwsIGJsLCBjbCwgZGwsIGVsO1xcblxcdFxcdFxcdFxcdHZhciBhciwgYnIsIGNyLCBkciwgZXI7XFxuXFxuXFx0XFx0XFx0XFx0YXIgPSBhbCA9IEhbMF07XFxuXFx0XFx0XFx0XFx0YnIgPSBibCA9IEhbMV07XFxuXFx0XFx0XFx0XFx0Y3IgPSBjbCA9IEhbMl07XFxuXFx0XFx0XFx0XFx0ZHIgPSBkbCA9IEhbM107XFxuXFx0XFx0XFx0XFx0ZXIgPSBlbCA9IEhbNF07XFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0YXRpb25cXG5cXHRcXHRcXHRcXHR2YXIgdDtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHR0ID0gYWwgKyBNW29mZnNldCArIHpsW2ldXSB8IDA7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGkgPCAxNikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gZjEoYmwsIGNsLCBkbCkgKyBobFswXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGkgPCAzMikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gZjIoYmwsIGNsLCBkbCkgKyBobFsxXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGkgPCA0OCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gZjMoYmwsIGNsLCBkbCkgKyBobFsyXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGkgPCA2NCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gZjQoYmwsIGNsLCBkbCkgKyBobFszXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGlmIChpPDgwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dCArPSBmNShibCwgY2wsIGRsKSArIGhsWzRdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0ID0gdCB8IDA7XFxuXFx0XFx0XFx0XFx0XFx0dCA9IHJvdGwodCwgc2xbaV0pO1xcblxcdFxcdFxcdFxcdFxcdHQgPSB0ICsgZWwgfCAwO1xcblxcdFxcdFxcdFxcdFxcdGFsID0gZWw7XFxuXFx0XFx0XFx0XFx0XFx0ZWwgPSBkbDtcXG5cXHRcXHRcXHRcXHRcXHRkbCA9IHJvdGwoY2wsIDEwKTtcXG5cXHRcXHRcXHRcXHRcXHRjbCA9IGJsO1xcblxcdFxcdFxcdFxcdFxcdGJsID0gdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ID0gYXIgKyBNW29mZnNldCArIHpyW2ldXSB8IDA7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGkgPCAxNikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gZjUoYnIsIGNyLCBkcikgKyBoclswXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGkgPCAzMikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gZjQoYnIsIGNyLCBkcikgKyBoclsxXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGkgPCA0OCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gZjMoYnIsIGNyLCBkcikgKyBoclsyXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGkgPCA2NCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gZjIoYnIsIGNyLCBkcikgKyBoclszXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGlmIChpPDgwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dCArPSBmMShiciwgY3IsIGRyKSArIGhyWzRdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0ID0gdCB8IDA7XFxuXFx0XFx0XFx0XFx0XFx0dCA9IHJvdGwodCwgc3JbaV0pO1xcblxcdFxcdFxcdFxcdFxcdHQgPSB0ICsgZXIgfCAwO1xcblxcdFxcdFxcdFxcdFxcdGFyID0gZXI7XFxuXFx0XFx0XFx0XFx0XFx0ZXIgPSBkcjtcXG5cXHRcXHRcXHRcXHRcXHRkciA9IHJvdGwoY3IsIDEwKTtcXG5cXHRcXHRcXHRcXHRcXHRjciA9IGJyO1xcblxcdFxcdFxcdFxcdFxcdGJyID0gdDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcXG5cXHRcXHRcXHRcXHR0ID0gSFsxXSArIGNsICsgZHIgfCAwO1xcblxcdFxcdFxcdFxcdEhbMV0gPSBIWzJdICsgZGwgKyBlciB8IDA7XFxuXFx0XFx0XFx0XFx0SFsyXSA9IEhbM10gKyBlbCArIGFyIHwgMDtcXG5cXHRcXHRcXHRcXHRIWzNdID0gSFs0XSArIGFsICsgYnIgfCAwO1xcblxcdFxcdFxcdFxcdEhbNF0gPSBIWzBdICsgYmwgKyBjciB8IDA7XFxuXFx0XFx0XFx0XFx0SFswXSA9IHQ7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBkYXRhID0gdGhpcy5fZGF0YTtcXG5cXHRcXHRcXHRcXHR2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xcblxcdFxcdFxcdFxcdHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgcGFkZGluZ1xcblxcdFxcdFxcdFxcdGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgMjQgLSBuQml0c0xlZnQgJSAzMjtcXG5cXHRcXHRcXHRcXHRkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gKG5CaXRzVG90YWwgPDwgOCB8IG5CaXRzVG90YWwgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAobkJpdHNUb3RhbCA8PCAyNCB8IG5CaXRzVG90YWwgPj4+IDgpICYgMHhmZjAwZmYwMDtcXG5cXHRcXHRcXHRcXHRkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFzaCBmaW5hbCBibG9ja3NcXG5cXHRcXHRcXHRcXHR0aGlzLl9wcm9jZXNzKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xcblxcdFxcdFxcdFxcdHZhciBIID0gaGFzaC53b3JkcztcXG5cXG5cXHRcXHRcXHRcXHQvLyBTd2FwIGVuZGlhblxcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHRcXHR2YXIgSF9pID0gSFtpXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTd2FwXFxuXFx0XFx0XFx0XFx0XFx0SFtpXSA9IChIX2kgPDwgOCB8IEhfaSA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChIX2kgPDwgMjQgfCBIX2kgPj4+IDgpICYgMHhmZjAwZmYwMDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaGFzaDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0XFx0Y2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsb25lO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBmMSh4LCB5LCB6KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHggXiB5IF4gejtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZjIoeCwgeSwgeikge1xcblxcdFxcdFxcdHJldHVybiB4ICYgeSB8IH54ICYgejtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZjMoeCwgeSwgeikge1xcblxcdFxcdFxcdHJldHVybiAoeCB8IH55KSBeIHo7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGY0KHgsIHksIHopIHtcXG5cXHRcXHRcXHRyZXR1cm4geCAmIHogfCB5ICYgfno7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGY1KHgsIHksIHopIHtcXG5cXHRcXHRcXHRyZXR1cm4geCBeICh5IHwgfnopO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByb3RsKHgsIG4pIHtcXG5cXHRcXHRcXHRyZXR1cm4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvKipcXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuUklQRU1EMTYwKCdtZXNzYWdlJyk7XFxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5SSVBFTUQxNjAod29yZEFycmF5KTtcXG4gICAqL1xcblxcdFxcdEMuUklQRU1EMTYwID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoUklQRU1EMTYwKTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1JJUEVNRDE2MChtZXNzYWdlLCBrZXkpO1xcbiAgICovXFxuXFx0XFx0Qy5IbWFjUklQRU1EMTYwID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFJJUEVNRDE2MCk7XFxuXFx0fSkoTWF0aCk7XFxuXFxuXFx0cmV0dXJuIENyeXB0b0pTLlJJUEVNRDE2MDtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmlwZW1kMTYwLmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMS5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcXG5cXHRcXHR2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xcblxcdFxcdHZhciBDX2FsZ28gPSBDLmFsZ287XFxuXFxuXFx0XFx0Ly8gUmV1c2FibGUgb2JqZWN0XFxuXFx0XFx0dmFyIFcgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNIQS0xIGhhc2ggYWxnb3JpdGhtLlxcbiAgICovXFxuXFx0XFx0dmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xcblxcdFxcdFxcdF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF0pO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV29ya2luZyB2YXJpYWJsZXNcXG5cXHRcXHRcXHRcXHR2YXIgYSA9IEhbMF07XFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBIWzFdO1xcblxcdFxcdFxcdFxcdHZhciBjID0gSFsyXTtcXG5cXHRcXHRcXHRcXHR2YXIgZCA9IEhbM107XFxuXFx0XFx0XFx0XFx0dmFyIGUgPSBIWzRdO1xcblxcblxcdFxcdFxcdFxcdC8vIENvbXB1dGF0aW9uXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGkgPCAxNikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBuID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRXW2ldID0gbiA8PCAxIHwgbiA+Pj4gMzE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0ID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGUgKyBXW2ldO1xcblxcdFxcdFxcdFxcdFxcdGlmIChpIDwgMjApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ICs9IChiICYgYyB8IH5iICYgZCkgKyAweDVhODI3OTk5O1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoaSA8IDQwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChpIDwgNjApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ICs9IChiICYgYyB8IGIgJiBkIHwgYyAmIGQpIC0gMHg3MGU0NDMyNDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgLyogaWYgKGkgPCA4MCkgKi97XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dCArPSAoYiBeIGMgXiBkKSAtIDB4MzU5ZDNlMmE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGUgPSBkO1xcblxcdFxcdFxcdFxcdFxcdGQgPSBjO1xcblxcdFxcdFxcdFxcdFxcdGMgPSBiIDw8IDMwIHwgYiA+Pj4gMjtcXG5cXHRcXHRcXHRcXHRcXHRiID0gYTtcXG5cXHRcXHRcXHRcXHRcXHRhID0gdDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcXG5cXHRcXHRcXHRcXHRIWzBdID0gSFswXSArIGEgfCAwO1xcblxcdFxcdFxcdFxcdEhbMV0gPSBIWzFdICsgYiB8IDA7XFxuXFx0XFx0XFx0XFx0SFsyXSA9IEhbMl0gKyBjIHwgMDtcXG5cXHRcXHRcXHRcXHRIWzNdID0gSFszXSArIGQgfCAwO1xcblxcdFxcdFxcdFxcdEhbNF0gPSBIWzRdICsgZSB8IDA7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBkYXRhID0gdGhpcy5fZGF0YTtcXG5cXHRcXHRcXHRcXHR2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xcblxcdFxcdFxcdFxcdHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgcGFkZGluZ1xcblxcdFxcdFxcdFxcdGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgMjQgLSBuQml0c0xlZnQgJSAzMjtcXG5cXHRcXHRcXHRcXHRkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xcblxcdFxcdFxcdFxcdGRhdGFXb3Jkc1sobkJpdHNMZWZ0ICsgNjQgPj4+IDkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xcblxcdFxcdFxcdFxcdGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBIYXNoIGZpbmFsIGJsb2Nrc1xcblxcdFxcdFxcdFxcdHRoaXMuX3Byb2Nlc3MoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl9oYXNoO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2xvbmU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXFxuICAgKlxcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cXG4gICAqXFxuICAgKiBAc3RhdGljXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XFxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XFxuICAgKi9cXG5cXHRcXHRDLlNIQTEgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExKTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcXG4gICAqL1xcblxcdFxcdEMuSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSk7XFxuXFx0fSkoKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMTtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMS5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjI0LmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zaGEyNTYgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHR2YXIgQyA9IENyeXB0b0pTO1xcblxcdFxcdHZhciBDX2xpYiA9IEMubGliO1xcblxcdFxcdHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XFxuXFx0XFx0dmFyIENfYWxnbyA9IEMuYWxnbztcXG5cXHRcXHR2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NjtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNIQS0yMjQgaGFzaCBhbGdvcml0aG0uXFxuICAgKi9cXG5cXHRcXHR2YXIgU0hBMjI0ID0gQ19hbGdvLlNIQTIyNCA9IFNIQTI1Ni5leHRlbmQoe1xcblxcdFxcdFxcdF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSwgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNF0pO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgaGFzaCA9IFNIQTI1Ni5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO1xcblxcblxcdFxcdFxcdFxcdGhhc2guc2lnQnl0ZXMgLT0gNDtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gaGFzaDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cXG4gICAqXFxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxcbiAgICpcXG4gICAqIEBzdGF0aWNcXG4gICAqXFxuICAgKiBAZXhhbXBsZVxcbiAgICpcXG4gICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTIyNCgnbWVzc2FnZScpO1xcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjI0KHdvcmRBcnJheSk7XFxuICAgKi9cXG5cXHRcXHRDLlNIQTIyNCA9IFNIQTI1Ni5fY3JlYXRlSGVscGVyKFNIQTIyNCk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cXG4gICAqXFxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxcbiAgICpcXG4gICAqIEBzdGF0aWNcXG4gICAqXFxuICAgKiBAZXhhbXBsZVxcbiAgICpcXG4gICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEyMjQobWVzc2FnZSwga2V5KTtcXG4gICAqL1xcblxcdFxcdEMuSG1hY1NIQTIyNCA9IFNIQTI1Ni5fY3JlYXRlSG1hY0hlbHBlcihTSEEyMjQpO1xcblxcdH0pKCk7XFxuXFxuXFx0cmV0dXJuIENyeXB0b0pTLlNIQTIyNDtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjI0LmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjU2LmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdChmdW5jdGlvbiAoTWF0aCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcXG5cXHRcXHR2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xcblxcdFxcdHZhciBDX2FsZ28gPSBDLmFsZ287XFxuXFxuXFx0XFx0Ly8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcXG5cXHRcXHR2YXIgSCA9IFtdO1xcblxcdFxcdHZhciBLID0gW107XFxuXFxuXFx0XFx0Ly8gQ29tcHV0ZSBjb25zdGFudHNcXG5cXHRcXHQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGZ1bmN0aW9uIGlzUHJpbWUobikge1xcblxcdFxcdFxcdFxcdHZhciBzcXJ0TiA9IE1hdGguc3FydChuKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCEobiAlIGZhY3RvcikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0RnJhY3Rpb25hbEJpdHMobikge1xcblxcdFxcdFxcdFxcdHJldHVybiAobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDAgfCAwO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgbiA9IDI7XFxuXFx0XFx0XFx0dmFyIG5QcmltZSA9IDA7XFxuXFx0XFx0XFx0d2hpbGUgKG5QcmltZSA8IDY0KSB7XFxuXFx0XFx0XFx0XFx0aWYgKGlzUHJpbWUobikpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoblByaW1lIDwgOCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAzKSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0blByaW1lKys7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdG4rKztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSkoKTtcXG5cXG5cXHRcXHQvLyBSZXVzYWJsZSBvYmplY3RcXG5cXHRcXHR2YXIgVyA9IFtdO1xcblxcblxcdFxcdC8qKlxcbiAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cXG4gICAqL1xcblxcdFxcdHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XFxuXFx0XFx0XFx0X2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRcXG5cXHRcXHRcXHRcXHR2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV29ya2luZyB2YXJpYWJsZXNcXG5cXHRcXHRcXHRcXHR2YXIgYSA9IEhbMF07XFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBIWzFdO1xcblxcdFxcdFxcdFxcdHZhciBjID0gSFsyXTtcXG5cXHRcXHRcXHRcXHR2YXIgZCA9IEhbM107XFxuXFx0XFx0XFx0XFx0dmFyIGUgPSBIWzRdO1xcblxcdFxcdFxcdFxcdHZhciBmID0gSFs1XTtcXG5cXHRcXHRcXHRcXHR2YXIgZyA9IEhbNl07XFxuXFx0XFx0XFx0XFx0dmFyIGggPSBIWzddO1xcblxcblxcdFxcdFxcdFxcdC8vIENvbXB1dGF0aW9uXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGkgPCAxNikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTAgPSAoZ2FtbWEweCA8PCAyNSB8IGdhbW1hMHggPj4+IDcpIF4gKGdhbW1hMHggPDwgMTQgfCBnYW1tYTB4ID4+PiAxOCkgXiBnYW1tYTB4ID4+PiAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdhbW1hMSA9IChnYW1tYTF4IDw8IDE1IHwgZ2FtbWExeCA+Pj4gMTcpIF4gKGdhbW1hMXggPDwgMTMgfCBnYW1tYTF4ID4+PiAxOSkgXiBnYW1tYTF4ID4+PiAxMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjaCA9IGUgJiBmIF4gfmUgJiBnO1xcblxcdFxcdFxcdFxcdFxcdHZhciBtYWogPSBhICYgYiBeIGEgJiBjIF4gYiAmIGM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNpZ21hMCA9IChhIDw8IDMwIHwgYSA+Pj4gMikgXiAoYSA8PCAxOSB8IGEgPj4+IDEzKSBeIChhIDw8IDEwIHwgYSA+Pj4gMjIpO1xcblxcdFxcdFxcdFxcdFxcdHZhciBzaWdtYTEgPSAoZSA8PCAyNiB8IGUgPj4+IDYpIF4gKGUgPDwgMjEgfCBlID4+PiAxMSkgXiAoZSA8PCA3IHwgZSA+Pj4gMjUpO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xcblxcdFxcdFxcdFxcdFxcdHZhciB0MiA9IHNpZ21hMCArIG1hajtcXG5cXG5cXHRcXHRcXHRcXHRcXHRoID0gZztcXG5cXHRcXHRcXHRcXHRcXHRnID0gZjtcXG5cXHRcXHRcXHRcXHRcXHRmID0gZTtcXG5cXHRcXHRcXHRcXHRcXHRlID0gZCArIHQxIHwgMDtcXG5cXHRcXHRcXHRcXHRcXHRkID0gYztcXG5cXHRcXHRcXHRcXHRcXHRjID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRiID0gYTtcXG5cXHRcXHRcXHRcXHRcXHRhID0gdDEgKyB0MiB8IDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXFxuXFx0XFx0XFx0XFx0SFswXSA9IEhbMF0gKyBhIHwgMDtcXG5cXHRcXHRcXHRcXHRIWzFdID0gSFsxXSArIGIgfCAwO1xcblxcdFxcdFxcdFxcdEhbMl0gPSBIWzJdICsgYyB8IDA7XFxuXFx0XFx0XFx0XFx0SFszXSA9IEhbM10gKyBkIHwgMDtcXG5cXHRcXHRcXHRcXHRIWzRdID0gSFs0XSArIGUgfCAwO1xcblxcdFxcdFxcdFxcdEhbNV0gPSBIWzVdICsgZiB8IDA7XFxuXFx0XFx0XFx0XFx0SFs2XSA9IEhbNl0gKyBnIHwgMDtcXG5cXHRcXHRcXHRcXHRIWzddID0gSFs3XSArIGggfCAwO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XFxuXFx0XFx0XFx0XFx0dmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcXG5cXHRcXHRcXHRcXHR2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRkIHBhZGRpbmdcXG5cXHRcXHRcXHRcXHRkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8IDI0IC0gbkJpdHNMZWZ0ICUgMzI7XFxuXFx0XFx0XFx0XFx0ZGF0YVdvcmRzWyhuQml0c0xlZnQgKyA2NCA+Pj4gOSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcXG5cXHRcXHRcXHRcXHRkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcXG5cXHRcXHRcXHRcXHRkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFzaCBmaW5hbCBibG9ja3NcXG5cXHRcXHRcXHRcXHR0aGlzLl9wcm9jZXNzKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5faGFzaDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0XFx0Y2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsb25lO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XFxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcXG4gICAqL1xcblxcdFxcdEMuU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMjU2KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xcbiAgICovXFxuXFx0XFx0Qy5IbWFjU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1Nik7XFxuXFx0fSkoTWF0aCk7XFxuXFxuXFx0cmV0dXJuIENyeXB0b0pTLlNIQTI1NjtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjU2LmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMy5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTMuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi94NjQtY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3g2NC1jb3JlLmpzXFxcIikpO1xcblxcdH0gZWxzZSB7fVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xcblxcblxcdChmdW5jdGlvbiAoTWF0aCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcXG5cXHRcXHR2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xcblxcdFxcdHZhciBDX3g2NCA9IEMueDY0O1xcblxcdFxcdHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcXG5cXHRcXHR2YXIgQ19hbGdvID0gQy5hbGdvO1xcblxcblxcdFxcdC8vIENvbnN0YW50cyB0YWJsZXNcXG5cXHRcXHR2YXIgUkhPX09GRlNFVFMgPSBbXTtcXG5cXHRcXHR2YXIgUElfSU5ERVhFUyA9IFtdO1xcblxcdFxcdHZhciBST1VORF9DT05TVEFOVFMgPSBbXTtcXG5cXG5cXHRcXHQvLyBDb21wdXRlIENvbnN0YW50c1xcblxcdFxcdChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0Ly8gQ29tcHV0ZSByaG8gb2Zmc2V0IGNvbnN0YW50c1xcblxcdFxcdFxcdHZhciB4ID0gMSxcXG5cXHRcXHRcXHQgICAgeSA9IDA7XFxuXFx0XFx0XFx0Zm9yICh2YXIgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XFxuXFx0XFx0XFx0XFx0UkhPX09GRlNFVFNbeCArIDUgKiB5XSA9ICh0ICsgMSkgKiAodCArIDIpIC8gMiAlIDY0O1xcblxcblxcdFxcdFxcdFxcdHZhciBuZXdYID0geSAlIDU7XFxuXFx0XFx0XFx0XFx0dmFyIG5ld1kgPSAoMiAqIHggKyAzICogeSkgJSA1O1xcblxcdFxcdFxcdFxcdHggPSBuZXdYO1xcblxcdFxcdFxcdFxcdHkgPSBuZXdZO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb21wdXRlIHBpIGluZGV4IGNvbnN0YW50c1xcblxcdFxcdFxcdGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcXG5cXHRcXHRcXHRcXHRcXHRQSV9JTkRFWEVTW3ggKyA1ICogeV0gPSB5ICsgKDIgKiB4ICsgMyAqIHkpICUgNSAqIDU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb21wdXRlIHJvdW5kIGNvbnN0YW50c1xcblxcdFxcdFxcdHZhciBMRlNSID0gMHgwMTtcXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHR2YXIgcm91bmRDb25zdGFudE1zdyA9IDA7XFxuXFx0XFx0XFx0XFx0dmFyIHJvdW5kQ29uc3RhbnRMc3cgPSAwO1xcblxcblxcdFxcdFxcdFxcdGZvciAodmFyIGogPSAwOyBqIDwgNzsgaisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKExGU1IgJiAweDAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJpdFBvc2l0aW9uID0gKDEgPDwgaikgLSAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChiaXRQb3NpdGlvbiA8IDMyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cm91bmRDb25zdGFudExzdyBePSAxIDw8IGJpdFBvc2l0aW9uO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSAvKiBpZiAoYml0UG9zaXRpb24gPj0gMzIpICove1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJvdW5kQ29uc3RhbnRNc3cgXj0gMSA8PCBiaXRQb3NpdGlvbiAtIDMyO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ29tcHV0ZSBuZXh0IExGU1JcXG5cXHRcXHRcXHRcXHRcXHRpZiAoTEZTUiAmIDB4ODApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBQcmltaXRpdmUgcG9seW5vbWlhbCBvdmVyIEdGKDIpOiB4XjggKyB4XjYgKyB4XjUgKyB4XjQgKyAxXFxuXFx0XFx0XFx0XFx0XFx0XFx0TEZTUiA9IExGU1IgPDwgMSBeIDB4NzE7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRMRlNSIDw8PSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Uk9VTkRfQ09OU1RBTlRTW2ldID0gWDY0V29yZC5jcmVhdGUocm91bmRDb25zdGFudE1zdywgcm91bmRDb25zdGFudExzdyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pKCk7XFxuXFxuXFx0XFx0Ly8gUmV1c2FibGUgb2JqZWN0cyBmb3IgdGVtcG9yYXJ5IHZhbHVlc1xcblxcdFxcdHZhciBUID0gW107XFxuXFx0XFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRUW2ldID0gWDY0V29yZC5jcmVhdGUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSkoKTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNIQS0zIGhhc2ggYWxnb3JpdGhtLlxcbiAgICovXFxuXFx0XFx0dmFyIFNIQTMgPSBDX2FsZ28uU0hBMyA9IEhhc2hlci5leHRlbmQoe1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cXG4gICAgKlxcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvdXRwdXRMZW5ndGhcXG4gICAgKiAgIFRoZSBkZXNpcmVkIG51bWJlciBvZiBiaXRzIGluIHRoZSBvdXRwdXQgaGFzaC5cXG4gICAgKiAgIE9ubHkgdmFsdWVzIHBlcm1pdHRlZCBhcmU6IDIyNCwgMjU2LCAzODQsIDUxMi5cXG4gICAgKiAgIERlZmF1bHQ6IDUxMlxcbiAgICAqL1xcblxcdFxcdFxcdGNmZzogSGFzaGVyLmNmZy5leHRlbmQoe1xcblxcdFxcdFxcdFxcdG91dHB1dExlbmd0aDogNTEyXFxuXFx0XFx0XFx0fSksXFxuXFxuXFx0XFx0XFx0X2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZSA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlW2ldID0gbmV3IFg2NFdvcmQuaW5pdCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJsb2NrU2l6ZSA9ICgxNjAwIC0gMiAqIHRoaXMuY2ZnLm91dHB1dExlbmd0aCkgLyAzMjtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xcblxcdFxcdFxcdFxcdHZhciBuQmxvY2tTaXplTGFuZXMgPSB0aGlzLmJsb2NrU2l6ZSAvIDI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWJzb3JiXFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuQmxvY2tTaXplTGFuZXM7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdFxcdHZhciBNMmkgPSBNW29mZnNldCArIDIgKiBpXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgTTJpMSA9IE1bb2Zmc2V0ICsgMiAqIGkgKyAxXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTd2FwIGVuZGlhblxcblxcdFxcdFxcdFxcdFxcdE0yaSA9IChNMmkgPDwgOCB8IE0yaSA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChNMmkgPDwgMjQgfCBNMmkgPj4+IDgpICYgMHhmZjAwZmYwMDtcXG5cXHRcXHRcXHRcXHRcXHRNMmkxID0gKE0yaTEgPDwgOCB8IE0yaTEgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoTTJpMSA8PCAyNCB8IE0yaTEgPj4+IDgpICYgMHhmZjAwZmYwMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBBYnNvcmIgbWVzc2FnZSBpbnRvIHN0YXRlXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxhbmUgPSBzdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRsYW5lLmhpZ2ggXj0gTTJpMTtcXG5cXHRcXHRcXHRcXHRcXHRsYW5lLmxvdyBePSBNMmk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJvdW5kc1xcblxcdFxcdFxcdFxcdGZvciAodmFyIHJvdW5kID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRoZXRhXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBNaXggY29sdW1uIGxhbmVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRNc3cgPSAwLFxcblxcdFxcdFxcdFxcdFxcdFxcdCAgICB0THN3ID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBsYW5lID0gc3RhdGVbeCArIDUgKiB5XTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0TXN3IF49IGxhbmUuaGlnaDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0THN3IF49IGxhbmUubG93O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBUZW1wb3JhcnkgdmFsdWVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFR4ID0gVFt4XTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRUeC5oaWdoID0gdE1zdztcXG5cXHRcXHRcXHRcXHRcXHRcXHRUeC5sb3cgPSB0THN3O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBUeDQgPSBUWyh4ICsgNCkgJSA1XTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgVHgxID0gVFsoeCArIDEpICUgNV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFR4MU1zdyA9IFR4MS5oaWdoO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBUeDFMc3cgPSBUeDEubG93O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIE1peCBzdXJyb3VuZGluZyBjb2x1bW5zXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRNc3cgPSBUeDQuaGlnaCBeIChUeDFNc3cgPDwgMSB8IFR4MUxzdyA+Pj4gMzEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB0THN3ID0gVHg0LmxvdyBeIChUeDFMc3cgPDwgMSB8IFR4MU1zdyA+Pj4gMzEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGxhbmUgPSBzdGF0ZVt4ICsgNSAqIHldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhbmUuaGlnaCBePSB0TXN3O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhbmUubG93IF49IHRMc3c7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSaG8gUGlcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHZhciBsYW5lSW5kZXggPSAxOyBsYW5lSW5kZXggPCAyNTsgbGFuZUluZGV4KyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbGFuZSA9IHN0YXRlW2xhbmVJbmRleF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGxhbmVNc3cgPSBsYW5lLmhpZ2g7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGxhbmVMc3cgPSBsYW5lLmxvdztcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmhvT2Zmc2V0ID0gUkhPX09GRlNFVFNbbGFuZUluZGV4XTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBSb3RhdGUgbGFuZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocmhvT2Zmc2V0IDwgMzIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdE1zdyA9IGxhbmVNc3cgPDwgcmhvT2Zmc2V0IHwgbGFuZUxzdyA+Pj4gMzIgLSByaG9PZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRMc3cgPSBsYW5lTHN3IDw8IHJob09mZnNldCB8IGxhbmVNc3cgPj4+IDMyIC0gcmhvT2Zmc2V0O1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSAvKiBpZiAocmhvT2Zmc2V0ID49IDMyKSAqL3tcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdE1zdyA9IGxhbmVMc3cgPDwgcmhvT2Zmc2V0IC0gMzIgfCBsYW5lTXN3ID4+PiA2NCAtIHJob09mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdExzdyA9IGxhbmVNc3cgPDwgcmhvT2Zmc2V0IC0gMzIgfCBsYW5lTHN3ID4+PiA2NCAtIHJob09mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gVHJhbnNwb3NlIGxhbmVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFRQaUxhbmUgPSBUW1BJX0lOREVYRVNbbGFuZUluZGV4XV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0VFBpTGFuZS5oaWdoID0gdE1zdztcXG5cXHRcXHRcXHRcXHRcXHRcXHRUUGlMYW5lLmxvdyA9IHRMc3c7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJobyBwaSBhdCB4ID0geSA9IDBcXG5cXHRcXHRcXHRcXHRcXHR2YXIgVDAgPSBUWzBdO1xcblxcdFxcdFxcdFxcdFxcdHZhciBzdGF0ZTAgPSBzdGF0ZVswXTtcXG5cXHRcXHRcXHRcXHRcXHRUMC5oaWdoID0gc3RhdGUwLmhpZ2g7XFxuXFx0XFx0XFx0XFx0XFx0VDAubG93ID0gc3RhdGUwLmxvdztcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDaGlcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGxhbmVJbmRleCA9IHggKyA1ICogeTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgbGFuZSA9IHN0YXRlW2xhbmVJbmRleF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIFRMYW5lID0gVFtsYW5lSW5kZXhdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBUeDFMYW5lID0gVFsoeCArIDEpICUgNSArIDUgKiB5XTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgVHgyTGFuZSA9IFRbKHggKyAyKSAlIDUgKyA1ICogeV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTWl4IHJvd3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYW5lLmhpZ2ggPSBUTGFuZS5oaWdoIF4gflR4MUxhbmUuaGlnaCAmIFR4MkxhbmUuaGlnaDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYW5lLmxvdyA9IFRMYW5lLmxvdyBeIH5UeDFMYW5lLmxvdyAmIFR4MkxhbmUubG93O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSW90YVxcblxcdFxcdFxcdFxcdFxcdHZhciBsYW5lID0gc3RhdGVbMF07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJvdW5kQ29uc3RhbnQgPSBST1VORF9DT05TVEFOVFNbcm91bmRdO1xcblxcdFxcdFxcdFxcdFxcdGxhbmUuaGlnaCBePSByb3VuZENvbnN0YW50LmhpZ2g7XFxuXFx0XFx0XFx0XFx0XFx0bGFuZS5sb3cgXj0gcm91bmRDb25zdGFudC5sb3c7O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xcblxcdFxcdFxcdFxcdHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xcblxcdFxcdFxcdFxcdHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XFxuXFx0XFx0XFx0XFx0dmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xcblxcdFxcdFxcdFxcdHZhciBibG9ja1NpemVCaXRzID0gdGhpcy5ibG9ja1NpemUgKiAzMjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgcGFkZGluZ1xcblxcdFxcdFxcdFxcdGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4MSA8PCAyNCAtIG5CaXRzTGVmdCAlIDMyO1xcblxcdFxcdFxcdFxcdGRhdGFXb3Jkc1soTWF0aC5jZWlsKChuQml0c0xlZnQgKyAxKSAvIGJsb2NrU2l6ZUJpdHMpICogYmxvY2tTaXplQml0cyA+Pj4gNSkgLSAxXSB8PSAweDgwO1xcblxcdFxcdFxcdFxcdGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBIYXNoIGZpbmFsIGJsb2Nrc1xcblxcdFxcdFxcdFxcdHRoaXMuX3Byb2Nlc3MoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHR2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcXG5cXHRcXHRcXHRcXHR2YXIgb3V0cHV0TGVuZ3RoQnl0ZXMgPSB0aGlzLmNmZy5vdXRwdXRMZW5ndGggLyA4O1xcblxcdFxcdFxcdFxcdHZhciBvdXRwdXRMZW5ndGhMYW5lcyA9IG91dHB1dExlbmd0aEJ5dGVzIC8gODtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTcXVlZXplXFxuXFx0XFx0XFx0XFx0dmFyIGhhc2hXb3JkcyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoTGFuZXM7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdFxcdHZhciBsYW5lID0gc3RhdGVbaV07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxhbmVNc3cgPSBsYW5lLmhpZ2g7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxhbmVMc3cgPSBsYW5lLmxvdztcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTd2FwIGVuZGlhblxcblxcdFxcdFxcdFxcdFxcdGxhbmVNc3cgPSAobGFuZU1zdyA8PCA4IHwgbGFuZU1zdyA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChsYW5lTXN3IDw8IDI0IHwgbGFuZU1zdyA+Pj4gOCkgJiAweGZmMDBmZjAwO1xcblxcdFxcdFxcdFxcdFxcdGxhbmVMc3cgPSAobGFuZUxzdyA8PCA4IHwgbGFuZUxzdyA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChsYW5lTHN3IDw8IDI0IHwgbGFuZUxzdyA+Pj4gOCkgJiAweGZmMDBmZjAwO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNxdWVlemUgc3RhdGUgdG8gcmV0cmlldmUgaGFzaFxcblxcdFxcdFxcdFxcdFxcdGhhc2hXb3Jkcy5wdXNoKGxhbmVMc3cpO1xcblxcdFxcdFxcdFxcdFxcdGhhc2hXb3Jkcy5wdXNoKGxhbmVNc3cpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgV29yZEFycmF5LmluaXQoaGFzaFdvcmRzLCBvdXRwdXRMZW5ndGhCeXRlcyk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xcblxcblxcdFxcdFxcdFxcdHZhciBzdGF0ZSA9IGNsb25lLl9zdGF0ZSA9IHRoaXMuX3N0YXRlLnNsaWNlKDApO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlW2ldID0gc3RhdGVbaV0uY2xvbmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsb25lO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMygnbWVzc2FnZScpO1xcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMyh3b3JkQXJyYXkpO1xcbiAgICovXFxuXFx0XFx0Qy5TSEEzID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMyk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cXG4gICAqXFxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxcbiAgICpcXG4gICAqIEBzdGF0aWNcXG4gICAqXFxuICAgKiBAZXhhbXBsZVxcbiAgICpcXG4gICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEzKG1lc3NhZ2UsIGtleSk7XFxuICAgKi9cXG5cXHRcXHRDLkhtYWNTSEEzID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTMpO1xcblxcdH0pKE1hdGgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5TSEEzO1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzLmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG5cclxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMzg0LmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanMgKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3g2NC1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMveDY0LWNvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zaGE1MTIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGE1MTIuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHR2YXIgQyA9IENyeXB0b0pTO1xcblxcdFxcdHZhciBDX3g2NCA9IEMueDY0O1xcblxcdFxcdHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcXG5cXHRcXHR2YXIgWDY0V29yZEFycmF5ID0gQ194NjQuV29yZEFycmF5O1xcblxcdFxcdHZhciBDX2FsZ28gPSBDLmFsZ287XFxuXFx0XFx0dmFyIFNIQTUxMiA9IENfYWxnby5TSEE1MTI7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTSEEtMzg0IGhhc2ggYWxnb3JpdGhtLlxcbiAgICovXFxuXFx0XFx0dmFyIFNIQTM4NCA9IENfYWxnby5TSEEzODQgPSBTSEE1MTIuZXh0ZW5kKHtcXG5cXHRcXHRcXHRfZG9SZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5LmluaXQoW25ldyBYNjRXb3JkLmluaXQoMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCksIG5ldyBYNjRXb3JkLmluaXQoMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyksIG5ldyBYNjRXb3JkLmluaXQoMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyksIG5ldyBYNjRXb3JkLmluaXQoMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSksIG5ldyBYNjRXb3JkLmluaXQoMHg2NzMzMjY2NywgMHhmZmMwMGIzMSksIG5ldyBYNjRXb3JkLmluaXQoMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSksIG5ldyBYNjRXb3JkLmluaXQoMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyksIG5ldyBYNjRXb3JkLmluaXQoMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCldKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGhhc2ggPSBTSEE1MTIuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtcXG5cXG5cXHRcXHRcXHRcXHRoYXNoLnNpZ0J5dGVzIC09IDE2O1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBoYXNoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMzg0KCdtZXNzYWdlJyk7XFxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzODQod29yZEFycmF5KTtcXG4gICAqL1xcblxcdFxcdEMuU0hBMzg0ID0gU0hBNTEyLl9jcmVhdGVIZWxwZXIoU0hBMzg0KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxcbiAgICpcXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTM4NChtZXNzYWdlLCBrZXkpO1xcbiAgICovXFxuXFx0XFx0Qy5IbWFjU0hBMzg0ID0gU0hBNTEyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTM4NCk7XFxuXFx0fSkoKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMzg0O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGE1MTIuanNcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTUxMi5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcXG5cXHRpZiAodHJ1ZSkge1xcblxcdFxcdC8vIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4veDY0LWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcXG5cXHRcXHR2YXIgQ194NjQgPSBDLng2NDtcXG5cXHRcXHR2YXIgWDY0V29yZCA9IENfeDY0LldvcmQ7XFxuXFx0XFx0dmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheTtcXG5cXHRcXHR2YXIgQ19hbGdvID0gQy5hbGdvO1xcblxcblxcdFxcdGZ1bmN0aW9uIFg2NFdvcmRfY3JlYXRlKCkge1xcblxcdFxcdFxcdHJldHVybiBYNjRXb3JkLmNyZWF0ZS5hcHBseShYNjRXb3JkLCBhcmd1bWVudHMpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb25zdGFudHNcXG5cXHRcXHR2YXIgSyA9IFtYNjRXb3JkX2NyZWF0ZSgweDQyOGEyZjk4LCAweGQ3MjhhZTIyKSwgWDY0V29yZF9jcmVhdGUoMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCksIFg2NFdvcmRfY3JlYXRlKDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYpLCBYNjRXb3JkX2NyZWF0ZSgweGU5YjVkYmE1LCAweDgxODlkYmJjKSwgWDY0V29yZF9jcmVhdGUoMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCksIFg2NFdvcmRfY3JlYXRlKDB4NTlmMTExZjEsIDB4YjYwNWQwMTkpLCBYNjRXb3JkX2NyZWF0ZSgweDkyM2Y4MmE0LCAweGFmMTk0ZjliKSwgWDY0V29yZF9jcmVhdGUoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksIFg2NFdvcmRfY3JlYXRlKDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIpLCBYNjRXb3JkX2NyZWF0ZSgweDEyODM1YjAxLCAweDQ1NzA2ZmJlKSwgWDY0V29yZF9jcmVhdGUoMHgyNDMxODViZSwgMHg0ZWU0YjI4YyksIFg2NFdvcmRfY3JlYXRlKDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIpLCBYNjRXb3JkX2NyZWF0ZSgweDcyYmU1ZDc0LCAweGYyN2I4OTZmKSwgWDY0V29yZF9jcmVhdGUoMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSksIFg2NFdvcmRfY3JlYXRlKDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUpLCBYNjRXb3JkX2NyZWF0ZSgweGMxOWJmMTc0LCAweGNmNjkyNjk0KSwgWDY0V29yZF9jcmVhdGUoMHhlNDliNjljMSwgMHg5ZWYxNGFkMiksIFg2NFdvcmRfY3JlYXRlKDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMpLCBYNjRXb3JkX2NyZWF0ZSgweDBmYzE5ZGM2LCAweDhiOGNkNWI1KSwgWDY0V29yZF9jcmVhdGUoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksIFg2NFdvcmRfY3JlYXRlKDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUpLCBYNjRXb3JkX2NyZWF0ZSgweDRhNzQ4NGFhLCAweDZlYTZlNDgzKSwgWDY0V29yZF9jcmVhdGUoMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCksIFg2NFdvcmRfY3JlYXRlKDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUpLCBYNjRXb3JkX2NyZWF0ZSgweDk4M2U1MTUyLCAweGVlNjZkZmFiKSwgWDY0V29yZF9jcmVhdGUoMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCksIFg2NFdvcmRfY3JlYXRlKDB4YjAwMzI3YzgsIDB4OThmYjIxM2YpLCBYNjRXb3JkX2NyZWF0ZSgweGJmNTk3ZmM3LCAweGJlZWYwZWU0KSwgWDY0V29yZF9jcmVhdGUoMHhjNmUwMGJmMywgMHgzZGE4OGZjMiksIFg2NFdvcmRfY3JlYXRlKDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUpLCBYNjRXb3JkX2NyZWF0ZSgweDA2Y2E2MzUxLCAweGUwMDM4MjZmKSwgWDY0V29yZF9jcmVhdGUoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksIFg2NFdvcmRfY3JlYXRlKDB4MjdiNzBhODUsIDB4NDZkMjJmZmMpLCBYNjRXb3JkX2NyZWF0ZSgweDJlMWIyMTM4LCAweDVjMjZjOTI2KSwgWDY0V29yZF9jcmVhdGUoMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCksIFg2NFdvcmRfY3JlYXRlKDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYpLCBYNjRXb3JkX2NyZWF0ZSgweDY1MGE3MzU0LCAweDhiYWY2M2RlKSwgWDY0V29yZF9jcmVhdGUoMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCksIFg2NFdvcmRfY3JlYXRlKDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYpLCBYNjRXb3JkX2NyZWF0ZSgweDkyNzIyYzg1LCAweDE0ODIzNTNiKSwgWDY0V29yZF9jcmVhdGUoMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCksIFg2NFdvcmRfY3JlYXRlKDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEpLCBYNjRXb3JkX2NyZWF0ZSgweGMyNGI4YjcwLCAweGQwZjg5NzkxKSwgWDY0V29yZF9jcmVhdGUoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksIFg2NFdvcmRfY3JlYXRlKDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgpLCBYNjRXb3JkX2NyZWF0ZSgweGQ2OTkwNjI0LCAweDU1NjVhOTEwKSwgWDY0V29yZF9jcmVhdGUoMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSksIFg2NFdvcmRfY3JlYXRlKDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgpLCBYNjRXb3JkX2NyZWF0ZSgweDE5YTRjMTE2LCAweGI4ZDJkMGM4KSwgWDY0V29yZF9jcmVhdGUoMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyksIFg2NFdvcmRfY3JlYXRlKDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTkpLCBYNjRXb3JkX2NyZWF0ZSgweDM0YjBiY2I1LCAweGUxOWI0OGE4KSwgWDY0V29yZF9jcmVhdGUoMHgzOTFjMGNiMywgMHhjNWM5NWE2MyksIFg2NFdvcmRfY3JlYXRlKDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IpLCBYNjRXb3JkX2NyZWF0ZSgweDViOWNjYTRmLCAweDc3NjNlMzczKSwgWDY0V29yZF9jcmVhdGUoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksIFg2NFdvcmRfY3JlYXRlKDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMpLCBYNjRXb3JkX2NyZWF0ZSgweDc4YTU2MzZmLCAweDQzMTcyZjYwKSwgWDY0V29yZF9jcmVhdGUoMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiksIFg2NFdvcmRfY3JlYXRlKDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMpLCBYNjRXb3JkX2NyZWF0ZSgweDkwYmVmZmZhLCAweDIzNjMxZTI4KSwgWDY0V29yZF9jcmVhdGUoMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSksIFg2NFdvcmRfY3JlYXRlKDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUpLCBYNjRXb3JkX2NyZWF0ZSgweGM2NzE3OGYyLCAweGUzNzI1MzJiKSwgWDY0V29yZF9jcmVhdGUoMHhjYTI3M2VjZSwgMHhlYTI2NjE5YyksIFg2NFdvcmRfY3JlYXRlKDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcpLCBYNjRXb3JkX2NyZWF0ZSgweGVhZGE3ZGQ2LCAweGNkZTBlYjFlKSwgWDY0V29yZF9jcmVhdGUoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksIFg2NFdvcmRfY3JlYXRlKDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEpLCBYNjRXb3JkX2NyZWF0ZSgweDBhNjM3ZGM1LCAweGEyYzg5OGE2KSwgWDY0V29yZF9jcmVhdGUoMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSksIFg2NFdvcmRfY3JlYXRlKDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIpLCBYNjRXb3JkX2NyZWF0ZSgweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0KSwgWDY0V29yZF9jcmVhdGUoMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyksIFg2NFdvcmRfY3JlYXRlKDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMpLCBYNjRXb3JkX2NyZWF0ZSgweDQzMWQ2N2M0LCAweDljMTAwZDRjKSwgWDY0V29yZF9jcmVhdGUoMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiksIFg2NFdvcmRfY3JlYXRlKDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEpLCBYNjRXb3JkX2NyZWF0ZSgweDVmY2I2ZmFiLCAweDNhZDZmYWVjKSwgWDY0V29yZF9jcmVhdGUoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNyldO1xcblxcblxcdFxcdC8vIFJldXNhYmxlIG9iamVjdHNcXG5cXHRcXHR2YXIgVyA9IFtdO1xcblxcdFxcdChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0V1tpXSA9IFg2NFdvcmRfY3JlYXRlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pKCk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTSEEtNTEyIGhhc2ggYWxnb3JpdGhtLlxcbiAgICovXFxuXFx0XFx0dmFyIFNIQTUxMiA9IENfYWxnby5TSEE1MTIgPSBIYXNoZXIuZXh0ZW5kKHtcXG5cXHRcXHRcXHRfZG9SZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5LmluaXQoW25ldyBYNjRXb3JkLmluaXQoMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCksIG5ldyBYNjRXb3JkLmluaXQoMHhiYjY3YWU4NSwgMHg4NGNhYTczYiksIG5ldyBYNjRXb3JkLmluaXQoMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiksIG5ldyBYNjRXb3JkLmluaXQoMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSksIG5ldyBYNjRXb3JkLmluaXQoMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSksIG5ldyBYNjRXb3JkLmluaXQoMHg5YjA1Njg4YywgMHgyYjNlNmMxZiksIG5ldyBYNjRXb3JkLmluaXQoMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiksIG5ldyBYNjRXb3JkLmluaXQoMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSldKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcXG5cXG5cXHRcXHRcXHRcXHR2YXIgSDAgPSBIWzBdO1xcblxcdFxcdFxcdFxcdHZhciBIMSA9IEhbMV07XFxuXFx0XFx0XFx0XFx0dmFyIEgyID0gSFsyXTtcXG5cXHRcXHRcXHRcXHR2YXIgSDMgPSBIWzNdO1xcblxcdFxcdFxcdFxcdHZhciBINCA9IEhbNF07XFxuXFx0XFx0XFx0XFx0dmFyIEg1ID0gSFs1XTtcXG5cXHRcXHRcXHRcXHR2YXIgSDYgPSBIWzZdO1xcblxcdFxcdFxcdFxcdHZhciBINyA9IEhbN107XFxuXFxuXFx0XFx0XFx0XFx0dmFyIEgwaCA9IEgwLmhpZ2g7XFxuXFx0XFx0XFx0XFx0dmFyIEgwbCA9IEgwLmxvdztcXG5cXHRcXHRcXHRcXHR2YXIgSDFoID0gSDEuaGlnaDtcXG5cXHRcXHRcXHRcXHR2YXIgSDFsID0gSDEubG93O1xcblxcdFxcdFxcdFxcdHZhciBIMmggPSBIMi5oaWdoO1xcblxcdFxcdFxcdFxcdHZhciBIMmwgPSBIMi5sb3c7XFxuXFx0XFx0XFx0XFx0dmFyIEgzaCA9IEgzLmhpZ2g7XFxuXFx0XFx0XFx0XFx0dmFyIEgzbCA9IEgzLmxvdztcXG5cXHRcXHRcXHRcXHR2YXIgSDRoID0gSDQuaGlnaDtcXG5cXHRcXHRcXHRcXHR2YXIgSDRsID0gSDQubG93O1xcblxcdFxcdFxcdFxcdHZhciBINWggPSBINS5oaWdoO1xcblxcdFxcdFxcdFxcdHZhciBINWwgPSBINS5sb3c7XFxuXFx0XFx0XFx0XFx0dmFyIEg2aCA9IEg2LmhpZ2g7XFxuXFx0XFx0XFx0XFx0dmFyIEg2bCA9IEg2LmxvdztcXG5cXHRcXHRcXHRcXHR2YXIgSDdoID0gSDcuaGlnaDtcXG5cXHRcXHRcXHRcXHR2YXIgSDdsID0gSDcubG93O1xcblxcblxcdFxcdFxcdFxcdC8vIFdvcmtpbmcgdmFyaWFibGVzXFxuXFx0XFx0XFx0XFx0dmFyIGFoID0gSDBoO1xcblxcdFxcdFxcdFxcdHZhciBhbCA9IEgwbDtcXG5cXHRcXHRcXHRcXHR2YXIgYmggPSBIMWg7XFxuXFx0XFx0XFx0XFx0dmFyIGJsID0gSDFsO1xcblxcdFxcdFxcdFxcdHZhciBjaCA9IEgyaDtcXG5cXHRcXHRcXHRcXHR2YXIgY2wgPSBIMmw7XFxuXFx0XFx0XFx0XFx0dmFyIGRoID0gSDNoO1xcblxcdFxcdFxcdFxcdHZhciBkbCA9IEgzbDtcXG5cXHRcXHRcXHRcXHR2YXIgZWggPSBINGg7XFxuXFx0XFx0XFx0XFx0dmFyIGVsID0gSDRsO1xcblxcdFxcdFxcdFxcdHZhciBmaCA9IEg1aDtcXG5cXHRcXHRcXHRcXHR2YXIgZmwgPSBINWw7XFxuXFx0XFx0XFx0XFx0dmFyIGdoID0gSDZoO1xcblxcdFxcdFxcdFxcdHZhciBnbCA9IEg2bDtcXG5cXHRcXHRcXHRcXHR2YXIgaGggPSBIN2g7XFxuXFx0XFx0XFx0XFx0dmFyIGhsID0gSDdsO1xcblxcblxcdFxcdFxcdFxcdC8vIFJvdW5kc1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0XFx0dmFyIFdpID0gV1tpXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBFeHRlbmQgbWVzc2FnZVxcblxcdFxcdFxcdFxcdFxcdGlmIChpIDwgMTYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgV2loID0gV2kuaGlnaCA9IE1bb2Zmc2V0ICsgaSAqIDJdIHwgMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgV2lsID0gV2kubG93ID0gTVtvZmZzZXQgKyBpICogMiArIDFdIHwgMDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEdhbW1hMFxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTB4aCA9IGdhbW1hMHguaGlnaDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ2FtbWEweGwgPSBnYW1tYTB4LmxvdztcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ2FtbWEwaCA9IChnYW1tYTB4aCA+Pj4gMSB8IGdhbW1hMHhsIDw8IDMxKSBeIChnYW1tYTB4aCA+Pj4gOCB8IGdhbW1hMHhsIDw8IDI0KSBeIGdhbW1hMHhoID4+PiA3O1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTBsID0gKGdhbW1hMHhsID4+PiAxIHwgZ2FtbWEweGggPDwgMzEpIF4gKGdhbW1hMHhsID4+PiA4IHwgZ2FtbWEweGggPDwgMjQpIF4gKGdhbW1hMHhsID4+PiA3IHwgZ2FtbWEweGggPDwgMjUpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEdhbW1hMVxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdhbW1hMXhoID0gZ2FtbWExeC5oaWdoO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTF4bCA9IGdhbW1hMXgubG93O1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTFoID0gKGdhbW1hMXhoID4+PiAxOSB8IGdhbW1hMXhsIDw8IDEzKSBeIChnYW1tYTF4aCA8PCAzIHwgZ2FtbWExeGwgPj4+IDI5KSBeIGdhbW1hMXhoID4+PiA2O1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnYW1tYTFsID0gKGdhbW1hMXhsID4+PiAxOSB8IGdhbW1hMXhoIDw8IDEzKSBeIChnYW1tYTF4bCA8PCAzIHwgZ2FtbWExeGggPj4+IDI5KSBeIChnYW1tYTF4bCA+Pj4gNiB8IGdhbW1hMXhoIDw8IDI2KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgV2k3ID0gV1tpIC0gN107XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFdpN2ggPSBXaTcuaGlnaDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgV2k3bCA9IFdpNy5sb3c7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFdpMTYgPSBXW2kgLSAxNl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFdpMTZoID0gV2kxNi5oaWdoO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBXaTE2bCA9IFdpMTYubG93O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBXaWwgPSBnYW1tYTBsICsgV2k3bDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgV2loID0gZ2FtbWEwaCArIFdpN2ggKyAoV2lsID4+PiAwIDwgZ2FtbWEwbCA+Pj4gMCA/IDEgOiAwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgV2lsID0gV2lsICsgZ2FtbWExbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgV2loID0gV2loICsgZ2FtbWExaCArIChXaWwgPj4+IDAgPCBnYW1tYTFsID4+PiAwID8gMSA6IDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBXaWwgPSBXaWwgKyBXaTE2bDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgV2loID0gV2loICsgV2kxNmggKyAoV2lsID4+PiAwIDwgV2kxNmwgPj4+IDAgPyAxIDogMCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0V2kuaGlnaCA9IFdpaDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRXaS5sb3cgPSBXaWw7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjaGggPSBlaCAmIGZoIF4gfmVoICYgZ2g7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNobCA9IGVsICYgZmwgXiB+ZWwgJiBnbDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWFqaCA9IGFoICYgYmggXiBhaCAmIGNoIF4gYmggJiBjaDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWFqbCA9IGFsICYgYmwgXiBhbCAmIGNsIF4gYmwgJiBjbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2lnbWEwaCA9IChhaCA+Pj4gMjggfCBhbCA8PCA0KSBeIChhaCA8PCAzMCB8IGFsID4+PiAyKSBeIChhaCA8PCAyNSB8IGFsID4+PiA3KTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2lnbWEwbCA9IChhbCA+Pj4gMjggfCBhaCA8PCA0KSBeIChhbCA8PCAzMCB8IGFoID4+PiAyKSBeIChhbCA8PCAyNSB8IGFoID4+PiA3KTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2lnbWExaCA9IChlaCA+Pj4gMTQgfCBlbCA8PCAxOCkgXiAoZWggPj4+IDE4IHwgZWwgPDwgMTQpIF4gKGVoIDw8IDIzIHwgZWwgPj4+IDkpO1xcblxcdFxcdFxcdFxcdFxcdHZhciBzaWdtYTFsID0gKGVsID4+PiAxNCB8IGVoIDw8IDE4KSBeIChlbCA+Pj4gMTggfCBlaCA8PCAxNCkgXiAoZWwgPDwgMjMgfCBlaCA+Pj4gOSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXVxcblxcdFxcdFxcdFxcdFxcdHZhciBLaSA9IEtbaV07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIEtpaCA9IEtpLmhpZ2g7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIEtpbCA9IEtpLmxvdztcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdDFsID0gaGwgKyBzaWdtYTFsO1xcblxcdFxcdFxcdFxcdFxcdHZhciB0MWggPSBoaCArIHNpZ21hMWggKyAodDFsID4+PiAwIDwgaGwgPj4+IDAgPyAxIDogMCk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHQxbCA9IHQxbCArIGNobDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdDFoID0gdDFoICsgY2hoICsgKHQxbCA+Pj4gMCA8IGNobCA+Pj4gMCA/IDEgOiAwKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdDFsID0gdDFsICsgS2lsO1xcblxcdFxcdFxcdFxcdFxcdHZhciB0MWggPSB0MWggKyBLaWggKyAodDFsID4+PiAwIDwgS2lsID4+PiAwID8gMSA6IDApO1xcblxcdFxcdFxcdFxcdFxcdHZhciB0MWwgPSB0MWwgKyBXaWw7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHQxaCA9IHQxaCArIFdpaCArICh0MWwgPj4+IDAgPCBXaWwgPj4+IDAgPyAxIDogMCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdDIgPSBzaWdtYTAgKyBtYWpcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdDJsID0gc2lnbWEwbCArIG1hamw7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHQyaCA9IHNpZ21hMGggKyBtYWpoICsgKHQybCA+Pj4gMCA8IHNpZ21hMGwgPj4+IDAgPyAxIDogMCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVXBkYXRlIHdvcmtpbmcgdmFyaWFibGVzXFxuXFx0XFx0XFx0XFx0XFx0aGggPSBnaDtcXG5cXHRcXHRcXHRcXHRcXHRobCA9IGdsO1xcblxcdFxcdFxcdFxcdFxcdGdoID0gZmg7XFxuXFx0XFx0XFx0XFx0XFx0Z2wgPSBmbDtcXG5cXHRcXHRcXHRcXHRcXHRmaCA9IGVoO1xcblxcdFxcdFxcdFxcdFxcdGZsID0gZWw7XFxuXFx0XFx0XFx0XFx0XFx0ZWwgPSBkbCArIHQxbCB8IDA7XFxuXFx0XFx0XFx0XFx0XFx0ZWggPSBkaCArIHQxaCArIChlbCA+Pj4gMCA8IGRsID4+PiAwID8gMSA6IDApIHwgMDtcXG5cXHRcXHRcXHRcXHRcXHRkaCA9IGNoO1xcblxcdFxcdFxcdFxcdFxcdGRsID0gY2w7XFxuXFx0XFx0XFx0XFx0XFx0Y2ggPSBiaDtcXG5cXHRcXHRcXHRcXHRcXHRjbCA9IGJsO1xcblxcdFxcdFxcdFxcdFxcdGJoID0gYWg7XFxuXFx0XFx0XFx0XFx0XFx0YmwgPSBhbDtcXG5cXHRcXHRcXHRcXHRcXHRhbCA9IHQxbCArIHQybCB8IDA7XFxuXFx0XFx0XFx0XFx0XFx0YWggPSB0MWggKyB0MmggKyAoYWwgPj4+IDAgPCB0MWwgPj4+IDAgPyAxIDogMCkgfCAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxcblxcdFxcdFxcdFxcdEgwbCA9IEgwLmxvdyA9IEgwbCArIGFsO1xcblxcdFxcdFxcdFxcdEgwLmhpZ2ggPSBIMGggKyBhaCArIChIMGwgPj4+IDAgPCBhbCA+Pj4gMCA/IDEgOiAwKTtcXG5cXHRcXHRcXHRcXHRIMWwgPSBIMS5sb3cgPSBIMWwgKyBibDtcXG5cXHRcXHRcXHRcXHRIMS5oaWdoID0gSDFoICsgYmggKyAoSDFsID4+PiAwIDwgYmwgPj4+IDAgPyAxIDogMCk7XFxuXFx0XFx0XFx0XFx0SDJsID0gSDIubG93ID0gSDJsICsgY2w7XFxuXFx0XFx0XFx0XFx0SDIuaGlnaCA9IEgyaCArIGNoICsgKEgybCA+Pj4gMCA8IGNsID4+PiAwID8gMSA6IDApO1xcblxcdFxcdFxcdFxcdEgzbCA9IEgzLmxvdyA9IEgzbCArIGRsO1xcblxcdFxcdFxcdFxcdEgzLmhpZ2ggPSBIM2ggKyBkaCArIChIM2wgPj4+IDAgPCBkbCA+Pj4gMCA/IDEgOiAwKTtcXG5cXHRcXHRcXHRcXHRINGwgPSBINC5sb3cgPSBINGwgKyBlbDtcXG5cXHRcXHRcXHRcXHRINC5oaWdoID0gSDRoICsgZWggKyAoSDRsID4+PiAwIDwgZWwgPj4+IDAgPyAxIDogMCk7XFxuXFx0XFx0XFx0XFx0SDVsID0gSDUubG93ID0gSDVsICsgZmw7XFxuXFx0XFx0XFx0XFx0SDUuaGlnaCA9IEg1aCArIGZoICsgKEg1bCA+Pj4gMCA8IGZsID4+PiAwID8gMSA6IDApO1xcblxcdFxcdFxcdFxcdEg2bCA9IEg2LmxvdyA9IEg2bCArIGdsO1xcblxcdFxcdFxcdFxcdEg2LmhpZ2ggPSBINmggKyBnaCArIChINmwgPj4+IDAgPCBnbCA+Pj4gMCA/IDEgOiAwKTtcXG5cXHRcXHRcXHRcXHRIN2wgPSBINy5sb3cgPSBIN2wgKyBobDtcXG5cXHRcXHRcXHRcXHRINy5oaWdoID0gSDdoICsgaGggKyAoSDdsID4+PiAwIDwgaGwgPj4+IDAgPyAxIDogMCk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBkYXRhID0gdGhpcy5fZGF0YTtcXG5cXHRcXHRcXHRcXHR2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xcblxcdFxcdFxcdFxcdHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgcGFkZGluZ1xcblxcdFxcdFxcdFxcdGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgMjQgLSBuQml0c0xlZnQgJSAzMjtcXG5cXHRcXHRcXHRcXHRkYXRhV29yZHNbKG5CaXRzTGVmdCArIDEyOCA+Pj4gMTAgPDwgNSkgKyAzMF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XFxuXFx0XFx0XFx0XFx0ZGF0YVdvcmRzWyhuQml0c0xlZnQgKyAxMjggPj4+IDEwIDw8IDUpICsgMzFdID0gbkJpdHNUb3RhbDtcXG5cXHRcXHRcXHRcXHRkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFzaCBmaW5hbCBibG9ja3NcXG5cXHRcXHRcXHRcXHR0aGlzLl9wcm9jZXNzKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29udmVydCBoYXNoIHRvIDMyLWJpdCB3b3JkIGFycmF5IGJlZm9yZSByZXR1cm5pbmdcXG5cXHRcXHRcXHRcXHR2YXIgaGFzaCA9IHRoaXMuX2hhc2gudG9YMzIoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxcblxcdFxcdFxcdFxcdHJldHVybiBoYXNoO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2xvbmU7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRibG9ja1NpemU6IDEwMjQgLyAzMlxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXFxuICAgKlxcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cXG4gICAqXFxuICAgKiBAc3RhdGljXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEE1MTIoJ21lc3NhZ2UnKTtcXG4gICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTUxMih3b3JkQXJyYXkpO1xcbiAgICovXFxuXFx0XFx0Qy5TSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEE1MTIpO1xcblxcblxcdFxcdC8qKlxcbiAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXFxuICAgKlxcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cXG4gICAqXFxuICAgKiBAc3RhdGljXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBNTEyKG1lc3NhZ2UsIGtleSk7XFxuICAgKi9cXG5cXHRcXHRDLkhtYWNTSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBNTEyKTtcXG5cXHR9KSgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUy5TSEE1MTI7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQmFzZUVuY3J5cHRpb24vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTUxMi5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3RyaXBsZWRlcy5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvdHJpcGxlZGVzLmpzICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lbmMtYmFzZTY0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWJhc2U2NC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21kNSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21kNS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2cGtkZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NpcGhlci1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcXFwiKSk7XFxuXFx0fSBlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XFxuXFxuXFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHR2YXIgQyA9IENyeXB0b0pTO1xcblxcdFxcdHZhciBDX2xpYiA9IEMubGliO1xcblxcdFxcdHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XFxuXFx0XFx0dmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XFxuXFx0XFx0dmFyIENfYWxnbyA9IEMuYWxnbztcXG5cXG5cXHRcXHQvLyBQZXJtdXRlZCBDaG9pY2UgMSBjb25zdGFudHNcXG5cXHRcXHR2YXIgUEMxID0gWzU3LCA0OSwgNDEsIDMzLCAyNSwgMTcsIDksIDEsIDU4LCA1MCwgNDIsIDM0LCAyNiwgMTgsIDEwLCAyLCA1OSwgNTEsIDQzLCAzNSwgMjcsIDE5LCAxMSwgMywgNjAsIDUyLCA0NCwgMzYsIDYzLCA1NSwgNDcsIDM5LCAzMSwgMjMsIDE1LCA3LCA2MiwgNTQsIDQ2LCAzOCwgMzAsIDIyLCAxNCwgNiwgNjEsIDUzLCA0NSwgMzcsIDI5LCAyMSwgMTMsIDUsIDI4LCAyMCwgMTIsIDRdO1xcblxcblxcdFxcdC8vIFBlcm11dGVkIENob2ljZSAyIGNvbnN0YW50c1xcblxcdFxcdHZhciBQQzIgPSBbMTQsIDE3LCAxMSwgMjQsIDEsIDUsIDMsIDI4LCAxNSwgNiwgMjEsIDEwLCAyMywgMTksIDEyLCA0LCAyNiwgOCwgMTYsIDcsIDI3LCAyMCwgMTMsIDIsIDQxLCA1MiwgMzEsIDM3LCA0NywgNTUsIDMwLCA0MCwgNTEsIDQ1LCAzMywgNDgsIDQ0LCA0OSwgMzksIDU2LCAzNCwgNTMsIDQ2LCA0MiwgNTAsIDM2LCAyOSwgMzJdO1xcblxcblxcdFxcdC8vIEN1bXVsYXRpdmUgYml0IHNoaWZ0IGNvbnN0YW50c1xcblxcdFxcdHZhciBCSVRfU0hJRlRTID0gWzEsIDIsIDQsIDYsIDgsIDEwLCAxMiwgMTQsIDE1LCAxNywgMTksIDIxLCAyMywgMjUsIDI3LCAyOF07XFxuXFxuXFx0XFx0Ly8gU0JPWGVzIGFuZCByb3VuZCBwZXJtdXRhdGlvbiBjb25zdGFudHNcXG5cXHRcXHR2YXIgU0JPWF9QID0gW3tcXG5cXHRcXHRcXHQweDA6IDB4ODA4MjAwLFxcblxcdFxcdFxcdDB4MTAwMDAwMDA6IDB4ODAwMCxcXG5cXHRcXHRcXHQweDIwMDAwMDAwOiAweDgwODAwMixcXG5cXHRcXHRcXHQweDMwMDAwMDAwOiAweDIsXFxuXFx0XFx0XFx0MHg0MDAwMDAwMDogMHgyMDAsXFxuXFx0XFx0XFx0MHg1MDAwMDAwMDogMHg4MDgyMDIsXFxuXFx0XFx0XFx0MHg2MDAwMDAwMDogMHg4MDAyMDIsXFxuXFx0XFx0XFx0MHg3MDAwMDAwMDogMHg4MDAwMDAsXFxuXFx0XFx0XFx0MHg4MDAwMDAwMDogMHgyMDIsXFxuXFx0XFx0XFx0MHg5MDAwMDAwMDogMHg4MDAyMDAsXFxuXFx0XFx0XFx0MHhhMDAwMDAwMDogMHg4MjAwLFxcblxcdFxcdFxcdDB4YjAwMDAwMDA6IDB4ODA4MDAwLFxcblxcdFxcdFxcdDB4YzAwMDAwMDA6IDB4ODAwMixcXG5cXHRcXHRcXHQweGQwMDAwMDAwOiAweDgwMDAwMixcXG5cXHRcXHRcXHQweGUwMDAwMDAwOiAweDAsXFxuXFx0XFx0XFx0MHhmMDAwMDAwMDogMHg4MjAyLFxcblxcdFxcdFxcdDB4ODAwMDAwMDogMHgwLFxcblxcdFxcdFxcdDB4MTgwMDAwMDA6IDB4ODA4MjAyLFxcblxcdFxcdFxcdDB4MjgwMDAwMDA6IDB4ODIwMixcXG5cXHRcXHRcXHQweDM4MDAwMDAwOiAweDgwMDAsXFxuXFx0XFx0XFx0MHg0ODAwMDAwMDogMHg4MDgyMDAsXFxuXFx0XFx0XFx0MHg1ODAwMDAwMDogMHgyMDAsXFxuXFx0XFx0XFx0MHg2ODAwMDAwMDogMHg4MDgwMDIsXFxuXFx0XFx0XFx0MHg3ODAwMDAwMDogMHgyLFxcblxcdFxcdFxcdDB4ODgwMDAwMDA6IDB4ODAwMjAwLFxcblxcdFxcdFxcdDB4OTgwMDAwMDA6IDB4ODIwMCxcXG5cXHRcXHRcXHQweGE4MDAwMDAwOiAweDgwODAwMCxcXG5cXHRcXHRcXHQweGI4MDAwMDAwOiAweDgwMDIwMixcXG5cXHRcXHRcXHQweGM4MDAwMDAwOiAweDgwMDAwMixcXG5cXHRcXHRcXHQweGQ4MDAwMDAwOiAweDgwMDIsXFxuXFx0XFx0XFx0MHhlODAwMDAwMDogMHgyMDIsXFxuXFx0XFx0XFx0MHhmODAwMDAwMDogMHg4MDAwMDAsXFxuXFx0XFx0XFx0MHgxOiAweDgwMDAsXFxuXFx0XFx0XFx0MHgxMDAwMDAwMTogMHgyLFxcblxcdFxcdFxcdDB4MjAwMDAwMDE6IDB4ODA4MjAwLFxcblxcdFxcdFxcdDB4MzAwMDAwMDE6IDB4ODAwMDAwLFxcblxcdFxcdFxcdDB4NDAwMDAwMDE6IDB4ODA4MDAyLFxcblxcdFxcdFxcdDB4NTAwMDAwMDE6IDB4ODIwMCxcXG5cXHRcXHRcXHQweDYwMDAwMDAxOiAweDIwMCxcXG5cXHRcXHRcXHQweDcwMDAwMDAxOiAweDgwMDIwMixcXG5cXHRcXHRcXHQweDgwMDAwMDAxOiAweDgwODIwMixcXG5cXHRcXHRcXHQweDkwMDAwMDAxOiAweDgwODAwMCxcXG5cXHRcXHRcXHQweGEwMDAwMDAxOiAweDgwMDAwMixcXG5cXHRcXHRcXHQweGIwMDAwMDAxOiAweDgyMDIsXFxuXFx0XFx0XFx0MHhjMDAwMDAwMTogMHgyMDIsXFxuXFx0XFx0XFx0MHhkMDAwMDAwMTogMHg4MDAyMDAsXFxuXFx0XFx0XFx0MHhlMDAwMDAwMTogMHg4MDAyLFxcblxcdFxcdFxcdDB4ZjAwMDAwMDE6IDB4MCxcXG5cXHRcXHRcXHQweDgwMDAwMDE6IDB4ODA4MjAyLFxcblxcdFxcdFxcdDB4MTgwMDAwMDE6IDB4ODA4MDAwLFxcblxcdFxcdFxcdDB4MjgwMDAwMDE6IDB4ODAwMDAwLFxcblxcdFxcdFxcdDB4MzgwMDAwMDE6IDB4MjAwLFxcblxcdFxcdFxcdDB4NDgwMDAwMDE6IDB4ODAwMCxcXG5cXHRcXHRcXHQweDU4MDAwMDAxOiAweDgwMDAwMixcXG5cXHRcXHRcXHQweDY4MDAwMDAxOiAweDIsXFxuXFx0XFx0XFx0MHg3ODAwMDAwMTogMHg4MjAyLFxcblxcdFxcdFxcdDB4ODgwMDAwMDE6IDB4ODAwMixcXG5cXHRcXHRcXHQweDk4MDAwMDAxOiAweDgwMDIwMixcXG5cXHRcXHRcXHQweGE4MDAwMDAxOiAweDIwMixcXG5cXHRcXHRcXHQweGI4MDAwMDAxOiAweDgwODIwMCxcXG5cXHRcXHRcXHQweGM4MDAwMDAxOiAweDgwMDIwMCxcXG5cXHRcXHRcXHQweGQ4MDAwMDAxOiAweDAsXFxuXFx0XFx0XFx0MHhlODAwMDAwMTogMHg4MjAwLFxcblxcdFxcdFxcdDB4ZjgwMDAwMDE6IDB4ODA4MDAyXFxuXFx0XFx0fSwge1xcblxcdFxcdFxcdDB4MDogMHg0MDA4NDAxMCxcXG5cXHRcXHRcXHQweDEwMDAwMDA6IDB4NDAwMCxcXG5cXHRcXHRcXHQweDIwMDAwMDA6IDB4ODAwMDAsXFxuXFx0XFx0XFx0MHgzMDAwMDAwOiAweDQwMDgwMDEwLFxcblxcdFxcdFxcdDB4NDAwMDAwMDogMHg0MDAwMDAxMCxcXG5cXHRcXHRcXHQweDUwMDAwMDA6IDB4NDAwODQwMDAsXFxuXFx0XFx0XFx0MHg2MDAwMDAwOiAweDQwMDA0MDAwLFxcblxcdFxcdFxcdDB4NzAwMDAwMDogMHgxMCxcXG5cXHRcXHRcXHQweDgwMDAwMDA6IDB4ODQwMDAsXFxuXFx0XFx0XFx0MHg5MDAwMDAwOiAweDQwMDA0MDEwLFxcblxcdFxcdFxcdDB4YTAwMDAwMDogMHg0MDAwMDAwMCxcXG5cXHRcXHRcXHQweGIwMDAwMDA6IDB4ODQwMTAsXFxuXFx0XFx0XFx0MHhjMDAwMDAwOiAweDgwMDEwLFxcblxcdFxcdFxcdDB4ZDAwMDAwMDogMHgwLFxcblxcdFxcdFxcdDB4ZTAwMDAwMDogMHg0MDEwLFxcblxcdFxcdFxcdDB4ZjAwMDAwMDogMHg0MDA4MDAwMCxcXG5cXHRcXHRcXHQweDgwMDAwMDogMHg0MDAwNDAwMCxcXG5cXHRcXHRcXHQweDE4MDAwMDA6IDB4ODQwMTAsXFxuXFx0XFx0XFx0MHgyODAwMDAwOiAweDEwLFxcblxcdFxcdFxcdDB4MzgwMDAwMDogMHg0MDAwNDAxMCxcXG5cXHRcXHRcXHQweDQ4MDAwMDA6IDB4NDAwODQwMTAsXFxuXFx0XFx0XFx0MHg1ODAwMDAwOiAweDQwMDAwMDAwLFxcblxcdFxcdFxcdDB4NjgwMDAwMDogMHg4MDAwMCxcXG5cXHRcXHRcXHQweDc4MDAwMDA6IDB4NDAwODAwMTAsXFxuXFx0XFx0XFx0MHg4ODAwMDAwOiAweDgwMDEwLFxcblxcdFxcdFxcdDB4OTgwMDAwMDogMHgwLFxcblxcdFxcdFxcdDB4YTgwMDAwMDogMHg0MDAwLFxcblxcdFxcdFxcdDB4YjgwMDAwMDogMHg0MDA4MDAwMCxcXG5cXHRcXHRcXHQweGM4MDAwMDA6IDB4NDAwMDAwMTAsXFxuXFx0XFx0XFx0MHhkODAwMDAwOiAweDg0MDAwLFxcblxcdFxcdFxcdDB4ZTgwMDAwMDogMHg0MDA4NDAwMCxcXG5cXHRcXHRcXHQweGY4MDAwMDA6IDB4NDAxMCxcXG5cXHRcXHRcXHQweDEwMDAwMDAwOiAweDAsXFxuXFx0XFx0XFx0MHgxMTAwMDAwMDogMHg0MDA4MDAxMCxcXG5cXHRcXHRcXHQweDEyMDAwMDAwOiAweDQwMDA0MDEwLFxcblxcdFxcdFxcdDB4MTMwMDAwMDA6IDB4NDAwODQwMDAsXFxuXFx0XFx0XFx0MHgxNDAwMDAwMDogMHg0MDA4MDAwMCxcXG5cXHRcXHRcXHQweDE1MDAwMDAwOiAweDEwLFxcblxcdFxcdFxcdDB4MTYwMDAwMDA6IDB4ODQwMTAsXFxuXFx0XFx0XFx0MHgxNzAwMDAwMDogMHg0MDAwLFxcblxcdFxcdFxcdDB4MTgwMDAwMDA6IDB4NDAxMCxcXG5cXHRcXHRcXHQweDE5MDAwMDAwOiAweDgwMDAwLFxcblxcdFxcdFxcdDB4MWEwMDAwMDA6IDB4ODAwMTAsXFxuXFx0XFx0XFx0MHgxYjAwMDAwMDogMHg0MDAwMDAxMCxcXG5cXHRcXHRcXHQweDFjMDAwMDAwOiAweDg0MDAwLFxcblxcdFxcdFxcdDB4MWQwMDAwMDA6IDB4NDAwMDQwMDAsXFxuXFx0XFx0XFx0MHgxZTAwMDAwMDogMHg0MDAwMDAwMCxcXG5cXHRcXHRcXHQweDFmMDAwMDAwOiAweDQwMDg0MDEwLFxcblxcdFxcdFxcdDB4MTA4MDAwMDA6IDB4ODQwMTAsXFxuXFx0XFx0XFx0MHgxMTgwMDAwMDogMHg4MDAwMCxcXG5cXHRcXHRcXHQweDEyODAwMDAwOiAweDQwMDgwMDAwLFxcblxcdFxcdFxcdDB4MTM4MDAwMDA6IDB4NDAwMCxcXG5cXHRcXHRcXHQweDE0ODAwMDAwOiAweDQwMDA0MDAwLFxcblxcdFxcdFxcdDB4MTU4MDAwMDA6IDB4NDAwODQwMTAsXFxuXFx0XFx0XFx0MHgxNjgwMDAwMDogMHgxMCxcXG5cXHRcXHRcXHQweDE3ODAwMDAwOiAweDQwMDAwMDAwLFxcblxcdFxcdFxcdDB4MTg4MDAwMDA6IDB4NDAwODQwMDAsXFxuXFx0XFx0XFx0MHgxOTgwMDAwMDogMHg0MDAwMDAxMCxcXG5cXHRcXHRcXHQweDFhODAwMDAwOiAweDQwMDA0MDEwLFxcblxcdFxcdFxcdDB4MWI4MDAwMDA6IDB4ODAwMTAsXFxuXFx0XFx0XFx0MHgxYzgwMDAwMDogMHgwLFxcblxcdFxcdFxcdDB4MWQ4MDAwMDA6IDB4NDAxMCxcXG5cXHRcXHRcXHQweDFlODAwMDAwOiAweDQwMDgwMDEwLFxcblxcdFxcdFxcdDB4MWY4MDAwMDA6IDB4ODQwMDBcXG5cXHRcXHR9LCB7XFxuXFx0XFx0XFx0MHgwOiAweDEwNCxcXG5cXHRcXHRcXHQweDEwMDAwMDogMHgwLFxcblxcdFxcdFxcdDB4MjAwMDAwOiAweDQwMDAxMDAsXFxuXFx0XFx0XFx0MHgzMDAwMDA6IDB4MTAxMDQsXFxuXFx0XFx0XFx0MHg0MDAwMDA6IDB4MTAwMDQsXFxuXFx0XFx0XFx0MHg1MDAwMDA6IDB4NDAwMDAwNCxcXG5cXHRcXHRcXHQweDYwMDAwMDogMHg0MDEwMTA0LFxcblxcdFxcdFxcdDB4NzAwMDAwOiAweDQwMTAwMDAsXFxuXFx0XFx0XFx0MHg4MDAwMDA6IDB4NDAwMDAwMCxcXG5cXHRcXHRcXHQweDkwMDAwMDogMHg0MDEwMTAwLFxcblxcdFxcdFxcdDB4YTAwMDAwOiAweDEwMTAwLFxcblxcdFxcdFxcdDB4YjAwMDAwOiAweDQwMTAwMDQsXFxuXFx0XFx0XFx0MHhjMDAwMDA6IDB4NDAwMDEwNCxcXG5cXHRcXHRcXHQweGQwMDAwMDogMHgxMDAwMCxcXG5cXHRcXHRcXHQweGUwMDAwMDogMHg0LFxcblxcdFxcdFxcdDB4ZjAwMDAwOiAweDEwMCxcXG5cXHRcXHRcXHQweDgwMDAwOiAweDQwMTAxMDAsXFxuXFx0XFx0XFx0MHgxODAwMDA6IDB4NDAxMDAwNCxcXG5cXHRcXHRcXHQweDI4MDAwMDogMHgwLFxcblxcdFxcdFxcdDB4MzgwMDAwOiAweDQwMDAxMDAsXFxuXFx0XFx0XFx0MHg0ODAwMDA6IDB4NDAwMDAwNCxcXG5cXHRcXHRcXHQweDU4MDAwMDogMHgxMDAwMCxcXG5cXHRcXHRcXHQweDY4MDAwMDogMHgxMDAwNCxcXG5cXHRcXHRcXHQweDc4MDAwMDogMHgxMDQsXFxuXFx0XFx0XFx0MHg4ODAwMDA6IDB4NCxcXG5cXHRcXHRcXHQweDk4MDAwMDogMHgxMDAsXFxuXFx0XFx0XFx0MHhhODAwMDA6IDB4NDAxMDAwMCxcXG5cXHRcXHRcXHQweGI4MDAwMDogMHgxMDEwNCxcXG5cXHRcXHRcXHQweGM4MDAwMDogMHgxMDEwMCxcXG5cXHRcXHRcXHQweGQ4MDAwMDogMHg0MDAwMTA0LFxcblxcdFxcdFxcdDB4ZTgwMDAwOiAweDQwMTAxMDQsXFxuXFx0XFx0XFx0MHhmODAwMDA6IDB4NDAwMDAwMCxcXG5cXHRcXHRcXHQweDEwMDAwMDA6IDB4NDAxMDEwMCxcXG5cXHRcXHRcXHQweDExMDAwMDA6IDB4MTAwMDQsXFxuXFx0XFx0XFx0MHgxMjAwMDAwOiAweDEwMDAwLFxcblxcdFxcdFxcdDB4MTMwMDAwMDogMHg0MDAwMTAwLFxcblxcdFxcdFxcdDB4MTQwMDAwMDogMHgxMDAsXFxuXFx0XFx0XFx0MHgxNTAwMDAwOiAweDQwMTAxMDQsXFxuXFx0XFx0XFx0MHgxNjAwMDAwOiAweDQwMDAwMDQsXFxuXFx0XFx0XFx0MHgxNzAwMDAwOiAweDAsXFxuXFx0XFx0XFx0MHgxODAwMDAwOiAweDQwMDAxMDQsXFxuXFx0XFx0XFx0MHgxOTAwMDAwOiAweDQwMDAwMDAsXFxuXFx0XFx0XFx0MHgxYTAwMDAwOiAweDQsXFxuXFx0XFx0XFx0MHgxYjAwMDAwOiAweDEwMTAwLFxcblxcdFxcdFxcdDB4MWMwMDAwMDogMHg0MDEwMDAwLFxcblxcdFxcdFxcdDB4MWQwMDAwMDogMHgxMDQsXFxuXFx0XFx0XFx0MHgxZTAwMDAwOiAweDEwMTA0LFxcblxcdFxcdFxcdDB4MWYwMDAwMDogMHg0MDEwMDA0LFxcblxcdFxcdFxcdDB4MTA4MDAwMDogMHg0MDAwMDAwLFxcblxcdFxcdFxcdDB4MTE4MDAwMDogMHgxMDQsXFxuXFx0XFx0XFx0MHgxMjgwMDAwOiAweDQwMTAxMDAsXFxuXFx0XFx0XFx0MHgxMzgwMDAwOiAweDAsXFxuXFx0XFx0XFx0MHgxNDgwMDAwOiAweDEwMDA0LFxcblxcdFxcdFxcdDB4MTU4MDAwMDogMHg0MDAwMTAwLFxcblxcdFxcdFxcdDB4MTY4MDAwMDogMHgxMDAsXFxuXFx0XFx0XFx0MHgxNzgwMDAwOiAweDQwMTAwMDQsXFxuXFx0XFx0XFx0MHgxODgwMDAwOiAweDEwMDAwLFxcblxcdFxcdFxcdDB4MTk4MDAwMDogMHg0MDEwMTA0LFxcblxcdFxcdFxcdDB4MWE4MDAwMDogMHgxMDEwNCxcXG5cXHRcXHRcXHQweDFiODAwMDA6IDB4NDAwMDAwNCxcXG5cXHRcXHRcXHQweDFjODAwMDA6IDB4NDAwMDEwNCxcXG5cXHRcXHRcXHQweDFkODAwMDA6IDB4NDAxMDAwMCxcXG5cXHRcXHRcXHQweDFlODAwMDA6IDB4NCxcXG5cXHRcXHRcXHQweDFmODAwMDA6IDB4MTAxMDBcXG5cXHRcXHR9LCB7XFxuXFx0XFx0XFx0MHgwOiAweDgwNDAxMDAwLFxcblxcdFxcdFxcdDB4MTAwMDA6IDB4ODAwMDEwNDAsXFxuXFx0XFx0XFx0MHgyMDAwMDogMHg0MDEwNDAsXFxuXFx0XFx0XFx0MHgzMDAwMDogMHg4MDQwMDAwMCxcXG5cXHRcXHRcXHQweDQwMDAwOiAweDAsXFxuXFx0XFx0XFx0MHg1MDAwMDogMHg0MDEwMDAsXFxuXFx0XFx0XFx0MHg2MDAwMDogMHg4MDAwMDA0MCxcXG5cXHRcXHRcXHQweDcwMDAwOiAweDQwMDA0MCxcXG5cXHRcXHRcXHQweDgwMDAwOiAweDgwMDAwMDAwLFxcblxcdFxcdFxcdDB4OTAwMDA6IDB4NDAwMDAwLFxcblxcdFxcdFxcdDB4YTAwMDA6IDB4NDAsXFxuXFx0XFx0XFx0MHhiMDAwMDogMHg4MDAwMTAwMCxcXG5cXHRcXHRcXHQweGMwMDAwOiAweDgwNDAwMDQwLFxcblxcdFxcdFxcdDB4ZDAwMDA6IDB4MTA0MCxcXG5cXHRcXHRcXHQweGUwMDAwOiAweDEwMDAsXFxuXFx0XFx0XFx0MHhmMDAwMDogMHg4MDQwMTA0MCxcXG5cXHRcXHRcXHQweDgwMDA6IDB4ODAwMDEwNDAsXFxuXFx0XFx0XFx0MHgxODAwMDogMHg0MCxcXG5cXHRcXHRcXHQweDI4MDAwOiAweDgwNDAwMDQwLFxcblxcdFxcdFxcdDB4MzgwMDA6IDB4ODAwMDEwMDAsXFxuXFx0XFx0XFx0MHg0ODAwMDogMHg0MDEwMDAsXFxuXFx0XFx0XFx0MHg1ODAwMDogMHg4MDQwMTA0MCxcXG5cXHRcXHRcXHQweDY4MDAwOiAweDAsXFxuXFx0XFx0XFx0MHg3ODAwMDogMHg4MDQwMDAwMCxcXG5cXHRcXHRcXHQweDg4MDAwOiAweDEwMDAsXFxuXFx0XFx0XFx0MHg5ODAwMDogMHg4MDQwMTAwMCxcXG5cXHRcXHRcXHQweGE4MDAwOiAweDQwMDAwMCxcXG5cXHRcXHRcXHQweGI4MDAwOiAweDEwNDAsXFxuXFx0XFx0XFx0MHhjODAwMDogMHg4MDAwMDAwMCxcXG5cXHRcXHRcXHQweGQ4MDAwOiAweDQwMDA0MCxcXG5cXHRcXHRcXHQweGU4MDAwOiAweDQwMTA0MCxcXG5cXHRcXHRcXHQweGY4MDAwOiAweDgwMDAwMDQwLFxcblxcdFxcdFxcdDB4MTAwMDAwOiAweDQwMDA0MCxcXG5cXHRcXHRcXHQweDExMDAwMDogMHg0MDEwMDAsXFxuXFx0XFx0XFx0MHgxMjAwMDA6IDB4ODAwMDAwNDAsXFxuXFx0XFx0XFx0MHgxMzAwMDA6IDB4MCxcXG5cXHRcXHRcXHQweDE0MDAwMDogMHgxMDQwLFxcblxcdFxcdFxcdDB4MTUwMDAwOiAweDgwNDAwMDQwLFxcblxcdFxcdFxcdDB4MTYwMDAwOiAweDgwNDAxMDAwLFxcblxcdFxcdFxcdDB4MTcwMDAwOiAweDgwMDAxMDQwLFxcblxcdFxcdFxcdDB4MTgwMDAwOiAweDgwNDAxMDQwLFxcblxcdFxcdFxcdDB4MTkwMDAwOiAweDgwMDAwMDAwLFxcblxcdFxcdFxcdDB4MWEwMDAwOiAweDgwNDAwMDAwLFxcblxcdFxcdFxcdDB4MWIwMDAwOiAweDQwMTA0MCxcXG5cXHRcXHRcXHQweDFjMDAwMDogMHg4MDAwMTAwMCxcXG5cXHRcXHRcXHQweDFkMDAwMDogMHg0MDAwMDAsXFxuXFx0XFx0XFx0MHgxZTAwMDA6IDB4NDAsXFxuXFx0XFx0XFx0MHgxZjAwMDA6IDB4MTAwMCxcXG5cXHRcXHRcXHQweDEwODAwMDogMHg4MDQwMDAwMCxcXG5cXHRcXHRcXHQweDExODAwMDogMHg4MDQwMTA0MCxcXG5cXHRcXHRcXHQweDEyODAwMDogMHgwLFxcblxcdFxcdFxcdDB4MTM4MDAwOiAweDQwMTAwMCxcXG5cXHRcXHRcXHQweDE0ODAwMDogMHg0MDAwNDAsXFxuXFx0XFx0XFx0MHgxNTgwMDA6IDB4ODAwMDAwMDAsXFxuXFx0XFx0XFx0MHgxNjgwMDA6IDB4ODAwMDEwNDAsXFxuXFx0XFx0XFx0MHgxNzgwMDA6IDB4NDAsXFxuXFx0XFx0XFx0MHgxODgwMDA6IDB4ODAwMDAwNDAsXFxuXFx0XFx0XFx0MHgxOTgwMDA6IDB4MTAwMCxcXG5cXHRcXHRcXHQweDFhODAwMDogMHg4MDAwMTAwMCxcXG5cXHRcXHRcXHQweDFiODAwMDogMHg4MDQwMDA0MCxcXG5cXHRcXHRcXHQweDFjODAwMDogMHgxMDQwLFxcblxcdFxcdFxcdDB4MWQ4MDAwOiAweDgwNDAxMDAwLFxcblxcdFxcdFxcdDB4MWU4MDAwOiAweDQwMDAwMCxcXG5cXHRcXHRcXHQweDFmODAwMDogMHg0MDEwNDBcXG5cXHRcXHR9LCB7XFxuXFx0XFx0XFx0MHgwOiAweDgwLFxcblxcdFxcdFxcdDB4MTAwMDogMHgxMDQwMDAwLFxcblxcdFxcdFxcdDB4MjAwMDogMHg0MDAwMCxcXG5cXHRcXHRcXHQweDMwMDA6IDB4MjAwMDAwMDAsXFxuXFx0XFx0XFx0MHg0MDAwOiAweDIwMDQwMDgwLFxcblxcdFxcdFxcdDB4NTAwMDogMHgxMDAwMDgwLFxcblxcdFxcdFxcdDB4NjAwMDogMHgyMTAwMDA4MCxcXG5cXHRcXHRcXHQweDcwMDA6IDB4NDAwODAsXFxuXFx0XFx0XFx0MHg4MDAwOiAweDEwMDAwMDAsXFxuXFx0XFx0XFx0MHg5MDAwOiAweDIwMDQwMDAwLFxcblxcdFxcdFxcdDB4YTAwMDogMHgyMDAwMDA4MCxcXG5cXHRcXHRcXHQweGIwMDA6IDB4MjEwNDAwODAsXFxuXFx0XFx0XFx0MHhjMDAwOiAweDIxMDQwMDAwLFxcblxcdFxcdFxcdDB4ZDAwMDogMHgwLFxcblxcdFxcdFxcdDB4ZTAwMDogMHgxMDQwMDgwLFxcblxcdFxcdFxcdDB4ZjAwMDogMHgyMTAwMDAwMCxcXG5cXHRcXHRcXHQweDgwMDogMHgxMDQwMDgwLFxcblxcdFxcdFxcdDB4MTgwMDogMHgyMTAwMDA4MCxcXG5cXHRcXHRcXHQweDI4MDA6IDB4ODAsXFxuXFx0XFx0XFx0MHgzODAwOiAweDEwNDAwMDAsXFxuXFx0XFx0XFx0MHg0ODAwOiAweDQwMDAwLFxcblxcdFxcdFxcdDB4NTgwMDogMHgyMDA0MDA4MCxcXG5cXHRcXHRcXHQweDY4MDA6IDB4MjEwNDAwMDAsXFxuXFx0XFx0XFx0MHg3ODAwOiAweDIwMDAwMDAwLFxcblxcdFxcdFxcdDB4ODgwMDogMHgyMDA0MDAwMCxcXG5cXHRcXHRcXHQweDk4MDA6IDB4MCxcXG5cXHRcXHRcXHQweGE4MDA6IDB4MjEwNDAwODAsXFxuXFx0XFx0XFx0MHhiODAwOiAweDEwMDAwODAsXFxuXFx0XFx0XFx0MHhjODAwOiAweDIwMDAwMDgwLFxcblxcdFxcdFxcdDB4ZDgwMDogMHgyMTAwMDAwMCxcXG5cXHRcXHRcXHQweGU4MDA6IDB4MTAwMDAwMCxcXG5cXHRcXHRcXHQweGY4MDA6IDB4NDAwODAsXFxuXFx0XFx0XFx0MHgxMDAwMDogMHg0MDAwMCxcXG5cXHRcXHRcXHQweDExMDAwOiAweDgwLFxcblxcdFxcdFxcdDB4MTIwMDA6IDB4MjAwMDAwMDAsXFxuXFx0XFx0XFx0MHgxMzAwMDogMHgyMTAwMDA4MCxcXG5cXHRcXHRcXHQweDE0MDAwOiAweDEwMDAwODAsXFxuXFx0XFx0XFx0MHgxNTAwMDogMHgyMTA0MDAwMCxcXG5cXHRcXHRcXHQweDE2MDAwOiAweDIwMDQwMDgwLFxcblxcdFxcdFxcdDB4MTcwMDA6IDB4MTAwMDAwMCxcXG5cXHRcXHRcXHQweDE4MDAwOiAweDIxMDQwMDgwLFxcblxcdFxcdFxcdDB4MTkwMDA6IDB4MjEwMDAwMDAsXFxuXFx0XFx0XFx0MHgxYTAwMDogMHgxMDQwMDAwLFxcblxcdFxcdFxcdDB4MWIwMDA6IDB4MjAwNDAwMDAsXFxuXFx0XFx0XFx0MHgxYzAwMDogMHg0MDA4MCxcXG5cXHRcXHRcXHQweDFkMDAwOiAweDIwMDAwMDgwLFxcblxcdFxcdFxcdDB4MWUwMDA6IDB4MCxcXG5cXHRcXHRcXHQweDFmMDAwOiAweDEwNDAwODAsXFxuXFx0XFx0XFx0MHgxMDgwMDogMHgyMTAwMDA4MCxcXG5cXHRcXHRcXHQweDExODAwOiAweDEwMDAwMDAsXFxuXFx0XFx0XFx0MHgxMjgwMDogMHgxMDQwMDAwLFxcblxcdFxcdFxcdDB4MTM4MDA6IDB4MjAwNDAwODAsXFxuXFx0XFx0XFx0MHgxNDgwMDogMHgyMDAwMDAwMCxcXG5cXHRcXHRcXHQweDE1ODAwOiAweDEwNDAwODAsXFxuXFx0XFx0XFx0MHgxNjgwMDogMHg4MCxcXG5cXHRcXHRcXHQweDE3ODAwOiAweDIxMDQwMDAwLFxcblxcdFxcdFxcdDB4MTg4MDA6IDB4NDAwODAsXFxuXFx0XFx0XFx0MHgxOTgwMDogMHgyMTA0MDA4MCxcXG5cXHRcXHRcXHQweDFhODAwOiAweDAsXFxuXFx0XFx0XFx0MHgxYjgwMDogMHgyMTAwMDAwMCxcXG5cXHRcXHRcXHQweDFjODAwOiAweDEwMDAwODAsXFxuXFx0XFx0XFx0MHgxZDgwMDogMHg0MDAwMCxcXG5cXHRcXHRcXHQweDFlODAwOiAweDIwMDQwMDAwLFxcblxcdFxcdFxcdDB4MWY4MDA6IDB4MjAwMDAwODBcXG5cXHRcXHR9LCB7XFxuXFx0XFx0XFx0MHgwOiAweDEwMDAwMDA4LFxcblxcdFxcdFxcdDB4MTAwOiAweDIwMDAsXFxuXFx0XFx0XFx0MHgyMDA6IDB4MTAyMDAwMDAsXFxuXFx0XFx0XFx0MHgzMDA6IDB4MTAyMDIwMDgsXFxuXFx0XFx0XFx0MHg0MDA6IDB4MTAwMDIwMDAsXFxuXFx0XFx0XFx0MHg1MDA6IDB4MjAwMDAwLFxcblxcdFxcdFxcdDB4NjAwOiAweDIwMDAwOCxcXG5cXHRcXHRcXHQweDcwMDogMHgxMDAwMDAwMCxcXG5cXHRcXHRcXHQweDgwMDogMHgwLFxcblxcdFxcdFxcdDB4OTAwOiAweDEwMDAyMDA4LFxcblxcdFxcdFxcdDB4YTAwOiAweDIwMjAwMCxcXG5cXHRcXHRcXHQweGIwMDogMHg4LFxcblxcdFxcdFxcdDB4YzAwOiAweDEwMjAwMDA4LFxcblxcdFxcdFxcdDB4ZDAwOiAweDIwMjAwOCxcXG5cXHRcXHRcXHQweGUwMDogMHgyMDA4LFxcblxcdFxcdFxcdDB4ZjAwOiAweDEwMjAyMDAwLFxcblxcdFxcdFxcdDB4ODA6IDB4MTAyMDAwMDAsXFxuXFx0XFx0XFx0MHgxODA6IDB4MTAyMDIwMDgsXFxuXFx0XFx0XFx0MHgyODA6IDB4OCxcXG5cXHRcXHRcXHQweDM4MDogMHgyMDAwMDAsXFxuXFx0XFx0XFx0MHg0ODA6IDB4MjAyMDA4LFxcblxcdFxcdFxcdDB4NTgwOiAweDEwMDAwMDA4LFxcblxcdFxcdFxcdDB4NjgwOiAweDEwMDAyMDAwLFxcblxcdFxcdFxcdDB4NzgwOiAweDIwMDgsXFxuXFx0XFx0XFx0MHg4ODA6IDB4MjAwMDA4LFxcblxcdFxcdFxcdDB4OTgwOiAweDIwMDAsXFxuXFx0XFx0XFx0MHhhODA6IDB4MTAwMDIwMDgsXFxuXFx0XFx0XFx0MHhiODA6IDB4MTAyMDAwMDgsXFxuXFx0XFx0XFx0MHhjODA6IDB4MCxcXG5cXHRcXHRcXHQweGQ4MDogMHgxMDIwMjAwMCxcXG5cXHRcXHRcXHQweGU4MDogMHgyMDIwMDAsXFxuXFx0XFx0XFx0MHhmODA6IDB4MTAwMDAwMDAsXFxuXFx0XFx0XFx0MHgxMDAwOiAweDEwMDAyMDAwLFxcblxcdFxcdFxcdDB4MTEwMDogMHgxMDIwMDAwOCxcXG5cXHRcXHRcXHQweDEyMDA6IDB4MTAyMDIwMDgsXFxuXFx0XFx0XFx0MHgxMzAwOiAweDIwMDgsXFxuXFx0XFx0XFx0MHgxNDAwOiAweDIwMDAwMCxcXG5cXHRcXHRcXHQweDE1MDA6IDB4MTAwMDAwMDAsXFxuXFx0XFx0XFx0MHgxNjAwOiAweDEwMDAwMDA4LFxcblxcdFxcdFxcdDB4MTcwMDogMHgyMDIwMDAsXFxuXFx0XFx0XFx0MHgxODAwOiAweDIwMjAwOCxcXG5cXHRcXHRcXHQweDE5MDA6IDB4MCxcXG5cXHRcXHRcXHQweDFhMDA6IDB4OCxcXG5cXHRcXHRcXHQweDFiMDA6IDB4MTAyMDAwMDAsXFxuXFx0XFx0XFx0MHgxYzAwOiAweDIwMDAsXFxuXFx0XFx0XFx0MHgxZDAwOiAweDEwMDAyMDA4LFxcblxcdFxcdFxcdDB4MWUwMDogMHgxMDIwMjAwMCxcXG5cXHRcXHRcXHQweDFmMDA6IDB4MjAwMDA4LFxcblxcdFxcdFxcdDB4MTA4MDogMHg4LFxcblxcdFxcdFxcdDB4MTE4MDogMHgyMDIwMDAsXFxuXFx0XFx0XFx0MHgxMjgwOiAweDIwMDAwMCxcXG5cXHRcXHRcXHQweDEzODA6IDB4MTAwMDAwMDgsXFxuXFx0XFx0XFx0MHgxNDgwOiAweDEwMDAyMDAwLFxcblxcdFxcdFxcdDB4MTU4MDogMHgyMDA4LFxcblxcdFxcdFxcdDB4MTY4MDogMHgxMDIwMjAwOCxcXG5cXHRcXHRcXHQweDE3ODA6IDB4MTAyMDAwMDAsXFxuXFx0XFx0XFx0MHgxODgwOiAweDEwMjAyMDAwLFxcblxcdFxcdFxcdDB4MTk4MDogMHgxMDIwMDAwOCxcXG5cXHRcXHRcXHQweDFhODA6IDB4MjAwMCxcXG5cXHRcXHRcXHQweDFiODA6IDB4MjAyMDA4LFxcblxcdFxcdFxcdDB4MWM4MDogMHgyMDAwMDgsXFxuXFx0XFx0XFx0MHgxZDgwOiAweDAsXFxuXFx0XFx0XFx0MHgxZTgwOiAweDEwMDAwMDAwLFxcblxcdFxcdFxcdDB4MWY4MDogMHgxMDAwMjAwOFxcblxcdFxcdH0sIHtcXG5cXHRcXHRcXHQweDA6IDB4MTAwMDAwLFxcblxcdFxcdFxcdDB4MTA6IDB4MjAwMDQwMSxcXG5cXHRcXHRcXHQweDIwOiAweDQwMCxcXG5cXHRcXHRcXHQweDMwOiAweDEwMDQwMSxcXG5cXHRcXHRcXHQweDQwOiAweDIxMDA0MDEsXFxuXFx0XFx0XFx0MHg1MDogMHgwLFxcblxcdFxcdFxcdDB4NjA6IDB4MSxcXG5cXHRcXHRcXHQweDcwOiAweDIxMDAwMDEsXFxuXFx0XFx0XFx0MHg4MDogMHgyMDAwNDAwLFxcblxcdFxcdFxcdDB4OTA6IDB4MTAwMDAxLFxcblxcdFxcdFxcdDB4YTA6IDB4MjAwMDAwMSxcXG5cXHRcXHRcXHQweGIwOiAweDIxMDA0MDAsXFxuXFx0XFx0XFx0MHhjMDogMHgyMTAwMDAwLFxcblxcdFxcdFxcdDB4ZDA6IDB4NDAxLFxcblxcdFxcdFxcdDB4ZTA6IDB4MTAwNDAwLFxcblxcdFxcdFxcdDB4ZjA6IDB4MjAwMDAwMCxcXG5cXHRcXHRcXHQweDg6IDB4MjEwMDAwMSxcXG5cXHRcXHRcXHQweDE4OiAweDAsXFxuXFx0XFx0XFx0MHgyODogMHgyMDAwNDAxLFxcblxcdFxcdFxcdDB4Mzg6IDB4MjEwMDQwMCxcXG5cXHRcXHRcXHQweDQ4OiAweDEwMDAwMCxcXG5cXHRcXHRcXHQweDU4OiAweDIwMDAwMDEsXFxuXFx0XFx0XFx0MHg2ODogMHgyMDAwMDAwLFxcblxcdFxcdFxcdDB4Nzg6IDB4NDAxLFxcblxcdFxcdFxcdDB4ODg6IDB4MTAwNDAxLFxcblxcdFxcdFxcdDB4OTg6IDB4MjAwMDQwMCxcXG5cXHRcXHRcXHQweGE4OiAweDIxMDAwMDAsXFxuXFx0XFx0XFx0MHhiODogMHgxMDAwMDEsXFxuXFx0XFx0XFx0MHhjODogMHg0MDAsXFxuXFx0XFx0XFx0MHhkODogMHgyMTAwNDAxLFxcblxcdFxcdFxcdDB4ZTg6IDB4MSxcXG5cXHRcXHRcXHQweGY4OiAweDEwMDQwMCxcXG5cXHRcXHRcXHQweDEwMDogMHgyMDAwMDAwLFxcblxcdFxcdFxcdDB4MTEwOiAweDEwMDAwMCxcXG5cXHRcXHRcXHQweDEyMDogMHgyMDAwNDAxLFxcblxcdFxcdFxcdDB4MTMwOiAweDIxMDAwMDEsXFxuXFx0XFx0XFx0MHgxNDA6IDB4MTAwMDAxLFxcblxcdFxcdFxcdDB4MTUwOiAweDIwMDA0MDAsXFxuXFx0XFx0XFx0MHgxNjA6IDB4MjEwMDQwMCxcXG5cXHRcXHRcXHQweDE3MDogMHgxMDA0MDEsXFxuXFx0XFx0XFx0MHgxODA6IDB4NDAxLFxcblxcdFxcdFxcdDB4MTkwOiAweDIxMDA0MDEsXFxuXFx0XFx0XFx0MHgxYTA6IDB4MTAwNDAwLFxcblxcdFxcdFxcdDB4MWIwOiAweDEsXFxuXFx0XFx0XFx0MHgxYzA6IDB4MCxcXG5cXHRcXHRcXHQweDFkMDogMHgyMTAwMDAwLFxcblxcdFxcdFxcdDB4MWUwOiAweDIwMDAwMDEsXFxuXFx0XFx0XFx0MHgxZjA6IDB4NDAwLFxcblxcdFxcdFxcdDB4MTA4OiAweDEwMDQwMCxcXG5cXHRcXHRcXHQweDExODogMHgyMDAwNDAxLFxcblxcdFxcdFxcdDB4MTI4OiAweDIxMDAwMDEsXFxuXFx0XFx0XFx0MHgxMzg6IDB4MSxcXG5cXHRcXHRcXHQweDE0ODogMHgyMDAwMDAwLFxcblxcdFxcdFxcdDB4MTU4OiAweDEwMDAwMCxcXG5cXHRcXHRcXHQweDE2ODogMHg0MDEsXFxuXFx0XFx0XFx0MHgxNzg6IDB4MjEwMDQwMCxcXG5cXHRcXHRcXHQweDE4ODogMHgyMDAwMDAxLFxcblxcdFxcdFxcdDB4MTk4OiAweDIxMDAwMDAsXFxuXFx0XFx0XFx0MHgxYTg6IDB4MCxcXG5cXHRcXHRcXHQweDFiODogMHgyMTAwNDAxLFxcblxcdFxcdFxcdDB4MWM4OiAweDEwMDQwMSxcXG5cXHRcXHRcXHQweDFkODogMHg0MDAsXFxuXFx0XFx0XFx0MHgxZTg6IDB4MjAwMDQwMCxcXG5cXHRcXHRcXHQweDFmODogMHgxMDAwMDFcXG5cXHRcXHR9LCB7XFxuXFx0XFx0XFx0MHgwOiAweDgwMDA4MjAsXFxuXFx0XFx0XFx0MHgxOiAweDIwMDAwLFxcblxcdFxcdFxcdDB4MjogMHg4MDAwMDAwLFxcblxcdFxcdFxcdDB4MzogMHgyMCxcXG5cXHRcXHRcXHQweDQ6IDB4MjAwMjAsXFxuXFx0XFx0XFx0MHg1OiAweDgwMjA4MjAsXFxuXFx0XFx0XFx0MHg2OiAweDgwMjA4MDAsXFxuXFx0XFx0XFx0MHg3OiAweDgwMCxcXG5cXHRcXHRcXHQweDg6IDB4ODAyMDAwMCxcXG5cXHRcXHRcXHQweDk6IDB4ODAwMDgwMCxcXG5cXHRcXHRcXHQweGE6IDB4MjA4MDAsXFxuXFx0XFx0XFx0MHhiOiAweDgwMjAwMjAsXFxuXFx0XFx0XFx0MHhjOiAweDgyMCxcXG5cXHRcXHRcXHQweGQ6IDB4MCxcXG5cXHRcXHRcXHQweGU6IDB4ODAwMDAyMCxcXG5cXHRcXHRcXHQweGY6IDB4MjA4MjAsXFxuXFx0XFx0XFx0MHg4MDAwMDAwMDogMHg4MDAsXFxuXFx0XFx0XFx0MHg4MDAwMDAwMTogMHg4MDIwODIwLFxcblxcdFxcdFxcdDB4ODAwMDAwMDI6IDB4ODAwMDgyMCxcXG5cXHRcXHRcXHQweDgwMDAwMDAzOiAweDgwMDAwMDAsXFxuXFx0XFx0XFx0MHg4MDAwMDAwNDogMHg4MDIwMDAwLFxcblxcdFxcdFxcdDB4ODAwMDAwMDU6IDB4MjA4MDAsXFxuXFx0XFx0XFx0MHg4MDAwMDAwNjogMHgyMDgyMCxcXG5cXHRcXHRcXHQweDgwMDAwMDA3OiAweDIwLFxcblxcdFxcdFxcdDB4ODAwMDAwMDg6IDB4ODAwMDAyMCxcXG5cXHRcXHRcXHQweDgwMDAwMDA5OiAweDgyMCxcXG5cXHRcXHRcXHQweDgwMDAwMDBhOiAweDIwMDIwLFxcblxcdFxcdFxcdDB4ODAwMDAwMGI6IDB4ODAyMDgwMCxcXG5cXHRcXHRcXHQweDgwMDAwMDBjOiAweDAsXFxuXFx0XFx0XFx0MHg4MDAwMDAwZDogMHg4MDIwMDIwLFxcblxcdFxcdFxcdDB4ODAwMDAwMGU6IDB4ODAwMDgwMCxcXG5cXHRcXHRcXHQweDgwMDAwMDBmOiAweDIwMDAwLFxcblxcdFxcdFxcdDB4MTA6IDB4MjA4MjAsXFxuXFx0XFx0XFx0MHgxMTogMHg4MDIwODAwLFxcblxcdFxcdFxcdDB4MTI6IDB4MjAsXFxuXFx0XFx0XFx0MHgxMzogMHg4MDAsXFxuXFx0XFx0XFx0MHgxNDogMHg4MDAwODAwLFxcblxcdFxcdFxcdDB4MTU6IDB4ODAwMDAyMCxcXG5cXHRcXHRcXHQweDE2OiAweDgwMjAwMjAsXFxuXFx0XFx0XFx0MHgxNzogMHgyMDAwMCxcXG5cXHRcXHRcXHQweDE4OiAweDAsXFxuXFx0XFx0XFx0MHgxOTogMHgyMDAyMCxcXG5cXHRcXHRcXHQweDFhOiAweDgwMjAwMDAsXFxuXFx0XFx0XFx0MHgxYjogMHg4MDAwODIwLFxcblxcdFxcdFxcdDB4MWM6IDB4ODAyMDgyMCxcXG5cXHRcXHRcXHQweDFkOiAweDIwODAwLFxcblxcdFxcdFxcdDB4MWU6IDB4ODIwLFxcblxcdFxcdFxcdDB4MWY6IDB4ODAwMDAwMCxcXG5cXHRcXHRcXHQweDgwMDAwMDEwOiAweDIwMDAwLFxcblxcdFxcdFxcdDB4ODAwMDAwMTE6IDB4ODAwLFxcblxcdFxcdFxcdDB4ODAwMDAwMTI6IDB4ODAyMDAyMCxcXG5cXHRcXHRcXHQweDgwMDAwMDEzOiAweDIwODIwLFxcblxcdFxcdFxcdDB4ODAwMDAwMTQ6IDB4MjAsXFxuXFx0XFx0XFx0MHg4MDAwMDAxNTogMHg4MDIwMDAwLFxcblxcdFxcdFxcdDB4ODAwMDAwMTY6IDB4ODAwMDAwMCxcXG5cXHRcXHRcXHQweDgwMDAwMDE3OiAweDgwMDA4MjAsXFxuXFx0XFx0XFx0MHg4MDAwMDAxODogMHg4MDIwODIwLFxcblxcdFxcdFxcdDB4ODAwMDAwMTk6IDB4ODAwMDAyMCxcXG5cXHRcXHRcXHQweDgwMDAwMDFhOiAweDgwMDA4MDAsXFxuXFx0XFx0XFx0MHg4MDAwMDAxYjogMHgwLFxcblxcdFxcdFxcdDB4ODAwMDAwMWM6IDB4MjA4MDAsXFxuXFx0XFx0XFx0MHg4MDAwMDAxZDogMHg4MjAsXFxuXFx0XFx0XFx0MHg4MDAwMDAxZTogMHgyMDAyMCxcXG5cXHRcXHRcXHQweDgwMDAwMDFmOiAweDgwMjA4MDBcXG5cXHRcXHR9XTtcXG5cXG5cXHRcXHQvLyBNYXNrcyB0aGF0IHNlbGVjdCB0aGUgU0JPWCBpbnB1dFxcblxcdFxcdHZhciBTQk9YX01BU0sgPSBbMHhmODAwMDAwMSwgMHgxZjgwMDAwMCwgMHgwMWY4MDAwMCwgMHgwMDFmODAwMCwgMHgwMDAxZjgwMCwgMHgwMDAwMWY4MCwgMHgwMDAwMDFmOCwgMHg4MDAwMDAxZl07XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBERVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cXG4gICAqL1xcblxcdFxcdHZhciBERVMgPSBDX2FsZ28uREVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcXG5cXHRcXHRcXHRfZG9SZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBrZXkgPSB0aGlzLl9rZXk7XFxuXFx0XFx0XFx0XFx0dmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xcblxcblxcdFxcdFxcdFxcdC8vIFNlbGVjdCA1NiBiaXRzIGFjY29yZGluZyB0byBQQzFcXG5cXHRcXHRcXHRcXHR2YXIga2V5Qml0cyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgNTY7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHZhciBrZXlCaXRQb3MgPSBQQzFbaV0gLSAxO1xcblxcdFxcdFxcdFxcdFxcdGtleUJpdHNbaV0gPSBrZXlXb3Jkc1trZXlCaXRQb3MgPj4+IDVdID4+PiAzMSAtIGtleUJpdFBvcyAlIDMyICYgMTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXNzZW1ibGUgMTYgc3Via2V5c1xcblxcdFxcdFxcdFxcdHZhciBzdWJLZXlzID0gdGhpcy5fc3ViS2V5cyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIG5TdWJLZXkgPSAwOyBuU3ViS2V5IDwgMTY7IG5TdWJLZXkrKykge1xcblxcdFxcdFxcdFxcdFxcdC8vIENyZWF0ZSBzdWJrZXlcXG5cXHRcXHRcXHRcXHRcXHR2YXIgc3ViS2V5ID0gc3ViS2V5c1tuU3ViS2V5XSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJpdFNoaWZ0ID0gQklUX1NISUZUU1tuU3ViS2V5XTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZWxlY3QgNDggYml0cyBhY2NvcmRpbmcgdG8gUEMyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2VsZWN0IGZyb20gdGhlIGxlZnQgMjgga2V5IGJpdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdWJLZXlbaSAvIDYgfCAwXSB8PSBrZXlCaXRzWyhQQzJbaV0gLSAxICsgYml0U2hpZnQpICUgMjhdIDw8IDMxIC0gaSAlIDY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2VsZWN0IGZyb20gdGhlIHJpZ2h0IDI4IGtleSBiaXRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3ViS2V5WzQgKyAoaSAvIDYgfCAwKV0gfD0ga2V5Qml0c1syOCArIChQQzJbaSArIDI0XSAtIDEgKyBiaXRTaGlmdCkgJSAyOF0gPDwgMzEgLSBpICUgNjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2luY2UgZWFjaCBzdWJrZXkgaXMgYXBwbGllZCB0byBhbiBleHBhbmRlZCAzMi1iaXQgaW5wdXQsXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhlIHN1YmtleSBjYW4gYmUgYnJva2VuIGludG8gOCB2YWx1ZXMgc2NhbGVkIHRvIDMyLWJpdHMsXFxuXFx0XFx0XFx0XFx0XFx0Ly8gd2hpY2ggYWxsb3dzIHRoZSBrZXkgdG8gYmUgdXNlZCB3aXRob3V0IGV4cGFuc2lvblxcblxcdFxcdFxcdFxcdFxcdHN1YktleVswXSA9IHN1YktleVswXSA8PCAxIHwgc3ViS2V5WzBdID4+PiAzMTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHZhciBpID0gMTsgaSA8IDc7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN1YktleVtpXSA9IHN1YktleVtpXSA+Pj4gKGkgLSAxKSAqIDQgKyAzO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRzdWJLZXlbN10gPSBzdWJLZXlbN10gPDwgNSB8IHN1YktleVs3XSA+Pj4gMjc7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENvbXB1dGUgaW52ZXJzZSBzdWJrZXlzXFxuXFx0XFx0XFx0XFx0dmFyIGludlN1YktleXMgPSB0aGlzLl9pbnZTdWJLZXlzID0gW107XFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW52U3ViS2V5c1tpXSA9IHN1YktleXNbMTUgLSBpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9zdWJLZXlzKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludlN1YktleXMpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwgc3ViS2V5cykge1xcblxcdFxcdFxcdFxcdC8vIEdldCBpbnB1dFxcblxcdFxcdFxcdFxcdHRoaXMuX2xCbG9jayA9IE1bb2Zmc2V0XTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9yQmxvY2sgPSBNW29mZnNldCArIDFdO1xcblxcblxcdFxcdFxcdFxcdC8vIEluaXRpYWwgcGVybXV0YXRpb25cXG5cXHRcXHRcXHRcXHRleGNoYW5nZUxSLmNhbGwodGhpcywgNCwgMHgwZjBmMGYwZik7XFxuXFx0XFx0XFx0XFx0ZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDE2LCAweDAwMDBmZmZmKTtcXG5cXHRcXHRcXHRcXHRleGNoYW5nZVJMLmNhbGwodGhpcywgMiwgMHgzMzMzMzMzMyk7XFxuXFx0XFx0XFx0XFx0ZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsIDB4MDBmZjAwZmYpO1xcblxcdFxcdFxcdFxcdGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAweDU1NTU1NTU1KTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSb3VuZHNcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgMTY7IHJvdW5kKyspIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBTaG9ydGN1dHNcXG5cXHRcXHRcXHRcXHRcXHR2YXIgc3ViS2V5ID0gc3ViS2V5c1tyb3VuZF07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxCbG9jayA9IHRoaXMuX2xCbG9jaztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgckJsb2NrID0gdGhpcy5fckJsb2NrO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEZlaXN0ZWwgZnVuY3Rpb25cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmIHw9IFNCT1hfUFtpXVsoKHJCbG9jayBeIHN1YktleVtpXSkgJiBTQk9YX01BU0tbaV0pID4+PiAwXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbEJsb2NrID0gckJsb2NrO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JCbG9jayA9IGxCbG9jayBeIGY7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFVuZG8gc3dhcCBmcm9tIGxhc3Qgcm91bmRcXG5cXHRcXHRcXHRcXHR2YXIgdCA9IHRoaXMuX2xCbG9jaztcXG5cXHRcXHRcXHRcXHR0aGlzLl9sQmxvY2sgPSB0aGlzLl9yQmxvY2s7XFxuXFx0XFx0XFx0XFx0dGhpcy5fckJsb2NrID0gdDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaW5hbCBwZXJtdXRhdGlvblxcblxcdFxcdFxcdFxcdGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAweDU1NTU1NTU1KTtcXG5cXHRcXHRcXHRcXHRleGNoYW5nZVJMLmNhbGwodGhpcywgOCwgMHgwMGZmMDBmZik7XFxuXFx0XFx0XFx0XFx0ZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDIsIDB4MzMzMzMzMzMpO1xcblxcdFxcdFxcdFxcdGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxNiwgMHgwMDAwZmZmZik7XFxuXFx0XFx0XFx0XFx0ZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDQsIDB4MGYwZjBmMGYpO1xcblxcblxcdFxcdFxcdFxcdC8vIFNldCBvdXRwdXRcXG5cXHRcXHRcXHRcXHRNW29mZnNldF0gPSB0aGlzLl9sQmxvY2s7XFxuXFx0XFx0XFx0XFx0TVtvZmZzZXQgKyAxXSA9IHRoaXMuX3JCbG9jaztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGtleVNpemU6IDY0IC8gMzIsXFxuXFxuXFx0XFx0XFx0aXZTaXplOiA2NCAvIDMyLFxcblxcblxcdFxcdFxcdGJsb2NrU2l6ZTogNjQgLyAzMlxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8vIFN3YXAgYml0cyBhY3Jvc3MgdGhlIGxlZnQgYW5kIHJpZ2h0IHdvcmRzXFxuXFx0XFx0ZnVuY3Rpb24gZXhjaGFuZ2VMUihvZmZzZXQsIG1hc2spIHtcXG5cXHRcXHRcXHR2YXIgdCA9ICh0aGlzLl9sQmxvY2sgPj4+IG9mZnNldCBeIHRoaXMuX3JCbG9jaykgJiBtYXNrO1xcblxcdFxcdFxcdHRoaXMuX3JCbG9jayBePSB0O1xcblxcdFxcdFxcdHRoaXMuX2xCbG9jayBePSB0IDw8IG9mZnNldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZXhjaGFuZ2VSTChvZmZzZXQsIG1hc2spIHtcXG5cXHRcXHRcXHR2YXIgdCA9ICh0aGlzLl9yQmxvY2sgPj4+IG9mZnNldCBeIHRoaXMuX2xCbG9jaykgJiBtYXNrO1xcblxcdFxcdFxcdHRoaXMuX2xCbG9jayBePSB0O1xcblxcdFxcdFxcdHRoaXMuX3JCbG9jayBePSB0IDw8IG9mZnNldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqXFxuICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5ERVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XFxuICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5ERVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XFxuICAgKi9cXG5cXHRcXHRDLkRFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoREVTKTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFRyaXBsZS1ERVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cXG4gICAqL1xcblxcdFxcdHZhciBUcmlwbGVERVMgPSBDX2FsZ28uVHJpcGxlREVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcXG5cXHRcXHRcXHRfZG9SZXNldDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdFxcdFxcdHZhciBrZXkgPSB0aGlzLl9rZXk7XFxuXFx0XFx0XFx0XFx0dmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xcblxcblxcdFxcdFxcdFxcdC8vIENyZWF0ZSBERVMgaW5zdGFuY2VzXFxuXFx0XFx0XFx0XFx0dGhpcy5fZGVzMSA9IERFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSgwLCAyKSkpO1xcblxcdFxcdFxcdFxcdHRoaXMuX2RlczIgPSBERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoMiwgNCkpKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kZXMzID0gREVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDQsIDYpKSk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kZXMxLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xcblxcdFxcdFxcdFxcdHRoaXMuX2RlczIuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGVzMy5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RlczMuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGVzMi5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kZXMxLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0a2V5U2l6ZTogMTkyIC8gMzIsXFxuXFxuXFx0XFx0XFx0aXZTaXplOiA2NCAvIDMyLFxcblxcblxcdFxcdFxcdGJsb2NrU2l6ZTogNjQgLyAzMlxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKlxcbiAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuVHJpcGxlREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xcbiAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuVHJpcGxlREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xcbiAgICovXFxuXFx0XFx0Qy5UcmlwbGVERVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKFRyaXBsZURFUyk7XFxuXFx0fSkoKTtcXG5cXG5cXHRyZXR1cm4gQ3J5cHRvSlMuVHJpcGxlREVTO1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy90cmlwbGVkZXMuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qc1wiOlxyXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XFxuXFx0aWYgKHRydWUpIHtcXG5cXHRcXHQvLyBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xcXCIpKTtcXG5cXHR9IGVsc2Uge31cXG59KSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcXG5cXG5cXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xcblxcdFxcdC8vIFNob3J0Y3V0c1xcblxcdFxcdHZhciBDID0gQ3J5cHRvSlM7XFxuXFx0XFx0dmFyIENfbGliID0gQy5saWI7XFxuXFx0XFx0dmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xcblxcdFxcdHZhciBYMzJXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiB4NjQgbmFtZXNwYWNlLlxcbiAgICovXFxuXFx0XFx0dmFyIENfeDY0ID0gQy54NjQgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEEgNjQtYml0IHdvcmQuXFxuICAgKi9cXG5cXHRcXHR2YXIgWDY0V29yZCA9IENfeDY0LldvcmQgPSBCYXNlLmV4dGVuZCh7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIDY0LWJpdCB3b3JkLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggMzIgYml0cy5cXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgMzIgYml0cy5cXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIHg2NFdvcmQgPSBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyk7XFxuICAgICovXFxuXFx0XFx0XFx0aW5pdDogZnVuY3Rpb24gKGhpZ2gsIGxvdykge1xcblxcdFxcdFxcdFxcdHRoaXMuaGlnaCA9IGhpZ2g7XFxuXFx0XFx0XFx0XFx0dGhpcy5sb3cgPSBsb3c7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIEJpdHdpc2UgTk9UcyB0aGlzIHdvcmQuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgbmVnYXRpbmcuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBuZWdhdGVkID0geDY0V29yZC5ub3QoKTtcXG4gICAgKi9cXG5cXHRcXHRcXHQvLyBub3Q6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHQvLyB2YXIgaGlnaCA9IH50aGlzLmhpZ2g7XFxuXFx0XFx0XFx0Ly8gdmFyIGxvdyA9IH50aGlzLmxvdztcXG5cXG5cXHRcXHRcXHQvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcXG5cXHRcXHRcXHQvLyB9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIEJpdHdpc2UgQU5EcyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIEFORCB3aXRoIHRoaXMgd29yZC5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBBTkRpbmcuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBhbmRlZCA9IHg2NFdvcmQuYW5kKGFub3RoZXJYNjRXb3JkKTtcXG4gICAgKi9cXG5cXHRcXHRcXHQvLyBhbmQ6IGZ1bmN0aW9uICh3b3JkKSB7XFxuXFx0XFx0XFx0Ly8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggJiB3b3JkLmhpZ2g7XFxuXFx0XFx0XFx0Ly8gdmFyIGxvdyA9IHRoaXMubG93ICYgd29yZC5sb3c7XFxuXFxuXFx0XFx0XFx0Ly8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XFxuXFx0XFx0XFx0Ly8gfSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBCaXR3aXNlIE9ScyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIE9SIHdpdGggdGhpcyB3b3JkLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIE9SaW5nLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgb3JlZCA9IHg2NFdvcmQub3IoYW5vdGhlclg2NFdvcmQpO1xcbiAgICAqL1xcblxcdFxcdFxcdC8vIG9yOiBmdW5jdGlvbiAod29yZCkge1xcblxcdFxcdFxcdC8vIHZhciBoaWdoID0gdGhpcy5oaWdoIHwgd29yZC5oaWdoO1xcblxcdFxcdFxcdC8vIHZhciBsb3cgPSB0aGlzLmxvdyB8IHdvcmQubG93O1xcblxcblxcdFxcdFxcdC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xcblxcdFxcdFxcdC8vIH0sXFxuXFxuXFx0XFx0XFx0LyoqXFxuICAgICogQml0d2lzZSBYT1JzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gWE9SIHdpdGggdGhpcyB3b3JkLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIFhPUmluZy5cXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIHhvcmVkID0geDY0V29yZC54b3IoYW5vdGhlclg2NFdvcmQpO1xcbiAgICAqL1xcblxcdFxcdFxcdC8vIHhvcjogZnVuY3Rpb24gKHdvcmQpIHtcXG5cXHRcXHRcXHQvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCBeIHdvcmQuaGlnaDtcXG5cXHRcXHRcXHQvLyB2YXIgbG93ID0gdGhpcy5sb3cgXiB3b3JkLmxvdztcXG5cXG5cXHRcXHRcXHQvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcXG5cXHRcXHRcXHQvLyB9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIFNoaWZ0cyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSBsZWZ0LlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0LlxcbiAgICAqXFxuICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHNoaWZ0aW5nLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgc2hpZnRlZCA9IHg2NFdvcmQuc2hpZnRMKDI1KTtcXG4gICAgKi9cXG5cXHRcXHRcXHQvLyBzaGlmdEw6IGZ1bmN0aW9uIChuKSB7XFxuXFx0XFx0XFx0Ly8gaWYgKG4gPCAzMikge1xcblxcdFxcdFxcdC8vIHZhciBoaWdoID0gKHRoaXMuaGlnaCA8PCBuKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbikpO1xcblxcdFxcdFxcdC8vIHZhciBsb3cgPSB0aGlzLmxvdyA8PCBuO1xcblxcdFxcdFxcdC8vIH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gdmFyIGhpZ2ggPSB0aGlzLmxvdyA8PCAobiAtIDMyKTtcXG5cXHRcXHRcXHQvLyB2YXIgbG93ID0gMDtcXG5cXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0Ly8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XFxuXFx0XFx0XFx0Ly8gfSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBTaGlmdHMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgcmlnaHQuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgc2hpZnRpbmcuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciBzaGlmdGVkID0geDY0V29yZC5zaGlmdFIoNyk7XFxuICAgICovXFxuXFx0XFx0XFx0Ly8gc2hpZnRSOiBmdW5jdGlvbiAobikge1xcblxcdFxcdFxcdC8vIGlmIChuIDwgMzIpIHtcXG5cXHRcXHRcXHQvLyB2YXIgbG93ID0gKHRoaXMubG93ID4+PiBuKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbikpO1xcblxcdFxcdFxcdC8vIHZhciBoaWdoID0gdGhpcy5oaWdoID4+PiBuO1xcblxcdFxcdFxcdC8vIH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gdmFyIGxvdyA9IHRoaXMuaGlnaCA+Pj4gKG4gLSAzMik7XFxuXFx0XFx0XFx0Ly8gdmFyIGhpZ2ggPSAwO1xcblxcdFxcdFxcdC8vIH1cXG5cXG5cXHRcXHRcXHQvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcXG5cXHRcXHRcXHQvLyB9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIFJvdGF0ZXMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgbGVmdC5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byByb3RhdGUuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgcm90YXRpbmcuXFxuICAgICpcXG4gICAgKiBAZXhhbXBsZVxcbiAgICAqXFxuICAgICogICAgIHZhciByb3RhdGVkID0geDY0V29yZC5yb3RMKDI1KTtcXG4gICAgKi9cXG5cXHRcXHRcXHQvLyByb3RMOiBmdW5jdGlvbiAobikge1xcblxcdFxcdFxcdC8vIHJldHVybiB0aGlzLnNoaWZ0TChuKS5vcih0aGlzLnNoaWZ0Uig2NCAtIG4pKTtcXG5cXHRcXHRcXHQvLyB9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIFJvdGF0ZXMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgcmlnaHQuXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlLlxcbiAgICAqXFxuICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHJvdGF0aW5nLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgcm90YXRlZCA9IHg2NFdvcmQucm90Uig3KTtcXG4gICAgKi9cXG5cXHRcXHRcXHQvLyByb3RSOiBmdW5jdGlvbiAobikge1xcblxcdFxcdFxcdC8vIHJldHVybiB0aGlzLnNoaWZ0UihuKS5vcih0aGlzLnNoaWZ0TCg2NCAtIG4pKTtcXG5cXHRcXHRcXHQvLyB9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIEFkZHMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxcbiAgICAqXFxuICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBhZGQgd2l0aCB0aGlzIHdvcmQuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgYWRkaW5nLlxcbiAgICAqXFxuICAgICogQGV4YW1wbGVcXG4gICAgKlxcbiAgICAqICAgICB2YXIgYWRkZWQgPSB4NjRXb3JkLmFkZChhbm90aGVyWDY0V29yZCk7XFxuICAgICovXFxuXFx0XFx0XFx0Ly8gYWRkOiBmdW5jdGlvbiAod29yZCkge1xcblxcdFxcdFxcdC8vIHZhciBsb3cgPSAodGhpcy5sb3cgKyB3b3JkLmxvdykgfCAwO1xcblxcdFxcdFxcdC8vIHZhciBjYXJyeSA9IChsb3cgPj4+IDApIDwgKHRoaXMubG93ID4+PiAwKSA/IDEgOiAwO1xcblxcdFxcdFxcdC8vIHZhciBoaWdoID0gKHRoaXMuaGlnaCArIHdvcmQuaGlnaCArIGNhcnJ5KSB8IDA7XFxuXFxuXFx0XFx0XFx0Ly8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XFxuXFx0XFx0XFx0Ly8gfVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qKlxcbiAgICogQW4gYXJyYXkgb2YgNjQtYml0IHdvcmRzLlxcbiAgICpcXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiBDcnlwdG9KUy54NjQuV29yZCBvYmplY3RzLlxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxcbiAgICovXFxuXFx0XFx0dmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgQ3J5cHRvSlMueDY0LldvcmQgb2JqZWN0cy5cXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKCk7XFxuICAgICpcXG4gICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKFtcXG4gICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KSxcXG4gICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDE4MTkxYTFiLCAweDFjMWQxZTFmKVxcbiAgICAqICAgICBdKTtcXG4gICAgKlxcbiAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoW1xcbiAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpLFxcbiAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MTgxOTFhMWIsIDB4MWMxZDFlMWYpXFxuICAgICogICAgIF0sIDEwKTtcXG4gICAgKi9cXG5cXHRcXHRcXHRpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XFxuXFx0XFx0XFx0XFx0d29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA4O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qKlxcbiAgICAqIENvbnZlcnRzIHRoaXMgNjQtYml0IHdvcmQgYXJyYXkgdG8gYSAzMi1iaXQgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEByZXR1cm4ge0NyeXB0b0pTLmxpYi5Xb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheSdzIGRhdGEgYXMgYSAzMi1iaXQgd29yZCBhcnJheS5cXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIHgzMldvcmRBcnJheSA9IHg2NFdvcmRBcnJheS50b1gzMigpO1xcbiAgICAqL1xcblxcdFxcdFxcdHRvWDMyOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXRzXFxuXFx0XFx0XFx0XFx0dmFyIHg2NFdvcmRzID0gdGhpcy53b3JkcztcXG5cXHRcXHRcXHRcXHR2YXIgeDY0V29yZHNMZW5ndGggPSB4NjRXb3Jkcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29udmVydFxcblxcdFxcdFxcdFxcdHZhciB4MzJXb3JkcyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgeDY0V29yZHNMZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHZhciB4NjRXb3JkID0geDY0V29yZHNbaV07XFxuXFx0XFx0XFx0XFx0XFx0eDMyV29yZHMucHVzaCh4NjRXb3JkLmhpZ2gpO1xcblxcdFxcdFxcdFxcdFxcdHgzMldvcmRzLnB1c2goeDY0V29yZC5sb3cpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gWDMyV29yZEFycmF5LmNyZWF0ZSh4MzJXb3JkcywgdGhpcy5zaWdCeXRlcyk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvKipcXG4gICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXFxuICAgICpcXG4gICAgKiBAcmV0dXJuIHtYNjRXb3JkQXJyYXl9IFRoZSBjbG9uZS5cXG4gICAgKlxcbiAgICAqIEBleGFtcGxlXFxuICAgICpcXG4gICAgKiAgICAgdmFyIGNsb25lID0geDY0V29yZEFycmF5LmNsb25lKCk7XFxuICAgICovXFxuXFx0XFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2xvbmUgXFxcIndvcmRzXFxcIiBhcnJheVxcblxcdFxcdFxcdFxcdHZhciB3b3JkcyA9IGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDbG9uZSBlYWNoIFg2NFdvcmQgb2JqZWN0XFxuXFx0XFx0XFx0XFx0dmFyIHdvcmRzTGVuZ3RoID0gd29yZHMubGVuZ3RoO1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHNMZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHdvcmRzW2ldID0gd29yZHNbaV0uY2xvbmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsb25lO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9KSgpO1xcblxcblxcdHJldHVybiBDcnlwdG9KUztcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9CYXNlRW5jcnlwdGlvbi8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMveDY0LWNvcmUuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcblxyXG4vKioqLyBcIi4vc3JjL2luZGV4LmpzXCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiAuL3NyYy9pbmRleC5qcyAqKiohXHJcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmV2YWwoXCJcXG5cXG5jb25zdCBDcnlwdG9KUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNyeXB0by1qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2luZGV4LmpzXFxcIik7XFxuY29uc3QgQUVTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY3J5cHRvLWpzL2FlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qc1xcXCIpO1xcblxcbmNvbnN0IGtleVNpemUgPSAyNTY7XFxuY29uc3QgaXZTaXplID0gMTI4O1xcbmNvbnN0IGl0ZXJhdGlvbnMgPSAxMDA7XFxuY29uc3QgbGVuZ3RoID0gMzI7XFxuY29uc3QgaXZTaXplRGl2aWRlciA9IDg7XFxuXFxuLy8gSEVMUEVSU1xcbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XFxufVxcblxcbmZ1bmN0aW9uIG9ialRvU3RyaW5nKG9iaikge1xcbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcXG4gICAgb2JqID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcXG4gIH1cXG4gIHJldHVybiBvYmo7XFxufVxcblxcbmNvbnN0IG9uZVdheUVuY3J5cHRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgaWYgKGRhdGEpIHJldHVybiBDcnlwdG9KUy5NRDUoZGF0YSkudG9TdHJpbmcoKTtcXG4gIHJldHVybiBkYXRhO1xcbn07XFxuXFxuY29uc3Qgb25lV2F5Q29tcGFyYXRpb24gPSBmdW5jdGlvbiAoY3lwaGVyLCBjb21wYXJlKSB7XFxuICBpZiAoY3lwaGVyICYmIGNvbXBhcmUpIHtcXG4gICAgcmV0dXJuIGN5cGhlciA9PT0gQ3J5cHRvSlMuTUQ1KGNvbXBhcmUpLnRvU3RyaW5nKCk7XFxuICB9XFxuICByZXR1cm4gY3lwaGVyO1xcbn07XFxuXFxuY29uc3QgdHdvV2F5RW5jcnlwdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBwYXNzcGhyYXNlKSB7XFxuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xcbiAgaWYgKCFwYXNzcGhyYXNlKSByZXR1cm4gcGFzc3BocmFzZTtcXG5cXG4gIGlmIChpc09iamVjdChkYXRhKSkge1xcbiAgICBkYXRhID0gb2JqVG9TdHJpbmcoZGF0YSk7XFxuICB9XFxuICBjb25zdCBzYWx0ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oaXZTaXplIC8gaXZTaXplRGl2aWRlcik7XFxuICBjb25zdCBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3BocmFzZSwgc2FsdCwge1xcbiAgICBrZXlTaXplOiBrZXlTaXplIC8gbGVuZ3RoLFxcbiAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zXFxuICB9KTtcXG4gIGNvbnN0IGl2ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oaXZTaXplIC8gaXZTaXplRGl2aWRlcik7XFxuICBjb25zdCBlbmNyeXB0ZWQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChvYmpUb1N0cmluZyhkYXRhKSwga2V5LCB7XFxuICAgIGl2OiBpdixcXG4gICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBrY3M3LFxcbiAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQ1xcbiAgfSk7XFxuICAvLyBzYWx0LCBpbml0aWFsaXphdGlvbiB2ZWN0b3Igd2lsbCBiZSBoZXggMzIgaW4gbGVuZ3RoXFxuICBjb25zdCBjeXBoZXIgPSBzYWx0LnRvU3RyaW5nKCkgKyBpdi50b1N0cmluZygpICsgZW5jcnlwdGVkLnRvU3RyaW5nKCk7XFxuICByZXR1cm4gY3lwaGVyO1xcbn07XFxuXFxuY29uc3QgdHdvV2F5RGVjcnlwdGlvbiA9IGZ1bmN0aW9uIChjeXBoZXIsIHBhc3NwaHJhc2UpIHtcXG5cXG4gIC8vIGNvbnNvbGUubG9nKHtcXG4gIC8vICAgdHdkOiAxLFxcbiAgLy8gICBjeXBoZXI6IGN5cGhlcixcXG4gIC8vICAgcGFzc3BocmFzZTogcGFzc3BocmFzZVxcbiAgLy8gfSk7XFxuXFxuICBpZiAoIWN5cGhlcikgcmV0dXJuIGN5cGhlcjtcXG5cXG4gIGlmICghcGFzc3BocmFzZSkgcmV0dXJuIHBhc3NwaHJhc2U7XFxuXFxuICBjb25zdCBzYWx0ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShjeXBoZXIuc3Vic3RyKDAsIGxlbmd0aCkpO1xcbiAgY29uc3QgaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGN5cGhlci5zdWJzdHIobGVuZ3RoLCBsZW5ndGgpKTtcXG4gIGNvbnN0IGVuY3J5cHRlZCA9IGN5cGhlci5zdWJzdHJpbmcobGVuZ3RoICogMik7XFxuICBjb25zdCBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3BocmFzZSwgc2FsdCwge1xcbiAgICBrZXlTaXplOiBrZXlTaXplIC8gbGVuZ3RoLFxcbiAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zXFxuICB9KTtcXG4gIC8vIGNvbnNvbGUubG9nKHtcXG4gIC8vICAgdHdkOiAyLFxcbiAgLy8gICBzYWx0OiBzYWx0LFxcbiAgLy8gICBpdjogaXYsXFxuICAvLyAgIGVuY3J5cHRlZDogZW5jcnlwdGVkLFxcbiAgLy8gICBrZXk6IGtleVxcbiAgLy8gfSk7XFxuICBsZXQgZGVjcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoZW5jcnlwdGVkLCBrZXksIHtcXG4gICAgaXY6IGl2LFxcbiAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUGtjczcsXFxuICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDXFxuICB9KS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XFxuXFxuICAvLyBjb25zb2xlLmxvZyh7XFxuICAvLyAgIHR3ZDogMyxcXG4gIC8vICAgZGVjcnlwdGVkOmRlY3J5cHRlZFxcbiAgLy8gfSlcXG4gIC8vIGNvbnNvbGUubG9nKCd0d0RlYzQnKTtcXG4gIC8vIGNvbnNvbGUubG9nKCdERUNSWVBFRCcsZGVjcnlwdGVkKTtcXG4gIGlmIChkZWNyeXB0ZWQuY2hhckF0KDApID09PSAnXFxcIicgJiYgZGVjcnlwdGVkLmNoYXJBdChkZWNyeXB0ZWQubGVuZ3RoIC0gMSkgPT09ICdcXFwiJykge1xcbiAgICBkZWNyeXB0ZWQgPSBkZWNyeXB0ZWQuc3Vic3RyKDEsIGRlY3J5cHRlZC5sZW5ndGggLSAyKTtcXG4gIH1cXG5cXG4gIC8vIGNvbnNvbGUubG9nKCd0d0RlYzUnKTtcXG4gIC8vIGNvbnNvbGUubG9nKCdERUNSWVBFRCcsZGVjcnlwdGVkKTtcXG4gIHJldHVybiBkZWNyeXB0ZWQ7XFxufTtcXG5cXG5jb25zdCBCYXNlRW5jcnlwdGlvbiA9IHtcXG4gIG9uZVdheUVuY3J5cHQ6IG9uZVdheUVuY3J5cHRpb24sXFxuICBvbmVXYXlDb21wYXJlOiBvbmVXYXlDb21wYXJhdGlvbixcXG4gIHR3b1dheUVuY3J5cHQ6IHR3b1dheUVuY3J5cHRpb24sXFxuICB0d29XYXlEZWNyeXB0OiB0d29XYXlEZWNyeXB0aW9uXFxufTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VFbmNyeXB0aW9uO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Jhc2VFbmNyeXB0aW9uLy4vc3JjL2luZGV4LmpzP1wiKTtcclxuXHJcbi8qKiovIH0pXHJcblxyXG4vKioqKioqLyB9KTtcclxufSk7IiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJEdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbicgJiYgISEkR09QUy5mO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkR09QUy5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9ICRmYWlscyhmdW5jdGlvbiAoKSB7ICRHT1BTLmYoMSk7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIEZBSUxTX09OX1BSSU1JVElWRVMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgcmV0dXJuICRHT1BTLmYodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmIChyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cbiIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL19iaW5kJyk7XG52YXIgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxuLyoqIERldGVjdCBpZiBwcm9wZXJ0aWVzIHNoYWRvd2luZyB0aG9zZSBvbiBgT2JqZWN0LnByb3RvdHlwZWAgYXJlIG5vbi1lbnVtZXJhYmxlLiAqL1xudmFyIG5vbkVudW1TaGFkb3dzID0gIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAndmFsdWVPZic6IDEgfSwgJ3ZhbHVlT2YnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHwgaXNCdWZmZXIodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAobm9uRW51bVNoYWRvd3MgfHwgaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFuYXRpdmVLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEYsIGxlbiwgYXJncykge1xuICBpZiAoIShsZW4gaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKykgbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZiAoaXNPYmplY3QoZm4ucHJvdG90eXBlKSkgYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICB9IGVsc2UgaWYgKE9ic2VydmVyICYmICEoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuXHQvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcblx0Ly8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG5cdC8vIEhvd2V2ZXIsIHRoaXMgY2F1c2VzIENTUCB2aW9sYXRpb25zIGluIENocm9tZSBhcHBzLlxuXHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9XG5cdGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9XG5cdHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbnZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZ2xvYmFsLmZldGNoO1xuXG4vLyBOZWVkZWQgZm9yIFR5cGVTY3JpcHQgYW5kIFdlYnBhY2suXG5leHBvcnRzLmRlZmF1bHQgPSBnbG9iYWwuZmV0Y2guYmluZChnbG9iYWwpO1xuXG5leHBvcnRzLkhlYWRlcnMgPSBnbG9iYWwuSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IGdsb2JhbC5SZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IGdsb2JhbC5SZXNwb25zZTsiLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXVxuICBdKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZiAodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7XG4gICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBpbnN0YW5jZS5oYXMoMSk7IH0pO1xuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7IG5ldyBDKGl0ZXIpOyB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UoKSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYgKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpIGRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBpc0VudW0uY2FsbChTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCJjb25zdCBBUFBfQ09OU1RBTlRTID0ge1xyXG4gIFZFUlNJT046ICcyLjAuNScsXHJcbiAgREVGQVVMVFM6IHtcclxuICAgIExBTkdVQUdFOiAnZW5fRU4nLFxyXG4gICAgRU5DUllQVElPTjogdHJ1ZSxcclxuICAgIEVOVklST05NRU5UOiAncHJvZHVjdGlvbicsXHJcbiAgICBJRlJBTUVfQ1NTOiB7XHJcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxyXG4gICAgICBib3R0b206ICcxNnB4JyxcclxuICAgICAgcmlnaHQ6ICcxNnB4JyxcclxuICAgICAgaGVpZ2h0OiAnNTVweCcsXHJcbiAgICAgIHdpZHRoOiAnNTVweCcsXHJcbiAgICAgIGJvcmRlcjogJ25vbmUnXHJcbiAgICB9XHJcbiAgfSxcclxuICBFTlZJUk9OTUVOVFM6IFsnZGV2ZWxvcG1lbnQnLCAnc3RhZ2luZycsICdwcm9kdWN0aW9uJywgJ2xvY2FsJ10sXHJcbiAgRU5WSVJPTk1FTlRfU0hPUlRfTkFNRVM6IHtcclxuICAgIGRldmVsb3BtZW50OiAnZGV2JyxcclxuICAgIHN0YWdpbmc6ICdzdGFnaW5nJyxcclxuICAgIHByb2R1Y3Rpb246ICdwcm9kJyxcclxuICAgIGxvY2FsOiAnZGV2J1xyXG4gIH0sXHJcbiAgRU5WSVJPTk1FTlRfSURTOiB7XHJcbiAgICBkZXZlbG9wbWVudDogMyxcclxuICAgIHN0YWdpbmc6IDQsXHJcbiAgICBwcm9kdWN0aW9uOiA1XHJcbiAgfSxcclxuICBFTkNSWVBURURfRU5WSVJPTk1FTlRTOiBbJ3N0YWdpbmcnLCAncHJvZHVjdGlvbiddLFxyXG4gIExBTkdVQUdFUzogWydlbl9FTiddLFxyXG4gIExPR0lOX1RZUEVTOiBbJ0FQSScsICdLRVlfVE9LRU4nXSxcclxuICBVUkxTOiB7XHJcbiAgICBJRlJBTUU6IFsnaHR0cHM6Ly9ibHVlZGFyd2luLWNoYXRib3QtaWZyYW1lJywgJy5ldS1kZS5teWJsdWVtaXgubmV0LyddLFxyXG4gICAgQVBJOiBbXHJcbiAgICAgICdodHRwczovL29wZW53aGlzay5ldS1kZS5ibHVlbWl4Lm5ldC9hcGkvdjEvd2ViL2JsdWVkYXJ3aW5fJyxcclxuICAgICAgJy9kZWZhdWx0L2FwaSdcclxuICAgIF1cclxuICB9LFxyXG4gIEVWRU5UUzoge1xyXG4gICAgQVBJX1JFQURZOiAnYXBpOnJlYWR5JyxcclxuICAgIEFQSV9GQUlMOiAnYXBpOmZhaWwnLFxyXG4gICAgTE9HR0VEX0lOOiAnbG9naW46c3VjY2VzcycsXHJcbiAgICBMT0dHRURfT1VUOiAnbG9nb3V0OnN1Y2Nlc3MnLFxyXG4gICAgTE9HSU5fRkFJTDogJ2xvZ2luOmZhaWwnLFxyXG4gICAgQ09OVkVSU0FUSU9OX1JFUExZX0ZBSUw6ICdjb252ZXJzYXRpb24tcmVwbHk6ZmFpbCcsXHJcbiAgICBDT05WRVJTQVRJT05fVVBEQVRFOiAnY29udmVyc2F0aW9uOnVwZGF0ZWQnLFxyXG4gICAgVE9LRU5fTkVHT1RJQVRJT05fUkVRVUlSRUQ6ICd4LWFjY2Vzcy10b2tlbjpuZWdvdGlhdGlvbi1yZXF1aXJlZCcsXHJcbiAgICBJRlJBTUVfTE9BREVEOiAnaWZyYW1lOmxvYWRlZCdcclxuICB9LFxyXG4gIFNUQVRFUzoge1xyXG4gICAgQVBJX1JFQURZOiAnYXBpLXJlYWR5JyxcclxuICAgIEVOVklST05NRU5UOiAnZW52aXJvbm1lbnQnLFxyXG4gICAgTU9ERUxfTU9EVUxFOiAnbW9kZWwtYW0tbW9kdWxlJyxcclxuICAgIE1PREVMX0NIQU5ORUxTOiAnbW9kYWwtYW0tbW9kdWxlLWNoYW5uZWxzJyxcclxuICAgIE1PREVMX0lOVEVOVDogJ21vZGFsLWFtLW1vZHVsZS1pbnRlbnQnLFxyXG4gICAgTU9ERUxfU0VTU0lPTjogJ21vZGFsLXNlc3Npb24nLFxyXG4gICAgVVJMX0FQSTogJ3VybC1hcGknLFxyXG4gICAgVVJMX0lGUkFNRTogJ3VybC1pZnJhbWUnLFxyXG4gICAgSVNfRU5DUllQVEVEOiAnaXMtZW5jcnlwdGVkJyxcclxuICAgIElTX0xPR0dFRF9JTjogJ2lzLWxvZ2dlZC1pbicsXHJcbiAgICBJU19JTklUSUFMSVpFRDogJ2lzLWluaXRpYWxpemVkJyxcclxuICAgIEhBU19NT0RVTEU6ICdoYXMtbW9kdWxlJyxcclxuICAgIEhBU19DSEFUQk9UX1VTRVI6ICdoYXMtY2hhdGJvdC11c2VyJyxcclxuICAgIEhBU19DTElFTlRfVVNFUl9JRDogJ2hhcy1jbGllbnQtdXNlci1pZCcsXHJcbiAgICBIQVNfVVNFUjogJ2hhcy11c2VyJyxcclxuICAgIEhBU19UT0tFTjogJ2hhcy10b2tlbicsXHJcbiAgICBIQVNfUFJPSkVDVDogJ2hhcy1wcm9qZWN0JyxcclxuICAgIEhBU19LRVk6ICdoYXMta2V5JyxcclxuICAgIExPR0lOX01FVEhPRDogJ2xvZ2luLW1ldGhvZCcsXHJcbiAgICBFTEVNRU5UX0lGUkFNRTogJ2VsZW1lbnQtaWZyYW1lJyxcclxuICAgIElTX0lGUkFNRV9JTl9ERUJVR19NT0RFOiAnaXMtaWZyYW1lLWluLWRlYnVnLW1vZGUnLFxyXG4gICAgQ09OVkVSU0FUSU9OOiAnY29udmVyc2F0aW9uJyxcclxuICAgIENIQU5ORUxfVE9LRU46ICdjaGFubmVsLXRva2VuJ1xyXG4gIH0sXHJcbiAgU1RPUkFHRToge1xyXG4gICAgVVNFUjogJ3VzZXInLFxyXG4gICAgS0VZOiAna2V5JyxcclxuICAgIFRPS0VOOiAndG9rZW4nLFxyXG4gICAgT0xEX0tFWTogJ29sZC1rZXknLFxyXG4gICAgT0xEX1RPS0VOOiAnb2xkLXRva2VuJ1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFQUF9DT05TVEFOVFM7XHJcbiIsImV4cG9ydCBkZWZhdWx0IHtcclxuICBvcmlnaW5hbDoge1xyXG4gICAgZW52aXJvbm1lbnQ6IFwicHJvZHVjdGlvblwiLFxyXG4gICAgbGFuZ3VhZ2U6IFwiZW5fRU5cIlxyXG4gIH0sXHJcbiAgcG9zc2libGU6IHtcclxuICAgIGVudmlyb25tZW50OiBbXCJkZXZlbG9wbWVudFwiLCBcInN0YWdpbmdcIiwgXCJwcm9kdWN0aW9uXCIsIFwibG9jYWxcIl0sXHJcbiAgICBsYW5ndWFnZTogW1wiZW5fRU5cIl1cclxuICB9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBHZXRzIGEgYXJyYXkgb3IgYSBvYmplY3QsIGlmIGlzIGFycmF5LCBpbnN0YW5jaWF0ZXNcclxuICogdGhlIGRlcHJlbmRlbmN5IHNlcnZpY2UsIGVsc2UgcmV0dXJuc1xyXG4gKiBvYmplY3Qgd2l0aCBzZXZlcmFsIGRlcGVuZGVuY2llc1xyXG4gKiBAcGFyYW0gYXJyYXlPZkRlcGVuZGVuY2llc1xyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblxyXG5jb25zdCBpbmplY3REZXBlbmRlbmNpZXMgPSBmdW5jdGlvbihhcnJheU9mRGVwZW5kZW5jaWVzLCBwb2ludGVyKSB7XHJcbiAgYXJyYXlPZkRlcGVuZGVuY2llcy5mb3JFYWNoKGFyZyA9PiB7XHJcbiAgICBsZXQgX2NsYXNzO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIF9jbGFzcyA9IG5ldyBhcmcoKTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIF9jbGFzcyA9IGFyZztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgX2NsYXNzTmFtZSA9IF9jbGFzcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG5cclxuICAgIGlmIChfY2xhc3MuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIikge1xyXG4gICAgICBwb2ludGVyLkNvbmZpZ3VyYXRpb24gPSBfY2xhc3M7XHJcbiAgICAgIF9jbGFzc05hbWUgPSBcIkNvbmZpZ3VyYXRpb25cIjtcclxuICAgIH1cclxuICAgIHBvaW50ZXJbX2NsYXNzTmFtZV0gPSBfY2xhc3M7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBpbmplY3REZXBlbmRlbmNpZXM7XHJcblxyXG4vKlxyXG4oZnVuY3Rpb24odyl7XHJcbiAgICB2YXIgc3RhY2sgPSB7fSxcclxuICAgICAgICBpc0FycmF5ID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBJbmplY3QgKCkge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgSW5qZWN0LkVSUk9SX1JFQ1VSU0lPTiA9ICdSZWN1cnNpdmUgZmFpbHVyZSA6IENpcmN1bGFyIHJlZmVyZW5jZSBmb3IgZGVwZW5kZW5jeSAnO1xyXG4gICAgSW5qZWN0LkVSUk9SX1JFR0lTVFJBVElPTiA9ICdBbHJlYWR5IHJlZ2lzdGVyZWQuJztcclxuICAgIEluamVjdC5FUlJPUl9BUlJBWSA9ICdNdXN0IHBhc3MgYXJyYXkuJztcclxuICAgIEluamVjdC5FUlJPUl9GVU5DVElPTiA9ICdNdXN0IHBhc3MgZnVuY3Rpb24gdG8gaW52b2tlLic7XHJcbiAgICBJbmplY3QuRVJST1JfU0VSVklDRSA9ICdTZXJ2aWNlIGRvZXMgbm90IGV4aXN0Lic7XHJcblxyXG4gICAgSW5qZWN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLmNvbnRhaW5lcltuYW1lXTtcclxuICAgICAgICBpZiAod3JhcHBlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBJbmplY3QuRVJST1JfU0VSVklDRTtcclxuICAgIH07XHJcblxyXG4gICAgSW5qZWN0LnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoZm4sIGRlcHMsIGluc3RhbmNlLCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBhcmdzID0gW107XHJcbiAgICAgICAgaWYgKHN0YWNrW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRocm93IEluamVjdC5FUlJPUl9SRUNVUlNJT04gKyBuYW1lICsgXCIgOiBcIiArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHN0YWNrKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGFja1tuYW1lXSA9IGluc3RhbmNlO1xyXG4gICAgICAgIGZvciAoOyBpIDwgZGVwcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5nZXQoZGVwc1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgc3RhY2tbbmFtZV07XHJcblxyXG4gICAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEluamVjdC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSwgYW5ub3RhdGVkQXJyYXkpIHtcclxuICAgICAgICBpZiAoIWlzQXJyYXkoYW5ub3RhdGVkQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEluamVjdC5FUlJPUl9BUlJBWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lcltuYW1lXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBJbmplY3QuRVJST1JfUkVHSVNUUkFUSU9OO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhbm5vdGF0ZWRBcnJheVthbm5vdGF0ZWRBcnJheS5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBJbmplY3QuRVJST1JfRlVOQ1RJT047XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyW25hbWVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgSW5qZWN0aW9uSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IGFubm90YXRlZEFycmF5W2Fubm90YXRlZEFycmF5Lmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICB2YXIgZGVwcyA9IGFubm90YXRlZEFycmF5Lmxlbmd0aCA9PT0gMSA/IChhbm5vdGF0ZWRBcnJheVswXS4kJGRlcHMgfHwgW10pIDpcclxuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWRBcnJheS5zbGljZSgwLCBhbm5vdGF0ZWRBcnJheS5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgIGluamVjdGVkO1xyXG5cclxuICAgICAgICAgICAgSW5qZWN0aW9uSW5zdGFuY2UucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xyXG5cclxuICAgICAgICAgICAgaW5zdGFuY2UgPSBuZXcgSW5qZWN0aW9uSW5zdGFuY2UoKTtcclxuXHJcbiAgICAgICAgICAgIGluamVjdGVkID0gX3RoaXMuaW52b2tlKGZuLCBkZXBzLCBpbnN0YW5jZSwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgPSBpbmplY3RlZCB8fCBpbnN0YW5jZTtcclxuXHJcbiAgICAgICAgICAgIF90aGlzLmNvbnRhaW5lcltuYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gIFx0ZnVuY3Rpb24gSW5qZWN0aW9uV3JhcHBlcigpe1xyXG4gICBcdHZhciBpb2MgPSBuZXcgSW5qZWN0KCksIF90aGF0ID0gdGhpcztcclxuICAgIHRoaXMuZ2V0ID0gaW9jLmdldC5iaW5kKGlvYyk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IGlvYy5yZWdpc3Rlci5iaW5kKGlvYyk7XHJcbiAgICAgICAgaW9jLmNvbnRhaW5lclsnJCRJbmplY3QnXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGF0O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdy4kJEluamVjdCA9IG5ldyBJbmplY3Rpb25XcmFwcGVyKCk7XHJcblxyXG4gfSkod2luZG93KTtcclxuXHJcblxyXG5mdW5jdGlvbiBtYWluKCl7XHJcblxyXG4gIGNvbnN0IGxvZyA9IGNvbnNvbGUubG9nO1xyXG5cclxuICBmdW5jdGlvbiBQaXN0b25zKCkge1xyXG4gIFx0dGhpcy5hY3Rpb24gPSAoKSA9PiBsb2coXCJUaGUgcGlzdG9ucyBmaXJlIHVwIGFuZCBkb3duLlwiKTtcclxuICAgIGxvZyhcIk1hZGUgc29tZSBwaXN0b25zLlwiKTtcclxuICB9XHJcblxyXG4gICQkSW5qZWN0LnJlZ2lzdGVyKFwicGlzdG9uc1wiLCBbUGlzdG9uc10pO1xyXG5cclxuICAgZnVuY3Rpb24gRW5naW5lKHBpc3RvbnMpIHtcclxuICBcdHRoaXMucGlzdG9ucyA9IHBpc3RvbnM7XHJcbiAgICB0aGlzLmFjdGlvbiA9ICgpID0+IHtcclxuICAgIFx0dGhpcy5waXN0b25zLmFjdGlvbigpO1xyXG4gICAgICBsb2coXCJUaGUgZW5naW5lIGdvZXMgdnJvb20gdnJvb20uXCIpO1xyXG4gICAgfTtcclxuICAgIGxvZyhcIk1hZGUgYW4gZW5naW5lLlwiKTtcclxuICB9XHJcblxyXG4gICQkSW5qZWN0LnJlZ2lzdGVyKFwiZW5naW5lXCIsIFtcInBpc3RvbnNcIiwgRW5naW5lXSk7XHJcblxyXG4gIHJldHVybiB7JCRJbmplY3R9O1xyXG59XHJcblxyXG5tYWluKCk7XHJcbiovXHJcbiIsIi8qKlxyXG4gKiBTZXJ2aWNlIGlzIHNpbmdsZXRvbiBhbmQgaW5qZWN0cyBkZXBlbmRlbmNpZXMgb24gaGlzIHBhcmVudCBjbGFzc1xyXG4gKiBAdHlwZSB7e319XHJcbiAqL1xyXG5pbXBvcnQgaW5qZWN0RGVwZW5kZW5jaWVzIGZyb20gXCIuLi9oZWxwZXJzL2RlcGVuZGVuY2llcy9pbmplY3QtZGVwZW5kZW5jaWVzXCI7XHJcblxyXG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBjb25zdCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG5cclxuICAgIGlmICghaW5zdGFuY2VzW25hbWVdKSB7XHJcbiAgICAgIGluc3RhbmNlc1tuYW1lXSA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBJbmplY3QgZGVwZW5kZW5jaWVzXHJcbiAgICAgIC8qXHJcbiAgICAgIFsuLi5hcmd1bWVudHNdLmZvckVhY2goYXJnID0+IHtcclxuICAgICAgICBjb25zdCBfY2xhc3MgPSBuZXcgYXJnKCk7XHJcbiAgICAgICAgbGV0IF9jbGFzc05hbWUgPSBfY2xhc3MuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBpZiAoX2NsYXNzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpIHtcclxuICAgICAgICAgIGluc3RhbmNlcy5Db25maWd1cmF0aW9uID0gX2NsYXNzO1xyXG4gICAgICAgICAgX2NsYXNzTmFtZSA9IFwiQ29uZmlndXJhdGlvblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZXNbbmFtZV1bX2NsYXNzTmFtZV0gPSBfY2xhc3M7XHJcbiAgICAgIH0pO1xyXG4gICAgICAqL1xyXG4gICAgICBpbmplY3REZXBlbmRlbmNpZXMoWy4uLmFyZ3VtZW50c10sIGluc3RhbmNlc1tuYW1lXSk7XHJcbiAgICAgIGlmIChpbnN0YW5jZXMuQ29uZmlndXJhdGlvbiAmJiAhaW5zdGFuY2VzLkNvbmZpZ3VyYXRpb24uZW52aXJvbm1lbnQpIHtcclxuICAgICAgICBpZiAoaW5zdGFuY2VzW25hbWVdLkNvbmZpZ3VyYXRpb24pXHJcbiAgICAgICAgICBpbnN0YW5jZXMuQ29uZmlndXJhdGlvbiA9IGluc3RhbmNlc1tuYW1lXS5Db25maWd1cmF0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IGNvbmZpZ09iamVjdCBmcm9tICcuLi9oZWxwZXJzL2NvbmZpZy1vYmplY3RzL2NvbmZpZyc7XHJcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4nO1xyXG5cclxuY29uc3QgZGVmYXVsdENvbmZpZ3VyYXRpb24gPSB7XHJcbiAgZW52aXJvbm1lbnQ6IGNvbmZpZ09iamVjdC5vcmlnaW5hbC5lbnZpcm9ubWVudCxcclxuICB1cmw6IHtcclxuICAgIGFwaTogJycsXHJcbiAgICBpZnJhbWU6ICcnXHJcbiAgfSxcclxuICBlbmNyeXB0aW9uOiB0cnVlLFxyXG4gIGxhbmd1YWdlOiBjb25maWdPYmplY3Qub3JpZ2luYWwubGFuZ3VhZ2VcclxufTtcclxuXHJcbmxldCBjb25maWc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maWd1cmF0aW9uIGV4dGVuZHMgU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoX2NvbmZpZyA9IHt9KSB7XHJcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgaWYgKCFjb25maWcpIHtcclxuICAgICAgT2JqZWN0LmtleXMoX2NvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZ09iamVjdEtleSA9IGNvbmZpZ09iamVjdC5vcmlnaW5hbFtrZXldO1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZ09iamVjdFZhbGlkQ29uZmlncyA9IGNvbmZpZ09iamVjdC5wb3NzaWJsZVtrZXldO1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBjb25maWdPYmplY3RLZXkgJiZcclxuICAgICAgICAgIGNvbmZpZ09iamVjdFZhbGlkQ29uZmlncy5pbmRleE9mKF9jb25maWdba2V5XSkgPiAtMVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgZGVmYXVsdENvbmZpZ3VyYXRpb25ba2V5XSA9IF9jb25maWdba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc3dpdGNoIChkZWZhdWx0Q29uZmlndXJhdGlvbi5lbnZpcm9ubWVudCkge1xyXG4gICAgICAgIGNhc2UgJ2RldmVsb3BtZW50JzpcclxuICAgICAgICAgIGRlZmF1bHRDb25maWd1cmF0aW9uLmVuY3J5cHRpb24gPSBmYWxzZTtcclxuICAgICAgICAgIGRlZmF1bHRDb25maWd1cmF0aW9uLnVybC5hcGkgPVxyXG4gICAgICAgICAgICAnaHR0cHM6Ly9vcGVud2hpc2suZXUtZGUuYmx1ZW1peC5uZXQvYXBpL3YxL3dlYi9ibHVlZGFyd2luX2Rldi9kZWZhdWx0L2FwaSc7XHJcbiAgICAgICAgICBkZWZhdWx0Q29uZmlndXJhdGlvbi51cmwuaWZyYW1lID1cclxuICAgICAgICAgICAgJ2h0dHBzOi8vYmx1ZWRhcndpbi1jaGF0Ym90LWRldi5ldS1kZS5teWJsdWVtaXgubmV0Lyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdsb2NhbCc6XHJcbiAgICAgICAgICBkZWZhdWx0Q29uZmlndXJhdGlvbi5lbmNyeXB0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICBkZWZhdWx0Q29uZmlndXJhdGlvbi51cmwuYXBpID1cclxuICAgICAgICAgICAgJ2h0dHBzOi8vb3BlbndoaXNrLmV1LWRlLmJsdWVtaXgubmV0L2FwaS92MS93ZWIvYmx1ZWRhcndpbl9kZXYvZGVmYXVsdC9hcGknO1xyXG4gICAgICAgICAgZGVmYXVsdENvbmZpZ3VyYXRpb24udXJsLmlmcmFtZSA9ICdodHRwOi8vbG9jYWxob3N0OjQyMDEnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3RhZ2luZyc6XHJcbiAgICAgICAgICBkZWZhdWx0Q29uZmlndXJhdGlvbi5lbmNyeXB0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgIGRlZmF1bHRDb25maWd1cmF0aW9uLnVybC5hcGkgPVxyXG4gICAgICAgICAgICAnaHR0cHM6Ly9vcGVud2hpc2suZXUtZGUuYmx1ZW1peC5uZXQvYXBpL3YxL3dlYi9ibHVlZGFyd2luX3N0YWdpbmcvZGVmYXVsdC9hcGknO1xyXG4gICAgICAgICAgZGVmYXVsdENvbmZpZ3VyYXRpb24udXJsLmlmcmFtZSA9XHJcbiAgICAgICAgICAgICdodHRwczovL2JsdWVkYXJ3aW4tY2hhdGJvdC1zdGFnaW5nLmV1LWRlLm15Ymx1ZW1peC5uZXQvJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3Byb2R1Y3Rpb24nOlxyXG4gICAgICAgICAgZGVmYXVsdENvbmZpZ3VyYXRpb24uZW5jcnlwdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICBkZWZhdWx0Q29uZmlndXJhdGlvbi51cmwuYXBpID1cclxuICAgICAgICAgICAgJ2h0dHBzOi8vb3BlbndoaXNrLmV1LWRlLmJsdWVtaXgubmV0L2FwaS92MS93ZWIvYmx1ZWRhcndpbl9wcm9kL2RlZmF1bHQvYXBpJztcclxuICAgICAgICAgIGRlZmF1bHRDb25maWd1cmF0aW9uLnVybC5pZnJhbWUgPVxyXG4gICAgICAgICAgICAnaHR0cHM6Ly9ibHVlZGFyd2luLWNoYXRib3QuZXUtZGUubXlibHVlbWl4Lm5ldC8nO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgLy9kZWZhdWx0Q29uZmlndXJhdGlvbi51cmwuYXBpID0gXCJodHRwOi8vbG9jYWxob3N0OjgwODAvYXBpXCJcclxuICAgICAgY29uZmlnID0gZGVmYXVsdENvbmZpZ3VyYXRpb247XHJcbiAgICAgIE9iamVjdC5mcmVlemUoZGVmYXVsdENvbmZpZ3VyYXRpb24pO1xyXG4gICAgICBPYmplY3QuZnJlZXplKGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQ29uZmlndXJhdGlvbiBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb25maWd1cmF0aW9uJztcclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgYSB1cmxcclxuICogQHBhcmFtICB7U3RyaW5nfSByb3V0ZSAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtICB7U3RyaW5nfSBwb2ludGVyQXBpVXJsIFtpbnRlcm5hbCBwb2ludGVyIG9mIGNsYXNzXVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKi9cclxuXHJcbmNvbnN0IGJ1aWxkVXJsID0gZnVuY3Rpb24ocm91dGUsIGNvbmZpZ3VyYXRpb24gPSBuZXcgQ29uZmlndXJhdGlvbigpKSB7XHJcbiAgcmV0dXJuIGAke2NvbmZpZ3VyYXRpb24udXJsLmFwaX0vJHtyb3V0ZVxyXG4gICAgLnNwbGl0KCcvJylcclxuICAgIC5maWx0ZXIoZWwgPT4gZWwgIT09ICcnKVxyXG4gICAgLmpvaW4oJy8nKX1gO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYnVpbGRVcmw7XHJcbiIsIi8qKlxyXG4gKiBNaWRkbGV3YXJlIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBpZiBhIHBheWxvYWQgc2hvdWxkIGJlIGVuY3J5cHRlZFxyXG4gKiBAcGFyYW0ge1BvaW50ZXJ9IHBvaW50ZXJJbnN0YW5jZVxyXG4gKiBAcGFyYW0ge1BvaW50ZXJ9IHBvaW50ZXJTaG91bGRFbmNyeXB0XHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuY29uc3QgbWlkZGxld2FyZVdpbGxFbmNyeXB0ID0gZnVuY3Rpb24ocG9pbnRlclNob3VsZEVuY3J5cHQgPSBmYWxzZSkge1xyXG4gIHJldHVybiBwb2ludGVyU2hvdWxkRW5jcnlwdDtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG1pZGRsZXdhcmVXaWxsRW5jcnlwdDtcclxuIiwiaW1wb3J0IEJsdWVEYXJ3aW5CYXNlRW5jcnlwdGlvbiBmcm9tIFwiYmFzZS1lbmNyeXB0aW9uXCI7XHJcbmltcG9ydCBtaWRkbGV3YXJlV2lsbEVuY3J5cHQgZnJvbSBcIi4vbWlkZGxld2FyZS13aWxsLWVuY3J5cHRcIjtcclxuXHJcbmNvbnN0IGVuY3J5cHRTdHJpbmcgPSBmdW5jdGlvbihzdHIsIHBvaW50ZXJTaG91bGRFbmNyeXB0KSB7XHJcbiAgaWYgKG1pZGRsZXdhcmVXaWxsRW5jcnlwdChwb2ludGVyU2hvdWxkRW5jcnlwdCkpIHtcclxuICAgIHJldHVybiBCbHVlRGFyd2luQmFzZUVuY3J5cHRpb24ub25lV2F5RW5jcnlwdChzdHIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVuY3J5cHRTdHJpbmc7XHJcbiIsImNvbnN0IEFQUF9DT05TVEFOVFMgPSB7XHJcbiAgREVGQVVMVFM6IHtcclxuICAgIExBTkdVQUdFOiAnZW5fRU4nLFxyXG4gICAgRU5DUllQVElPTjogdHJ1ZSxcclxuICAgIEVOVklST05NRU5UOiAncHJvZHVjdGlvbicsXHJcbiAgICBJRlJBTUVfQ1NTOiB7XHJcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICBib3R0b206IDAsXHJcbiAgICAgIHJpZ2h0OiAnNXB4JyxcclxuICAgICAgaGVpZ2h0OiAnNTUwcHgnLFxyXG4gICAgICB3aWR0aDogJzMzMHB4JyxcclxuICAgICAgYm9yZGVyOiAnbm9uZSdcclxuICAgIH0sXHJcbiAgICBVUkxfQVBJOlxyXG4gICAgICAnaHR0cHM6Ly9vcGVud2hpc2suZXUtZGUuYmx1ZW1peC5uZXQvYXBpL3YxL3dlYi9ibHVlZGFyd2luX3Byb2QvZGVmYXVsdC9hcGknLFxyXG4gICAgVVJMX0lGUkFNRTogJ2h0dHBzOi8vYmx1ZWRhcndpbi1jaGF0Ym90LmV1LWRlLm15Ymx1ZW1peC5uZXQvJ1xyXG4gIH0sXHJcbiAgRU5WSVJPTk1FTlRTOiBbJ2RldmVsb3BtZW50JywgJ3N0YWdpbmcnLCAncHJvZHVjdGlvbicsICdsb2NhbCddLFxyXG4gIEVOVklST05NRU5UX1NIT1JUX05BTUVTOiB7XHJcbiAgICBkZXZlbG9wbWVudDogJ2RldicsXHJcbiAgICBzdGFnaW5nOiAnc3RhZ2luZycsXHJcbiAgICBwcm9kdWN0aW9uOiAncHJvZCdcclxuICB9LFxyXG4gIEVOVklST05NRU5UX0lEUzoge1xyXG4gICAgZGV2ZWxvcG1lbnQ6IDMsXHJcbiAgICBzdGFnaW5nOiA0LFxyXG4gICAgcHJvZHVjdGlvbjogNVxyXG4gIH0sXHJcbiAgRU5DUllQVEVEX0VOVklST05NRU5UUzogWydzdGFnaW5nJywgJ3Byb2R1Y3Rpb24nXSxcclxuICBMQU5HVUFHRVM6IFsnZW5fRU4nXSxcclxuICBMT0dJTl9UWVBFUzogWydBUEknLCAnS0VZX1RPS0VOJ10sXHJcbiAgVVJMUzoge1xyXG4gICAgSUZSQU1FOiBbJ2h0dHBzOi8vY29nbnVzLWNoYXRib3QnLCAnLmV1LWRlLm15Ymx1ZW1peC5uZXQvJ10sXHJcbiAgICBBUEk6IFtcclxuICAgICAgJ2h0dHBzOi8vb3BlbndoaXNrLmV1LWRlLmJsdWVtaXgubmV0L2FwaS92MS93ZWIvYmx1ZWRhcndpbl8nLFxyXG4gICAgICAnL2RlZmF1bHQvYXBpJ1xyXG4gICAgXVxyXG4gIH0sXHJcbiAgRVZFTlRTOiB7XHJcbiAgICBBUElfUkVBRFk6ICdhcGk6cmVhZHknLFxyXG4gICAgQVBJX0ZBSUw6ICdhcGk6ZmFpbCcsXHJcbiAgICBMT0dHRURfSU46ICdsb2dpbjpzdWNjZXNzJyxcclxuICAgIExPR0dFRF9PVVQ6ICdsb2dvdXQ6c3VjY2VzcycsXHJcbiAgICBMT0dJTl9GQUlMOiAnbG9naW46ZmFpbCcsXHJcbiAgICBDT05WRVJTQVRJT05fUkVQTFlfRkFJTDogJ2NvbnZlcnNhdGlvbi1yZXBseTpmYWlsJyxcclxuICAgIENPTlZFUlNBVElPTl9VUERBVEU6ICdjb252ZXJzYXRpb246dXBkYXRlZCcsXHJcbiAgICBUT0tFTl9ORUdPVElBVElPTl9SRVFVSVJFRDogJ3gtYWNjZXNzLXRva2VuOm5lZ290aWF0aW9uLXJlcXVpcmVkJ1xyXG4gIH0sXHJcbiAgU1RBVEVTOiB7XHJcbiAgICBBUElfUkVBRFk6ICdhcGktcmVhZHknLFxyXG4gICAgRU5WSVJPTk1FTlQ6ICdlbnZpcm9ubWVudCcsXHJcbiAgICBNT0RFTF9NT0RVTEU6ICdtb2RlbC1hbS1tb2R1bGUnLFxyXG4gICAgTU9ERUxfQ0hBTk5FTFM6ICdtb2RhbC1hbS1tb2R1bGUtY2hhbm5lbHMnLFxyXG4gICAgTU9ERUxfSU5URU5UOiAnbW9kYWwtYW0tbW9kdWxlLWludGVudCcsXHJcbiAgICBNT0RFTF9TRVNTSU9OOiAnbW9kYWwtc2Vzc2lvbicsXHJcbiAgICBVUkxfQVBJOiAndXJsLWFwaScsXHJcbiAgICBVUkxfSUZSQU1FOiAndXJsLWlmcmFtZScsXHJcbiAgICBJU19FTkNSWVBURUQ6ICdpcy1lbmNyeXB0ZWQnLFxyXG4gICAgSVNfTE9HR0VEX0lOOiAnaXMtbG9nZ2VkLWluJyxcclxuICAgIElTX0lOSVRJQUxJWkVEOiAnaXMtaW5pdGlhbGl6ZWQnLFxyXG4gICAgSEFTX01PRFVMRTogJ2hhcy1tb2R1bGUnLFxyXG4gICAgSEFTX0NIQVRCT1RfVVNFUjogJ2hhcy1jaGF0Ym90LXVzZXInLFxyXG4gICAgSEFTX0NMSUVOVF9VU0VSX0lEOiAnaGFzLWNsaWVudC11c2VyLWlkJyxcclxuICAgIEhBU19VU0VSOiAnaGFzLXVzZXInLFxyXG4gICAgSEFTX1RPS0VOOiAnaGFzLXRva2VuJyxcclxuICAgIEhBU19QUk9KRUNUOiAnaGFzLXByb2plY3QnLFxyXG4gICAgSEFTX0tFWTogJ2hhcy1rZXknLFxyXG4gICAgTE9HSU5fTUVUSE9EOiAnbG9naW4tbWV0aG9kJyxcclxuICAgIEVMRU1FTlRfSUZSQU1FOiAnZWxlbWVudC1pZnJhbWUnLFxyXG4gICAgSVNfSUZSQU1FX0lOX0RFQlVHX01PREU6ICdpcy1pZnJhbWUtaW4tZGVidWctbW9kZScsXHJcbiAgICBDT05WRVJTQVRJT046ICdjb252ZXJzYXRpb24nLFxyXG4gICAgQ0hBTk5FTF9UT0tFTjogJ2NoYW5uZWwtdG9rZW4nXHJcbiAgfSxcclxuICBTVE9SQUdFOiB7XHJcbiAgICBVU0VSOiAndXNlcicsXHJcbiAgICBLRVk6ICdrZXknLFxyXG4gICAgVE9LRU46ICd0b2tlbicsXHJcbiAgICBPTERfS0VZOiAnb2xkLWtleScsXHJcbiAgICBPTERfVE9LRU46ICdvbGQtdG9rZW4nXHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQVBQX0NPTlNUQU5UUztcclxuIiwiaW1wb3J0IGxvY2FsZm9yYWdlIGZyb20gXCJsb2NhbGZvcmFnZVwiO1xyXG5pbXBvcnQgU2VydmljZSBmcm9tIFwiLlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmFnZSBleHRlbmRzIFNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgY29uZmlnID0ge1xyXG4gICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgZHJpdmVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIHNpemU6IHVuZGVmaW5lZCxcclxuICAgICAgICBzdG9yZU5hbWU6IHVuZGVmaW5lZFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKSB7XHJcbiAgICBzd2l0Y2ggKGNvbmZpZy5kcml2ZXIpIHtcclxuICAgICAgY2FzZSBcImxvY2Fsc3RvcmFnZVwiOlxyXG4gICAgICAgIGNvbmZpZy5kcml2ZXIgPSBsb2NhbGZvcmFnZS5MT0NBTFNUT1JBR0U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgbG9jYWxmb3JhZ2UuY29uZmlnKGNvbmZpZyk7XHJcblxyXG4gICAgbG9jYWxmb3JhZ2UucmVhZHkoKS5jYXRjaChmYWlsID0+IHtcclxuICAgICAgLy8gU2lsZW5jZSBpcyBnb2xkZW5cclxuICAgIH0pO1xyXG4gICAgc3VwZXIoKTtcclxuICB9XHJcblxyXG4gIGdldChrZXkpIHtcclxuICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKGtleSkuY2F0Y2goZXggPT4ge1xyXG4gICAgICAvLyBTaWxlbmNlIGlzIGdvbGRlblxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICBsb2NhbGZvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpLmNhdGNoKGV4ID0+IHtcclxuICAgICAgLy8gU2lsZW5jZSBpcyBnb2xkZW5cclxuICAgIH0pO1xyXG4gIH1cclxuICBkZWxldGUoa2V5KSB7XHJcbiAgICBsb2NhbGZvcmFnZS5yZW1vdmVJdGVtKGtleSkuY2F0Y2goZXggPT4ge1xyXG4gICAgICAvLyBTaWxlbmNlIGlzIGdvbGRlblxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNsZWFyKCkge1xyXG4gICAgbG9jYWxmb3JhZ2UuY2xlYXIoKS5jYXRjaChleCA9PiB7XHJcbiAgICAgIC8vIFNpbGVuY2UgaXMgZ29sZGVuXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IEFQUF9DT05TVEFOVFMgZnJvbSBcIi4uLy4uL2FwcC1jb25zdGFudHNcIjtcclxuaW1wb3J0IFN0b3JhZ2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3N0b3JhZ2VcIjtcclxuXHJcbmNvbnN0IHVwZGF0ZUtleSA9IGZ1bmN0aW9uKFxyXG4gIG5ld0tleSxcclxuICBzY29wZSA9IHsga2V5OiBcIlwiLCBvbGRLZXk6IFwiXCIgfSxcclxuICBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKVxyXG4pIHtcclxuICBzY29wZS5vbGRLZXkgPSBzY29wZS5rZXk7XHJcbiAgc2NvcGUua2V5ID0gbmV3S2V5O1xyXG5cclxuICBzdG9yYWdlLnNldChBUFBfQ09OU1RBTlRTLlNUT1JBR0UuT0xEX0tFWSwgc2NvcGUub2xkS2V5KTtcclxuICBzdG9yYWdlLnNldChBUFBfQ09OU1RBTlRTLlNUT1JBR0UuS0VZLCBzY29wZS5rZXkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgdXBkYXRlS2V5O1xyXG4iLCJpbXBvcnQgQmx1ZURhcndpbkJhc2VFbmNyeXB0aW9uIGZyb20gXCJiYXNlLWVuY3J5cHRpb25cIjtcclxuaW1wb3J0IG1pZGRsZXdhcmVXaWxsRW5jcnlwdCBmcm9tIFwiLi9taWRkbGV3YXJlLXdpbGwtZW5jcnlwdFwiO1xyXG5cclxuLyoqXHJcbiAqIEVuY3J5cHRzIGEgcGF5bG9hZCBpbiBvcmRlciB0byBiZSBjb25zdW1hYmxlIHdpdGggb3VyIEFQSVxyXG4gKiBAcGFyYW0gIHtAVE9ET30gcGF5bG9hZCBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSB7UG9pbnRlcn0ga2V5XHJcbiAqIEByZXR1cm4ge09iamVjdHxDb2dudXNSZXNwb25zZX0ge1wiY29nbnVzXCI6XCJlbmNyeXB0ZWQgc3RyaW5nXCJ9XHJcbiAqL1xyXG5jb25zdCBlbmNyeXB0UGF5bG9hZCA9IGZ1bmN0aW9uKHBheWxvYWQsIHBvaW50ZXJLZXksIHBvaW50ZXJTaG91bGRFbmNyeXB0KSB7XHJcbiAgaWYgKCFtaWRkbGV3YXJlV2lsbEVuY3J5cHQocG9pbnRlclNob3VsZEVuY3J5cHQpKSByZXR1cm4gcGF5bG9hZDtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGNvZ251czogQmx1ZURhcndpbkJhc2VFbmNyeXB0aW9uLnR3b1dheUVuY3J5cHQocGF5bG9hZCwgcG9pbnRlcktleSlcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW5jcnlwdFBheWxvYWQ7XHJcbiIsImltcG9ydCBpc09iamVjdCBmcm9tIFwibG9kYXNoLmlzb2JqZWN0XCI7XHJcbmltcG9ydCBCbHVlRGFyd2luQmFzZUVuY3J5cHRpb24gZnJvbSBcImJhc2UtZW5jcnlwdGlvblwiO1xyXG5pbXBvcnQgbWlkZGxld2FyZVdpbGxFbmNyeXB0IGZyb20gXCIuL21pZGRsZXdhcmUtd2lsbC1lbmNyeXB0XCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIFRyaWVzIHRvIGRlY3J5cHQgYSBwYXlsb2FkIHdpdGhcclxuICogQHBhcmFtICB7Q29nbnVzUmVzcG9uc2VPYmplY3R9IHBheWxvYWQgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcmV0dXJuIHtPYmplY3R8SlNPTkFQSX1cclxuICovXHJcblxyXG5mdW5jdGlvbiBkZWNyeXB0KHBheWxvYWQsIGtleSkge1xyXG4gIGNvbnN0IGRlY3J5cHRlZCA9IEJsdWVEYXJ3aW5CYXNlRW5jcnlwdGlvbi50d29XYXlEZWNyeXB0KFxyXG4gICAgcGF5bG9hZC5jb2dudXMgfHwgcGF5bG9hZC5kYXRhIHx8IHBheWxvYWQuZXJyb3IgfHwgcGF5bG9hZCwgLy8gaW4gY2FzZSBvZiBlcnJvcnNcclxuICAgIGtleVxyXG4gICk7XHJcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGVjcnlwdGVkKTtcclxufVxyXG5cclxuY29uc3QgZGVjcnlwdFBheWxvYWQgPSBmdW5jdGlvbihcclxuICBwYXlsb2FkLFxyXG4gIHBvaW50ZXJLZXkgPSBcIlwiLFxyXG4gIHBvaW50ZXJPbGRLZXkgPSBcIlwiLFxyXG4gIHBvaW50ZXJTaG91bGRFbmNyeXB0LFxyXG4gIGN1c3RvbUtleVxyXG4pIHtcclxuICBpZiAoIW1pZGRsZXdhcmVXaWxsRW5jcnlwdChwb2ludGVyU2hvdWxkRW5jcnlwdCkpIHJldHVybiBwYXlsb2FkO1xyXG5cclxuICBpZiAoXHJcbiAgICAhaXNPYmplY3QocGF5bG9hZCkgfHxcclxuICAgICghcGF5bG9hZC5jb2dudXMgJiYgIXBheWxvYWQuZXJyb3IgJiYgIXBheWxvYWQuZGF0YSlcclxuICApXHJcbiAgICB0aHJvdyB7XHJcbiAgICAgIG1lc3NhZ2U6IFwiRVJST1IuSU5WQUxJRF9DT0dOVVNfUkVTUE9OU0VfT0JKRUNUXCJcclxuICAgIH07XHJcblxyXG4gIGlmIChwYXlsb2FkLmVycm9yKSB7XHJcbiAgICByZXR1cm4gcGF5bG9hZDtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBGaXJzdCBhdHRlbXB0IC0gd2l0aCBjdXJyZW50IGtleVxyXG4gICAgLy8gQ3VzdG9tIGtleSB3aWxsIG5ldmVyIGJlIHN0b3JlZFxyXG4gICAgcmV0dXJuIGRlY3J5cHQocGF5bG9hZCwgY3VzdG9tS2V5IHx8IHBvaW50ZXJLZXkpO1xyXG4gIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAvLyBTZWNvbmQgQXR0ZW1wdCAtIHdpdGggb2xkIGtleVxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGRlY3J5cHQocGF5bG9hZCwgY3VzdG9tS2V5IHx8IHBvaW50ZXJPbGRLZXkpO1xyXG4gICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgdGhyb3cge1xyXG4gICAgICAgIGRhdGE6IGV4LFxyXG4gICAgICAgIG1lc3NhZ2U6IFwiRVJST1IuRkFJTEVEX1RPX0RFQ1JZUFRcIlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGRlY3J5cHRQYXlsb2FkO1xyXG4iLCIvKipcclxuICogQG5hbWUgQmx1ZURhcndpbiBQcm9qZWN0OiBFbmNyeXB0aW9uXHJcbiAqIEBkZXNjcmlwdGlvbjogSGFuZGxlcyBvbmUgYW5kIHR3byB3YXkgZW5jcmlwdGlvbiBvZiBkYXRhLCB0aGUgZnVuY3Rpb24gbmFtZXMgYXJlIHByZWV0eSBtdWNoIGV4cGxhbmF0b3J5LCBub1xyXG4gKiAgICBuZWVkIHRvIGdvIGRlZXBlciBvbiB0aGF0IHF1ZXN0b25cclxuICogQG1ldGhvZCBlbmNyeXB0U3RyaW5nXHJcbiAqICAgIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcclxuICogICAgQHJldHVybiB7U3RyaW5nfSBlbmNyeXB0ZWQgc3RyaW5nXHJcbiAqIEBtZXRob2QgZW5jcnlwdFBheWxvYWRcclxuICogICAgQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcclxuICogICAgQHBhcmFtIHtTdHJpbmd9IGN5cGhlclxyXG4gKiAgICBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqICBAbWV0aG9kIGRlY3J5cHRQYXlsb2FkXHJcbiAqICAgIEBwYXJhbSB7U3RyaW5nfSBlbmNyeXB0ZWRQYXlsb2FkXHJcbiAqICAgIEBwYXJhbSB7U3RyaW5nfSBjeXBoZXJcclxuICogICAgQHJldHVybiB7T2JqZWN0fSBwYXlsb2FkXHJcbiAqL1xyXG5cclxuaW1wb3J0IGVuY3J5cHRTdHJpbmcgZnJvbSAnLi4vaGVscGVycy9lbmNyeXB0aW9uL2VuY3J5cHQtc3RyaW5nJztcclxuaW1wb3J0IHVwZGF0ZUtleSBmcm9tICcuLi9oZWxwZXJzL2VuY3J5cHRpb24vdXBkYXRlLWtleSc7XHJcbmltcG9ydCBlbmNyeXB0UGF5bG9hZCBmcm9tICcuLi9oZWxwZXJzL2VuY3J5cHRpb24vZW5jcnlwdC1wYXlsb2FkJztcclxuaW1wb3J0IGRlY3J5cHRQYXlsb2FkIGZyb20gJy4uL2hlbHBlcnMvZW5jcnlwdGlvbi9kZWNyeXB0LXBheWxvYWQnO1xyXG5pbXBvcnQgU2VydmljZSBmcm9tICcuJztcclxuXHJcbmltcG9ydCBDb25maWd1cmF0aW9uIGZyb20gJy4vY29uZmlndXJhdGlvbic7XHJcbmltcG9ydCBTdG9yYWdlIGZyb20gJy4vc3RvcmFnZSc7XHJcblxyXG4vLyBwcml2YXRlU2NvcGUgaXMgYSBwb2ludGVyIHRoYXQgY2FuIGJlIHVwZGF0ZWQgYnkgdGhlIGNsYXNzXHJcbmxldCBwcml2YXRlU2NvcGUgPSB7XHJcbiAga2V5OiAnJyxcclxuICBvbGRLZXk6ICcnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmNyeXB0aW9uIGV4dGVuZHMgU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihDb25maWd1cmF0aW9uLCBTdG9yYWdlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVuY3J5cHRzIGEgc3RyaW5nIHdpdGggb3VyIGJhc2UgZW5jcnlwdGlvblxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc3RyIFtkZXNjcmlwdGlvbl1cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICovXHJcbiAgZW5jcnlwdFN0cmluZyhzdHIpIHtcclxuICAgIHJldHVybiBlbmNyeXB0U3RyaW5nKHN0ciwgdGhpcy5Db25maWd1cmF0aW9uLmVuY3J5cHRpb24pO1xyXG4gIH1cclxuXHJcbiAgZW5jcnlwdFBheWxvYWQocGF5bG9hZCkge1xyXG4gICAgcmV0dXJuIGVuY3J5cHRQYXlsb2FkKFxyXG4gICAgICBwYXlsb2FkLFxyXG4gICAgICBwcml2YXRlU2NvcGUua2V5LFxyXG4gICAgICB0aGlzLkNvbmZpZ3VyYXRpb24uZW5jcnlwdGlvblxyXG4gICAgKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICAgICAqIEVuY3J5cHRzIGEgcGF5bG9hZCBpbiBvcmRlciB0byBiZSBjb25zdW1hYmxlIHdpdGggb3VyIEFQSVxyXG4gICAgICAgKiBAcGFyYW0gIHtAVE9ET30gcGF5bG9hZCBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAqIEByZXR1cm4ge09iamVjdHxDb2dudXNSZXNwb25zZX0ge1wiY29nbnVzXCI6XCJlbmNyeXB0ZWQgc3RyaW5nXCJ9XHJcbiAgICAgICAqXHJcbiAgICAgICBlbmNyeXB0UGF5bG9hZChwYXlsb2FkKSB7XHJcbiAgICAgICAgICBpZiAoIXRoaXMuI21pZGRsZXdhcmVXaWxsRW5jcmlwdCgpKSByZXR1cm4gcGF5bG9hZDtcclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2dudXM6IEJsdWVEYXJ3aW5CYXNlRW5jcnlwdGlvbi50d29XYXlFbmNyeXB0KHBheWxvYWQsIHRoaXMuI2tleSlcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAqIFRyaWVzIHRvIGRlY3J5cHQgYSBwYXlsb2FkIHdpdGhcclxuICAgICAgICogQHBhcmFtICB7Q29nbnVzUmVzcG9uc2VPYmplY3R9IHBheWxvYWQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R8SlNPTkFQSX1cclxuICAgICAgICovXHJcbiAgZGVjcnlwdFBheWxvYWQocGF5bG9hZCwgY3VzdG9tS2V5KSB7XHJcbiAgICByZXR1cm4gZGVjcnlwdFBheWxvYWQoXHJcbiAgICAgIHBheWxvYWQsXHJcbiAgICAgIHByaXZhdGVTY29wZS5rZXksXHJcbiAgICAgIHByaXZhdGVTY29wZS5vbGRLZXksXHJcbiAgICAgIHRoaXMuQ29uZmlndXJhdGlvbi5lbmNyeXB0aW9uLFxyXG4gICAgICBjdXN0b21LZXlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIG9sZCBrZXkgYW5kIHNldHMgbmV3IGtleVxyXG4gICAqIEBwYXJhbSAge1VVSUR9IG5ld0tleSBbZGVzY3JpcHRpb25dXHJcbiAgICogQHJldHVybiB7VW5kZWZpbmVkfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAqL1xyXG4gIHVwZGF0ZUtleShuZXdLZXkpIHtcclxuICAgIHVwZGF0ZUtleShuZXdLZXksIChwcml2YXRlU2NvcGUgPSBwcml2YXRlU2NvcGUpLCB0aGlzLlN0b3JhZ2UpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tIFwiLi4vLi4vYXBwLWNvbnN0YW50c1wiO1xyXG5pbXBvcnQgU3RvcmFnZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvc3RvcmFnZVwiO1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgYW5kIHN0b3JlcyB4LWFjY2Vzcy10b2tlblxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5ld1Rva2VuICAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSAge0ludGVybmFsUG9pbmVyfSBwb2ludGVyVG9rZW4gW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcmV0dXJuIHtVbmRlZmluZWR9ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG5cclxuY29uc3QgdXBkYXRlVG9rZW4gPSBmdW5jdGlvbihcclxuICBuZXdUb2tlbixcclxuICBwb2ludGVyID0geyB0b2tlbjogXCJcIiB9LFxyXG4gIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpXHJcbikge1xyXG4gIHBvaW50ZXIudG9rZW4gPSBuZXdUb2tlbjtcclxuXHJcbiAgc3RvcmFnZS5zZXQoQVBQX0NPTlNUQU5UUy5TVE9SQUdFLlRPS0VOLCBuZXdUb2tlbik7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB1cGRhdGVUb2tlbjtcclxuIiwiY29uc3QgZ2V0RnVuY3Rpb25Db250ZW50ID0gZnVuY3Rpb24oZnVuY3Rpb25TdHIpIHtcclxuICBjb25zdCBzZXBhcmF0b3IgPSBcIilcIjsgLy8gRmlyc3QgcGFydCBvZiBmdW5jdGlvbiB3aWxsIGJlIGZ1bmN0aW9uIHh4eCA9ICgpXHJcbiAgcmV0dXJuIGZ1bmN0aW9uU3RyXHJcbiAgICAuc3BsaXQoc2VwYXJhdG9yKVxyXG4gICAgLnNwbGljZSgxKVxyXG4gICAgLmpvaW4oc2VwYXJhdG9yKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldEZ1bmN0aW9uQ29udGVudDtcclxuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSBcImxvZGFzaC5pc2Z1bmN0aW9uXCI7XHJcbmltcG9ydCBnZXRGdW5jdGlvbkNvbnRlbnQgZnJvbSBcIi4vZ2V0LWZ1bmN0aW9uLWNvbnRlbnRcIjtcclxuXHJcbmNvbnN0IGlzRXF1YWxGdW5jdGlvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICBpZiAoIWlzRnVuY3Rpb24oYSkgfHwgIWlzRnVuY3Rpb24oYikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLy8gR2V0IG9ubHkgdGhlIGNvbnRlbnQgb2YgdGhlIGZ1bmN0aW9uXHJcbiAgcmV0dXJuIGdldEZ1bmN0aW9uQ29udGVudChhLnRvU3RyaW5nKCkpID09PSBnZXRGdW5jdGlvbkNvbnRlbnQoYi50b1N0cmluZygpKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlzRXF1YWxGdW5jdGlvbjtcclxuIiwiaW1wb3J0IGlzRXF1YWxGdW5jdGlvbiBmcm9tIFwiLi9pcy1lcXVhbC1mdW5jdGlvblwiO1xyXG5cclxuY29uc3QgYXJyYXlDb250YWluc0Z1bmN0aW9uID0gZnVuY3Rpb24oYXJyYXksIGZuKSB7XHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoaXNFcXVhbEZ1bmN0aW9uKGFycmF5W2ldLCBmbikpIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXJyYXlDb250YWluc0Z1bmN0aW9uO1xyXG4iLCIvKipcclxuICogQG5hbWUgQmx1ZURhcndpbiBQcm9qZWN0OiBWYWxpZGF0b3JcclxuICogQGRlc2MgQSBzaW1wbGUgdXRpbHMgdXRpbCB0byB2YWxpZGF0ZSBzb21lIHByb3BlcnRpZXMuIEFsbCBmdW5jdGlvbnMgcmV0dXJuIGEgYm9vbGVhblxyXG4gKi9cclxuXHJcbmltcG9ydCBpc0VtcHR5IGZyb20gXCJsb2Rhc2guaXNlbXB0eVwiO1xyXG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tIFwibG9kYXNoLmlzZnVuY3Rpb25cIjtcclxuaW1wb3J0IGdldEZ1bmN0aW9uQ29udGVudCBmcm9tIFwiLi4vaGVscGVycy92YWxpZGF0b3JzL2dldC1mdW5jdGlvbi1jb250ZW50XCI7XHJcbmltcG9ydCBpc0VxdWFsRnVuY3Rpb24gZnJvbSBcIi4uL2hlbHBlcnMvdmFsaWRhdG9ycy9pcy1lcXVhbC1mdW5jdGlvblwiO1xyXG5pbXBvcnQgYXJyYXlDb250YWluc0Z1bmN0aW9uIGZyb20gXCIuLi9oZWxwZXJzL3ZhbGlkYXRvcnMvYXJyYXktY29udGFpbnMtZnVuY3Rpb25cIjtcclxuaW1wb3J0IFNlcnZpY2UgZnJvbSBcIi5cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhbGlkYXRvciBleHRlbmRzIFNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICB9XHJcblxyXG4gIGdldEZ1bmN0aW9uQ29udGVudChmdW5jdGlvblN0cikge1xyXG4gICAgcmV0dXJuIGdldEZ1bmN0aW9uQ29udGVudChmdW5jdGlvblN0cik7XHJcbiAgfVxyXG5cclxuICBpc0VtcHR5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNFbXB0eSh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBpc0Z1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBpc0VxdWFsRnVuY3Rpb24oYSwgYikge1xyXG4gICAgcmV0dXJuIGlzRXF1YWxGdW5jdGlvbihhLCBiKTtcclxuICB9XHJcblxyXG4gIGNvbnRhaW5zRnVuY3Rpb24oYXJyYXksIGZuKSB7XHJcbiAgICByZXR1cm4gYXJyYXlDb250YWluc0Z1bmN0aW9uKGFycmF5LCBmbik7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBJZiB1cmwgaGFzIGtleSBhbmQvb3IgdG9rZW4gaXQgc2hvdWxkIHVwZGF0ZSBlbmNyeXB0aW9uS2V5IGFuZFxyXG4gKiBIdHRwIHRva2VuXHJcbiAqIEBwYXJhbSAge0h0dHBSZXNwb25zZX0gZGVjcnlwdGVkUmVzcG9uc2UgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcmV0dXJuIHtVbmRlZmluZWR9ICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICovXHJcblxyXG5pbXBvcnQgdXBkYXRlVG9rZW4gZnJvbSBcIi4vdXBkYXRlLXRva2VuXCI7XHJcbmltcG9ydCBWYWxpZGF0b3IgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3ZhbGlkYXRvclwiO1xyXG5pbXBvcnQgRW5jcnlwdGlvbiBmcm9tIFwiLi4vLi4vc2VydmljZXMvZW5jcnlwdGlvblwiO1xyXG5pbXBvcnQgU3RvcmFnZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvc3RvcmFnZVwiO1xyXG5cclxuXHJcbmNvbnN0IGNoZWNrUmVzcG9uc2VGb3JLZXlBbmRUb2tlbiA9IGZ1bmN0aW9uKFxyXG4gIGRlY3J5cHRlZFBheWxvYWQsXHJcbiAgcG9pbnRlclRva2VuID0geyB0b2tlbjogXCJcIiB9LFxyXG4gIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IoKSxcclxuICBlbmNyeXB0aW9uID0gbmV3IEVuY3J5cHRpb24oKSxcclxuICBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKVxyXG4pIHtcclxuICBjb25zdCB0b2tlbiA9IGRlY3J5cHRlZFBheWxvYWQudG9rZW47XHJcbiAgY29uc3Qga2V5ID0gZGVjcnlwdGVkUGF5bG9hZC5rZXk7XHJcblxyXG4gIGlmICh0b2tlbiAmJiB2YWxpZGF0b3IuaXNGdW5jdGlvbih1cGRhdGVUb2tlbikpXHJcbiAgICB1cGRhdGVUb2tlbih0b2tlbiwgcG9pbnRlclRva2VuLCBzdG9yYWdlKTtcclxuICBpZiAoa2V5KSBlbmNyeXB0aW9uLnVwZGF0ZUtleShrZXkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2hlY2tSZXNwb25zZUZvcktleUFuZFRva2VuO1xyXG4iLCIvKipcclxuICogQG5hbWUgQmx1ZURhcndpbiBQcm9qZWN0OiBQdWJTdWJcclxuICogQGRlc2NyaXB0aW9uOiBWZXJ5IHNpbXBsZSBwdWJzdWIgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBhbmQgcnVuIGZ1bmN0aW9ucyB3aGVuIHRoZXkgaGFwcGVuXHJcbiAqIEBub3RlIFRISVMgSVMgQSBTSU5HTEVUT04sIFNJTkNFIEkgRE9OJ1QgV0FOVCBNVUxUSVBMRSBJTlNUQU5DRVMgT0YgUFVCU1VCU1xyXG4gKi9cclxuaW1wb3J0IFNlcnZpY2UgZnJvbSBcIi5cIjtcclxuaW1wb3J0IFZhbGlkYXRvciBmcm9tIFwiLi92YWxpZGF0b3JcIjtcclxuXHJcbmNvbnN0IF9ldmVudHMgPSB7fTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1YlN1YiBleHRlbmRzIFNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoVmFsaWRhdG9yKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lX29uXHJcbiAgICogQGRlc2MgQ3JlYXRlcyBhIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYSBnaXZlbiBldmVudCBuYW1lLiBXaWxsIGFkZCB1bmlxdWUgZnVuY3Rpb25zXHJcbiAgICogIHZhbGlkYXRlcyBpZiBjYWxsYmFjayBpcyBhIGZ1bmN0aW9uLCBpZiBjYWxsYmFjayBleGlzdHMgb24gY3VycmVudCBldmVudFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqIEByZXR1cm4ge1ZvaWR9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICovXHJcbiAgb24oZXZlbnROYW1lID0gXCIqXCIsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgICF0aGlzLlZhbGlkYXRvci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSB8fFxyXG4gICAgICAoX2V2ZW50c1tldmVudE5hbWVdICYmXHJcbiAgICAgICAgdGhpcy5WYWxpZGF0b3IuY29udGFpbnNGdW5jdGlvbihfZXZlbnRzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKSlcclxuICAgIClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIF9ldmVudHNbZXZlbnROYW1lXSA9IF9ldmVudHNbZXZlbnROYW1lXSB8fCB0aGlzLnJlc2V0KGV2ZW50TmFtZSk7XHJcbiAgICBfZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBvZmZcclxuICAgKiBAZGVzYyBSZW1vdmVzIGEgY2FsbGJhY2sgZnJvbSBhIGV2ZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICogQHJldHVybiB7Vm9pZH1cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKi9cclxuICBvZmYoZXZlbnROYW1lID0gXCIqXCIsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoX2V2ZW50c1tldmVudE5hbWVdICYmIEFycmF5LmlzQXJyYXkoX2V2ZW50c1tldmVudE5hbWVdKSkge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9ldmVudHNbZXZlbnROYW1lXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChfZXZlbnRzW2V2ZW50TmFtZV1baV0gPT09IGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICBfZXZlbnRzW2V2ZW50TmFtZV0uc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBlbWl0XHJcbiAgICogQGRlc2MgZGVidWdnaW5nIG9ubHlcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXHJcbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICovXHJcbiAgZW1pdChldmVudE5hbWUgPSBcIipcIiwgZGF0YSkge1xyXG4gICAgaWYgKF9ldmVudHNbZXZlbnROYW1lXSkge1xyXG4gICAgICBfZXZlbnRzW2V2ZW50TmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiB7XHJcbiAgICAgICAgY2FsbGJhY2soZGF0YSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgcmVzZXRcclxuICAgKiBAZGVzYyBSZW1vdmVzIGFsbCBjYWxsYmFja3MgZnJvbSBhIGV2ZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICogQHJldHVybiB7Vm9pZH1cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKi9cclxuICByZXNldChldmVudE5hbWUgPSBcIipcIikge1xyXG4gICAgbGV0IHJlc2V0ID0gW107XHJcbiAgICBfZXZlbnRzW2V2ZW50TmFtZV0gPSByZXNldDtcclxuICAgIHJldHVybiByZXNldDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgZXZlbnRzXHJcbiAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICovXHJcbiAgZ2V0RXZlbnRzKCkge1xyXG4gICAgcmV0dXJuIF9ldmVudHM7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gXCIuLi8uLi9hcHAtY29uc3RhbnRzXCI7XHJcblxyXG5pbXBvcnQgUHViU3ViIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9wdWItc3ViXCI7XHJcblxyXG4vLyBAVE9ETzogZGlzY292ZXIgd2h5IHB1YnN1YiBpc24ndCB2YWxpZCBpbmplY3Rpb25cclxuXHJcbmNvbnN0IGV2ZW50VG9rZW5OZWdvdGlhdGlvblJlcXVpcmVkID0gZnVuY3Rpb24ocHViU3ViID0gbmV3IFB1YlN1YigpKSB7XHJcbiAgcHViU3ViLmVtaXQoQVBQX0NPTlNUQU5UUy5FVkVOVFMuVE9LRU5fTkVHT1RJQVRJT05fUkVRVUlSRUQpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZXZlbnRUb2tlbk5lZ290aWF0aW9uUmVxdWlyZWQ7XHJcbiIsIi8vIFNpbXBsZSBwcm94eSBmb3IgdW5pdCB0ZXN0aW5nIGZldGNoIEFQSVxyXG4vLyBJZiBvbiBub2RlIHRlc3RpbmcgZW52aXJvbm1lbnQgdXNlIG5vZGUtZmV0Y2ggLCB1bmFibGUgdG8gZG8gdGhpcyBieSB1c2luZyByZXdpcmUgc29cclxuLy8gZW5kZWQgdXAgbGlrZSB0aGlzLiBBIG1vcmUgZWxlZ2FudCBzb2x1dGlvbiB3b3VsZCBiZSBhd2Vzb21lLlxyXG4vLyBpZiAoIWdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xyXG4vLyAgIHJlcXVpcmUoJ2JhYmVsLXBvbHlmaWxsJyk7XHJcbi8vIH1cclxuXHJcbi8vIEZpeCBmb3IgdW5pdCB0ZXN0aW5nXHJcbmxldCBfZmV0Y2g7XHJcbmlmICghX2ZldGNoKSB7XHJcbiAgdHJ5IHtcclxuICAgIF9mZXRjaCA9IGZldGNoO1xyXG4gIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBfZmV0Y2ggPSByZXF1aXJlKCdub2RlLWZldGNoJyk7XHJcbiAgICB9IGNhdGNoIChfZXgpIHtcclxuICAgICAgLy8gLi4uIFNpbGVuY2UgaXMgZ29sZGVuXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBoYW5kbGVSZXF1ZXN0ID0gYXN5bmMgZnVuY3Rpb24odXJsLCBwYXJhbXMpIHtcclxuICAvLyBDcmVhdGUgYSBmZXRjaCBBUEkgcmVxdWVzdFxyXG4gIGxldCByZXNwb25zZSA9IGF3YWl0IF9mZXRjaCh1cmwsIHBhcmFtcyk7XHJcblxyXG4gIC8vIFwiV2FpdFwiIHRvIGdldCBqc29uIGZyb20gcmVzcG9uc2VcclxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICByZXR1cm4geyByZXNwb25zZSwgZGF0YSB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlUmVxdWVzdDtcclxuIiwiLy8gaWYgKCFnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcclxuLy8gICByZXF1aXJlKFwiYmFiZWwtcG9seWZpbGxcIik7XHJcbi8vIH1cclxuXHJcbmltcG9ydCBFbmNyeXB0aW9uIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9lbmNyeXB0aW9uXCI7XHJcbmltcG9ydCBjaGVja1Jlc3BvbnNlRm9yS2V5QW5kVG9rZW4gZnJvbSBcIi4vY2hlY2stcmVzcG9uc2UtZm9yLWtleS1hbmQtdG9rZW5cIjtcclxuaW1wb3J0IGV2ZW50VG9rZW5OZWdvdGlhdGlvblJlcXVpcmVkIGZyb20gXCIuL2V2ZW50LXRva2VuLW5lZ290aWF0aW9uLXJlcXVpcmVkXCI7XHJcbmltcG9ydCBoYW5kbGVSZXF1ZXN0IGZyb20gXCIuL2hhbmRsZS1yZXF1ZXN0XCI7XHJcbmltcG9ydCBWYWxpZGF0b3IgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3ZhbGlkYXRvclwiO1xyXG5pbXBvcnQgU3RvcmFnZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvc3RvcmFnZVwiO1xyXG5pbXBvcnQgUHViU3ViIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9wdWItc3ViXCI7XHJcblxyXG4vKipcclxuICogSGFuZGxlcyBhIHJlc3BvbnNlOlxyXG4gKiBBd2FpdHMgdG8gZmV0Y2gsXHJcbiAqIERlY3J5b3RzIHBheWxvYXNcclxuICogQ2hlY2tzIGZvciB0b2tlbiBhbmQga2V5IHRvIHVwZGF0ZSB0aGVtIGlmIG5lc3NlZFxyXG4gKiBSZXR1cm5zIGhhbmRsZWQgZGF0YVxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybFxyXG4gKiBAcGFyYW0gIHtwYXlsb2FkfSB1cmxcclxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG5jb25zdCBjb25maWdPYmplY3QgPSB7XHJcbiAgbG9naW5EZWNyeXB0aW9uOiBmYWxzZSxcclxuICBnZXRGdWxsUmVzcG9uc2U6IGZhbHNlXHJcbn07XHJcblxyXG5jb25zdCBoYW5kbGVSZXNwb25zZSA9IGFzeW5jIGZ1bmN0aW9uKFxyXG4gIHJlc3BvbnNlLFxyXG4gIGRhdGEsXHJcbiAgY29uZmlnID0gY29uZmlnT2JqZWN0LFxyXG4gIHBvaW50ZXJUb2tlbiA9IHsgdG9rZW46IFwiXCIgfSxcclxuICBlbmNyeXB0aW9uID0gbmV3IEVuY3J5cHRpb24oKSxcclxuICB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKCksXHJcbiAgc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCksXHJcbiAgcHViU3ViID0gbmV3IFB1YlN1YigpXHJcbikge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBEZWNyaXB0IGRhdGEgZnJvbSByZXNwb25zZSBhbmRcclxuICAgIGRhdGEgPSBjb25maWcubG9naW5EZWNyeXB0aW9uXHJcbiAgICAgID8gZW5jcnlwdGlvbi5kZWNyeXB0UGF5bG9hZChkYXRhLCBjb25maWcubG9naW5EZWNyeXB0aW9uKVxyXG4gICAgICA6IGVuY3J5cHRpb24uZGVjcnlwdFBheWxvYWQoZGF0YSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIFRva2VuIGFuZCBrZXkgaWYgbmVlZGVkXHJcblxyXG4gICAgY2hlY2tSZXNwb25zZUZvcktleUFuZFRva2VuKFxyXG4gICAgICBkYXRhLFxyXG4gICAgICBwb2ludGVyVG9rZW4sXHJcbiAgICAgIHZhbGlkYXRvcixcclxuICAgICAgZW5jcnlwdGlvbixcclxuICAgICAgc3RvcmFnZVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBjaGVjayBpZiBzZW5kcyBmdWxsIHJlc3BvbnNlXHJcbiAgICAvLyBUcmllcyBkYXRhLmRhdGEgKEFQSSksIGRhdGEuZXJyb3IgKEFQSUVycm9yKSBhbmQgdGhlbiBkYXRhT25seSBmb3Igb3JjaGVzdHJhdG9yXHJcbiAgICBkYXRhID0gY29uZmlnLmdldEZ1bGxSZXNwb25zZSA/IGRhdGEgOiBkYXRhLmRhdGEgfHwgZGF0YS5lcnJvciB8fCBkYXRhO1xyXG5cclxuICAgIC8vIElmIHN1Y2Nlc3MgcmV0dXJuIGhhbmRsZWQgZGF0YVxyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcXVpcmVzIG5lZ290aWF0aW9uXHJcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDMpIHtcclxuICAgICAgZXZlbnRUb2tlbk5lZ290aWF0aW9uUmVxdWlyZWQocHViU3ViKTtcclxuICAgIH1cclxuICAgIC8vIEZhaWxlZCB3aXRoIDUwMFxyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwKSB7XHJcbiAgICAgIC8vQHRvZG9cclxuICAgIH1cclxuICAgIC8vIEB0b2RvOiBTZWUgd2h5IHRoZW4gZGF0YSBmYWlscyBhaW50IGdvaW5nIGRlY3J5cHRlZFxyXG5cclxuICAgIGNvbnN0IGZhaWwgPSBkYXRhLmNvZ251cyA/IGVuY3J5cHRpb24uZGVjcnlwdFBheWxvYWQoZGF0YSkgOiBkYXRhO1xyXG4gICAgdGhyb3cgZmFpbDtcclxuICAgIC8vIFJldHVybiBoYW5kbGVkIGRhdGFcclxuICB9IGNhdGNoIChleCkge1xyXG4gICAgdGhyb3cgZXg7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlUmVzcG9uc2U7XHJcbiIsImV4cG9ydCBkZWZhdWx0IHtcclxuICBkYXRhOiBmYWxzZSxcclxuICBtZXNzYWdlOiBmYWxzZVxyXG59O1xyXG4iLCJjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xyXG4gIHJldHVyblR5cGU6IFwiUEFUSFwiIC8vIFBBVEggfHwgVU5ERUZJTkVEXHJcbn07XHJcblxyXG5jb25zdCBzZWFyY2hPbmplY3RQYXRoID0gZnVuY3Rpb24oXHJcbiAgb2JqZWN0ID0ge30sXHJcbiAgcGF0aCA9IFwiXCIsXHJcbiAgY29uZmlnID0gZGVmYXVsdENvbmZpZ1xyXG4pIHtcclxuICBjb25zdCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcclxuXHJcbiAgbGV0IGN1cnJlbnRPYmplY3QgPSBvYmplY3Q7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXRQYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHNwbGl0UGF0aFtpXTtcclxuICAgIGNvbnN0IHRlc3ROb2RlID0gY3VycmVudE9iamVjdFtjdXJyZW50UGF0aF07XHJcbiAgICBpZiAodGVzdE5vZGUpIHtcclxuICAgICAgY3VycmVudE9iamVjdCA9IHRlc3ROb2RlO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVmYXVsdENvbmZpZy5yZXR1cm5UeXBlID09PSBcIlBBVEhcIiA/IHBhdGggOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3VycmVudE9iamVjdDtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNlYXJjaE9uamVjdFBhdGg7XHJcbiIsImltcG9ydCBzZWFyY2hPbmplY3RQYXRoIGZyb20gXCIuLi9oZWxwZXJzL3NlYXJjaC1vYmplY3QtcGF0aFwiO1xyXG5pbXBvcnQgU2VydmljZSBmcm9tIFwiLlwiO1xyXG5pbXBvcnQgQ29uZmlndXJhdGlvbiBmcm9tIFwiLi9jb25maWd1cmF0aW9uXCI7XHJcblxyXG5sZXQgZGljdGlvbmFyeTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zbGF0ZSBleHRlbmRzIFNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlID0ge30pIHtcclxuICAgIHN1cGVyKENvbmZpZ3VyYXRpb24pO1xyXG4gICAgdGhpcy5zZXRMYW5ndWFnZShsYW5ndWFnZSB8fCB0aGlzLkNvbmZpZ3VyYXRpb24ubGFuZ3VhZ2UpO1xyXG4gIH1cclxuXHJcbiAgc2V0TGFuZ3VhZ2UobGFuZ3VhZ2UgPSB7fSkge1xyXG4gICAgZGljdGlvbmFyeSA9IGxhbmd1YWdlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNsYXRlcyBhIGtleVxyXG4gICAqIEBwYXJhbSAge1N0cmluZ31cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgaW5zdGFudChrZXkgPSBcIlwiKSB7XHJcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBrZXkudHJpbSgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgcmV0dXJuIHNlYXJjaE9uamVjdFBhdGgoZGljdGlvbmFyeSwga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBTaW1wbGUgRnVuY3Rpb24gdG8gc3RhbmRhcmRpemUgZnVuY3Rpb24gcmVzcG9uc2VzXHJcbiAqIEBwYXJhbSAge0VudW1bMCwxLDJdfSBzdGF0dXNJbmRleFxyXG4gKiBAcGFyYW0gIHtBbnl9IGluZm8gLSByZXNwb25zZSBzdWNjZXNzIGRhdGFcclxuICogQHJldHVybiB7W1Jlc3BvbnNlXX1cclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBpbmZvT2JqZWN0IGZyb20gXCIuLi9oZWxwZXJzL2NvbmZpZy1vYmplY3RzL3Jlc3BvbnNlXCI7XHJcbmltcG9ydCBTZXJ2aWNlIGZyb20gXCIuL2luZGV4XCI7XHJcbmltcG9ydCBUcmFuc2xhdGUgZnJvbSBcIi4vdHJhbnNsYXRlXCI7XHJcblxyXG5jb25zdCBhdmFpbGFibGVTdGF0dXMgPSBbXCJPS1wiLCBcIldBUk5cIiwgXCJGQUlMXCJdO1xyXG5cclxuY29uc3QgYnVpbGRSZXNwb25zZSA9IGZ1bmN0aW9uKGluZGV4LCBpbmZvLCBUcmFuc2xhdGUpIHtcclxuICBjb25zdCBzdGF0dXMgPSBhdmFpbGFibGVTdGF0dXNbaW5kZXhdO1xyXG4gIGNvbnN0IGRhdGEgPSBpbmZvLmRhdGE7XHJcbiAgY29uc3QgbWVzc2FnZSA9IFRyYW5zbGF0ZS5pbnN0YW50KGluZm8ubWVzc2FnZSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzdGF0dXMsXHJcbiAgICBkYXRhLFxyXG4gICAgbWVzc2FnZVxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNwb25zZSBleHRlbmRzIFNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoVHJhbnNsYXRlKTtcclxuICB9XHJcblxyXG4gIG9rKGluZm8gPSBpbmZvT2JqZWN0KSB7XHJcbiAgICByZXR1cm4gYnVpbGRSZXNwb25zZSgwLCBpbmZvLCB0aGlzLlRyYW5zbGF0ZSk7XHJcbiAgfVxyXG5cclxuICB3YXJuKGluZm8gPSBpbmZvT2JqZWN0KSB7XHJcbiAgICByZXR1cm4gYnVpbGRSZXNwb25zZSgxLCBpbmZvLCB0aGlzLlRyYW5zbGF0ZSk7XHJcbiAgfVxyXG5cclxuICBlcnJvcihpbmZvID0gaW5mb09iamVjdCkge1xyXG4gICAgcmV0dXJuIGJ1aWxkUmVzcG9uc2UoMiwgaW5mbywgdGhpcy5UcmFuc2xhdGUpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgRW5jcnlwdGlvbiBmcm9tIFwiLi4vLi4vc2VydmljZXMvZW5jcnlwdGlvblwiO1xyXG5pbXBvcnQgUmVzcG9uc2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3Jlc3BvbnNlXCI7XHJcbi8qKlxyXG4gKiBEZWNyeXB0cyBhbmQgaGFuZGxlcyBhIGZhaWxlZCByZXF1ZXN0XHJcbiAqIEBwYXJhbSAge0h0dHBFcnJvcn0gZXggW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcmV0dXJuIHtSZXNwb25zZX1cclxuICovXHJcblxyXG5jb25zdCBoYW5kbGVGYWlsID0gZnVuY3Rpb24oXHJcbiAgZXgsXHJcbiAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoKSxcclxuICBlbmNyeXB0aW9uID0gbmV3IEVuY3J5cHRpb24oKVxyXG4pIHtcclxuICB0cnkge1xyXG4gICAgLy8gaWYgY2FuIGRlY3J5cHRcclxuICAgIGNvbnN0IGRhdGEgPSBlbmNyeXB0aW9uLmRlY3J5cHRQYXlsb2FkKGV4KTtcclxuICAgIHJldHVybiByZXNwb25zZS5lcnJvcih7XHJcbiAgICAgIGRhdGEsXHJcbiAgICAgIG1lc3NhZ2U6IFwiRVJST1IuSFRUUF9SRVFVRVNUX0ZBSUxcIlxyXG4gICAgfSk7XHJcbiAgfSBjYXRjaCAoX2V4KSB7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZXJyb3Ioe1xyXG4gICAgICBkYXRhOiBfZXgsXHJcbiAgICAgIG1lc3NhZ2U6IFwiRVJST1IuRkFJTEVEX1RPX0RFQ1JZUFRcIlxyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlRmFpbDtcclxuIiwiLyoqXHJcbiAqIEdldHMgaHR0cCBoZWFkZXJzXHJcbiAqIEBwYXJhbSAge1ByaXZhdGUgdmFyaWFibGUgdG9rZW59IHBvaW50ZXJUb2tlblxyXG4gKiBAcmV0dXJuIHtIZWFkZXJzT2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZ2V0SGVhZGVycyA9IGZ1bmN0aW9uKHBvaW50ZXJUb2tlbiA9IHsgdG9rZW46IFwiXCIgfSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgIFwieC1hY2Nlc3MtdG9rZW5cIjogcG9pbnRlclRva2VuLnRva2VuXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldEhlYWRlcnM7XHJcbiIsIi8vIGlmICghZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XHJcbi8vICAgcmVxdWlyZShcImJhYmVsLXBvbHlmaWxsXCIpO1xyXG4vLyB9XHJcblxyXG5pbXBvcnQgYnVpbGRVcmwgZnJvbSBcIi4vYnVpbGQtdXJsXCI7XHJcbmltcG9ydCBoYW5kbGVSZXNwb25zZSBmcm9tIFwiLi9oYW5kbGUtcmVzcG9uc2VcIjtcclxuaW1wb3J0IGhhbmRsZUZhaWwgZnJvbSBcIi4vaGFuZGxlLWZhaWxcIjtcclxuaW1wb3J0IGdldEhlYWRlcnMgZnJvbSBcIi4vZ2V0LWhlYWRlcnNcIjtcclxuaW1wb3J0IENvbmZpZ3VyYXRpb24gZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2NvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IFZhbGlkYXRvciBmcm9tIFwiLi4vLi4vc2VydmljZXMvdmFsaWRhdG9yXCI7XHJcbmltcG9ydCBQdWJTdWIgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3B1Yi1zdWJcIjtcclxuaW1wb3J0IEVuY3J5cHRpb24gZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2VuY3J5cHRpb25cIjtcclxuaW1wb3J0IFJlc3BvbnNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9yZXNwb25zZVwiO1xyXG5pbXBvcnQgU3RvcmFnZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvc3RvcmFnZVwiO1xyXG5pbXBvcnQgaGFuZGxlUmVxdWVzdCBmcm9tIFwiLi9oYW5kbGUtcmVxdWVzdFwiO1xyXG5cclxuLyoqXHJcbiAqIEdFVCByZXF1ZXN0XHJcbiAqIEBwYXJhbSAge1N0cmluZ30gcm91dGUgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSAge09iamVjdH0gW2NvbmZpZz17XHJcbiAgICBnZXRGdWxsUmVzcG9uc2U6IGZhbHNlLCAvLyBSZXR1cm5zIG9ubHkgZGF0YS5cclxuICB9XVxyXG4gKiBAcGFyYW0gIHtQb2ludGVyfSBwb2ludGVyQXBpVXJsIFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtICB7UG9pbnRlcn0gcG9pbnRlclRva2VuICBbZGVzY3JpcHRpb25dXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKi9cclxuXHJcbmNvbnN0IHJlcXVlc3RHZXQgPSBhc3luYyBmdW5jdGlvbihcclxuICByb3V0ZSxcclxuICBjb25maWcsXHJcbiAgcG9pbnRlclRva2VuID0geyB0b2tlbjogXCJcIiB9LFxyXG4gIGNvbmZpZ3VyYXRpb24gPSBuZXcgQ29uZmlndXJhdGlvbigpLFxyXG4gIGVuY3J5cHRpb24gPSBuZXcgRW5jcnlwdGlvbigpLFxyXG4gIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKCksXHJcbiAgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcigpLFxyXG4gIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpLFxyXG4gIHB1YlN1YiA9IG5ldyBQdWJTdWIoKVxyXG4pIHtcclxuICB0cnkge1xyXG4gICAgLy8gU2V0dXAgdGhlIFVSTFxyXG4gICAgbGV0IHVybCA9IGJ1aWxkVXJsKHJvdXRlLCBjb25maWd1cmF0aW9uKTtcclxuICAgIC8vIFNldHVwIHRoZSBwYXJhbWV0ZXJzXHJcbiAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXHJcbiAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnMocG9pbnRlclRva2VuKVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBcIldhaXRcIiBmb3IgcmVzcG9uc2VcclxuICAgIGxldCB7IHJlc3BvbnNlLCBkYXRhIH0gPSBhd2FpdCBoYW5kbGVSZXF1ZXN0KHVybCwgcGFyYW1zKTtcclxuXHJcbiAgICByZXR1cm4gaGFuZGxlUmVzcG9uc2UoXHJcbiAgICAgIHJlc3BvbnNlLFxyXG4gICAgICBkYXRhLFxyXG4gICAgICBjb25maWcsXHJcbiAgICAgIHBvaW50ZXJUb2tlbixcclxuICAgICAgZW5jcnlwdGlvbixcclxuICAgICAgdmFsaWRhdG9yLFxyXG4gICAgICBzdG9yYWdlLFxyXG4gICAgICBwdWJTdWJcclxuICAgICk7XHJcbiAgfSBjYXRjaCAoZXgpIHtcclxuICAgIHRocm93IGhhbmRsZUZhaWwoZXgsIHJlc3BvbnNlLCBlbmNyeXB0aW9uKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCByZXF1ZXN0R2V0O1xyXG4iLCJleHBvcnQgZGVmYXVsdCB7XHJcbiAgc2tpcEVuY3J5cHRpb246IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBIYW5kbGVzIGJvZHlcclxuICogQ2hlY2tzIGZvciBza2lwRW5jcnlwdGlvbiBmbGFnXHJcbiAqIEpTT04uc3RyaW5naWZpZXMgdGhlIGJvZHlcclxuICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkIC0gcGF5bG9hZCB0byBiZSBlbmNyeXB0ZWQgYW5kIHN0cmluZ2lmaWVkXHJcbiAqIEBwYXJhbSAge09iamVjdH0gY29uZmlnIC0gY29uZmlndXJhdGlvbnMgZm9yIHRoaXMgcmVxdWVzdFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5cclxuaW1wb3J0IEVuY3J5cHRpb24gZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2VuY3J5cHRpb25cIjtcclxuaW1wb3J0ICogYXMgY29uZmlnT2JqZWN0IGZyb20gXCIuLi9jb25maWctb2JqZWN0cy9odHRwLXJlcXVlc3QtYm9keVwiO1xyXG5cclxuY29uc3QgcGFyc2VCb2R5ID0gZnVuY3Rpb24oXHJcbiAgcGF5bG9hZCA9IHt9LFxyXG4gIGNvbmZpZyA9IGNvbmZpZ09iamVjdCxcclxuICBlbmNyeXB0aW9uID0gbmV3IEVuY3J5cHRpb24oKVxyXG4pIHtcclxuICBpZiAoIWNvbmZpZy5za2lwRW5jcnlwdGlvbikgcGF5bG9hZCA9IGVuY3J5cHRpb24uZW5jcnlwdFBheWxvYWQocGF5bG9hZCk7XHJcblxyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHBhcnNlQm9keTtcclxuIiwiZXhwb3J0IGRlZmF1bHQge1xyXG4gIHNraXBFbmNyeXB0aW9uOiBmYWxzZSxcclxuICBsb2dpbkRlY3J5cHRpb246IGZhbHNlLFxyXG4gIGdldEZ1bGxSZXNwb25zZTogZmFsc2VcclxufTtcclxuIiwiLy8gaWYgKCFnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcclxuLy8gICByZXF1aXJlKCdiYWJlbC1wb2x5ZmlsbCcpO1xyXG4vLyB9XHJcblxyXG5pbXBvcnQgYnVpbGRVcmwgZnJvbSAnLi9idWlsZC11cmwnO1xyXG5pbXBvcnQgaGFuZGxlUmVzcG9uc2UgZnJvbSAnLi9oYW5kbGUtcmVzcG9uc2UnO1xyXG5pbXBvcnQgaGFuZGxlRmFpbCBmcm9tICcuL2hhbmRsZS1mYWlsJztcclxuaW1wb3J0IHBhcnNlQm9keSBmcm9tICcuL3BhcnNlLWJvZHknO1xyXG5pbXBvcnQgZ2V0SGVhZGVycyBmcm9tICcuL2dldC1oZWFkZXJzJztcclxuXHJcbmltcG9ydCBDb25maWd1cmF0aW9uIGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbmZpZ3VyYXRpb24nO1xyXG5pbXBvcnQgRW5jcnlwdGlvbiBmcm9tICcuLi8uLi9zZXJ2aWNlcy9lbmNyeXB0aW9uJztcclxuaW1wb3J0IFJlc3BvbnNlIGZyb20gJy4uLy4uL3NlcnZpY2VzL3Jlc3BvbnNlJztcclxuXHJcbmltcG9ydCAqIGFzIGNvbmZpZ09iamVjdCBmcm9tICcuLi9jb25maWctb2JqZWN0cy9odHRwLXJlcXVlc3QnO1xyXG5pbXBvcnQgVmFsaWRhdG9yIGZyb20gJy4uLy4uL3NlcnZpY2VzL3ZhbGlkYXRvcic7XHJcbmltcG9ydCBTdG9yYWdlIGZyb20gJy4uLy4uL3NlcnZpY2VzL3N0b3JhZ2UnO1xyXG5pbXBvcnQgUHViU3ViIGZyb20gJy4uLy4uL3NlcnZpY2VzL3B1Yi1zdWInO1xyXG5pbXBvcnQgaGFuZGxlUmVxdWVzdCBmcm9tICcuL2hhbmRsZS1yZXF1ZXN0JztcclxuLyoqXHJcbiAgICogUG9zdCByZXF1ZXN0XHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSByb3V0ZSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhICAgICAgICBbYm9keV1cclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtjb25maWc9e1xyXG4gICAgICAgc2tpcEVuY3J5cHRpb246IGZhbHNlLFxyXG4gICAgICAgbG9naW5EZWNyeXB0aW9uOiBmYWxzZSxcclxuICAgICAgIGdldEZ1bGxSZXNwb25zZTogZmFsc2UsIC8vIFJldHVybnMgb25seSBkYXRhLlxyXG4gICAgfV1cclxuICAgKiBAcGFyYW0ge1BvaW50ZXJ9IHBvaW50ZXJBcGlVcmxcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJ9IHBvaW50ZXJUb2tlblxyXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAqL1xyXG5cclxuY29uc3QgcmVxdWVzdFBvc3QgPSBhc3luYyBmdW5jdGlvbihcclxuICByb3V0ZSxcclxuICBfZGF0YSxcclxuICBjb25maWcgPSBjb25maWdPYmplY3QsXHJcbiAgcG9pbnRlclRva2VuLFxyXG4gIGNvbmZpZ3VyYXRpb24gPSBuZXcgQ29uZmlndXJhdGlvbigpLFxyXG4gIGVuY3J5cHRpb24gPSBuZXcgRW5jcnlwdGlvbigpLFxyXG4gIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKCksXHJcbiAgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcigpLFxyXG4gIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpLFxyXG4gIHB1YlN1YiA9IG5ldyBQdWJTdWIoKVxyXG4pIHtcclxuICB0cnkge1xyXG4gICAgLy8gU2V0dXAgdGhlIFVSTFxyXG4gICAgbGV0IHVybCA9IGJ1aWxkVXJsKHJvdXRlLCBjb25maWd1cmF0aW9uKTtcclxuXHJcbiAgICAvLyBTZXR1cCB0aGUgcGFyYW1ldGVyc1xyXG4gICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnMocG9pbnRlclRva2VuKSxcclxuICAgICAgYm9keTogcGFyc2VCb2R5KF9kYXRhLCBjb25maWcsIGVuY3J5cHRpb24pXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFwiV2FpdFwiIGZvciByZXNwb25zZVxyXG4gICAgbGV0IHsgcmVzcG9uc2UsIGRhdGEgfSA9IGF3YWl0IGhhbmRsZVJlcXVlc3QodXJsLCBwYXJhbXMpO1xyXG5cclxuICAgIC8vIGhhbmRsZSB0aGUgcmVzcG9uc2VcclxuICAgIHJldHVybiBoYW5kbGVSZXNwb25zZShcclxuICAgICAgcmVzcG9uc2UsXHJcbiAgICAgIGRhdGEsXHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgcG9pbnRlclRva2VuLFxyXG4gICAgICBlbmNyeXB0aW9uLFxyXG4gICAgICB2YWxpZGF0b3IsXHJcbiAgICAgIHN0b3JhZ2UsXHJcbiAgICAgIHB1YlN1YlxyXG4gICAgKTtcclxuICB9IGNhdGNoIChleCkge1xyXG4gICAgLy8gSGFuZGxlIHRoZSBleGNlcHRpb25cclxuICAgIHRocm93IGhhbmRsZUZhaWwoZXgsIHJlc3BvbnNlLCBlbmNyeXB0aW9uKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCByZXF1ZXN0UG9zdDtcclxuIiwiaW1wb3J0IHJlcXVlc3RHZXQgZnJvbSAnLi4vaGVscGVycy9odHRwL3JlcXVlc3QtZ2V0JztcclxuaW1wb3J0IHJlcXVlc3RQb3N0IGZyb20gJy4uL2hlbHBlcnMvaHR0cC9yZXF1ZXN0LXBvc3QnO1xyXG5pbXBvcnQgdXBkYXRlVG9rZW4gZnJvbSAnLi4vaGVscGVycy9odHRwL3VwZGF0ZS10b2tlbic7XHJcblxyXG5pbXBvcnQgKiBhcyBjb25maWdPYmplY3QgZnJvbSAnLi4vaGVscGVycy9jb25maWctb2JqZWN0cy9odHRwLXJlcXVlc3QnO1xyXG5pbXBvcnQgU2VydmljZSBmcm9tICcuJztcclxuXHJcbmltcG9ydCBDb25maWd1cmF0aW9uIGZyb20gJy4vY29uZmlndXJhdGlvbic7XHJcbmltcG9ydCBFbmNyeXB0aW9uIGZyb20gJy4vZW5jcnlwdGlvbic7XHJcbmltcG9ydCBSZXNwb25zZSBmcm9tICcuL3Jlc3BvbnNlJztcclxuaW1wb3J0IFZhbGlkYXRvciBmcm9tICcuL3ZhbGlkYXRvcic7XHJcbmltcG9ydCBTdG9yYWdlIGZyb20gJy4vc3RvcmFnZSc7XHJcbmltcG9ydCBQdWJTdWIgZnJvbSAnLi9wdWItc3ViJztcclxuXHJcbi8vIERlY29yYXRvdG9yc1xyXG5cclxuLyoqXHJcbiAqIEh0dHAgSGFuZGxlcjpcclxuICogQnVpbGRzIHVybFxyXG4gKiBBZGRzIGFuZCB1cGRhdGVzIHgtYWNjZXNzLXRva2VuXHJcbiAqIEFkZHMgaGVhZGVycyB0byBhbGwgcmVxdWVzdHNcclxuICogRW5jcnlwdCBhbmQgc3RyaW5naWZ5IHBheWxvYWRcclxuICogRGVjcnlwdCBQYXlsb2FkXHJcbiAqIE1pZGRsZXdhcmVzOlxyXG4gKiAgVXBkYXRlIGtleSBhbmQgdG9rZW5cclxuICogIEhhbmRsZSBodHRwIGZhaWwgNTAwXHJcbiAqICBIYW5kbGUgaHR0cCBmYWlsIDQwMyBhbmQgNDAxXHJcbiAqICBJcyBpc250YW5jaWF0ZWRcclxuICogUHViU3ViIEV2ZW50czpcclxuICpcclxuICogQHB1YmxpYyBwb3N0IC0gc2VuZHMgcG9zdCByZXF1ZXN0XHJcbiAqIEBwdWJsaWMgZ2V0IC0gc2VuZHMgZ2V0IHJlcXVlc3RcclxuICogQHB1YmxpYyB1cGRhdGVUb2tlbiAtIHVwZGF0ZXMgeC1hY2Nlc3MtdG9rZW5cclxuICogQHB1YmxpYyBzZXR1cCAtIHJ1bnMgb25jZSBhbmQgZGVmaW5lcyBlbnZpcm9ubWVudFxyXG4gKi9cclxuXHJcbmNvbnN0IHByaXZhdGVTY29wZSA9IHtcclxuICB0b2tlbjogJydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEh0dHAgZXh0ZW5kcyBTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKENvbmZpZ3VyYXRpb24sIEVuY3J5cHRpb24pLCBSZXNwb25zZSwgU3RvcmFnZSwgUHViU3ViLCBWYWxpZGF0b3I7XHJcbiAgfVxyXG5cclxuICAvLyBHRVQgUkVRVUVTVFxyXG4gIGdldChyb3V0ZSA9ICcnLCBjb25maWcgPSBjb25maWdPYmplY3QpIHtcclxuICAgIHJldHVybiByZXF1ZXN0R2V0KFxyXG4gICAgICByb3V0ZSxcclxuICAgICAgY29uZmlnLFxyXG4gICAgICBwcml2YXRlU2NvcGUsXHJcbiAgICAgIHRoaXMuQ29uZmlndXJhdGlvbixcclxuICAgICAgdGhpcy5FbmNyeXB0aW9uLFxyXG4gICAgICB0aGlzLlJlc3BvbnNlLFxyXG4gICAgICB0aGlzLlZhbGlkYXRvcixcclxuICAgICAgdGhpcy5TdG9yYWdlLFxyXG4gICAgICB0aGlzLlB1YlN1YlxyXG4gICAgKTtcclxuICB9XHJcbiAgLy8gUE9TVCBSRVFVRVNUXHJcbiAgcG9zdChyb3V0ZSA9ICcnLCBwYXJhbXMgPSB7fSwgY29uZmlnID0gY29uZmlnT2JqZWN0KSB7XHJcbiAgICByZXR1cm4gcmVxdWVzdFBvc3QoXHJcbiAgICAgIHJvdXRlLFxyXG4gICAgICBwYXJhbXMsXHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgcHJpdmF0ZVNjb3BlLFxyXG4gICAgICB0aGlzLkNvbmZpZ3VyYXRpb24sXHJcbiAgICAgIHRoaXMuRW5jcnlwdGlvbixcclxuICAgICAgdGhpcy5SZXNwb25zZSxcclxuICAgICAgdGhpcy5WYWxpZGF0b3IsXHJcbiAgICAgIHRoaXMuU3RvcmFnZSxcclxuICAgICAgdGhpcy5QdWJTdWJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBVUERBVEUgWC1BQ0NFU1MtVE9LRU5cclxuICB1cGRhdGVUb2tlbihuZXdUb2tlbiA9ICcnKSB7XHJcbiAgICByZXR1cm4gdXBkYXRlVG9rZW4obmV3VG9rZW4sIHByaXZhdGVTY29wZSwgdGhpcy5TdG9yYWdlKTtcclxuICB9XHJcbn1cclxuIiwiXHJcbmltcG9ydCBIdHRwIGZyb20gXCJCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2h0dHBcIjtcclxuXHJcbmNvbnN0IGdldE1vZHVsZXMgPSBmdW5jdGlvbihodHRwID0gbmV3IEh0dHAoKSkge1xyXG4gIHJldHVybiBodHRwLmdldChcImFtX21vZHVsZXNcIik7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRNb2R1bGVzO1xyXG4iLCIvKipcclxuICogU3RhZ2UgTWFuYWdlciwgc3RvcmVzIGFwcGxpY2F0aW9uIHN0YXRlc1xyXG4gKiBAcHVibGljIGdldFxyXG4gKiBAcHVibGljIHNldFxyXG4gKiBAcHVibGljIGxpc3RcclxuICogQHB1YmxpYyBkZWxldGVcclxuICovXHJcbmltcG9ydCBTZXJ2aWNlIGZyb20gXCIuXCI7XHJcblxyXG5sZXQgc3RhdGVzID0ge307XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZSBleHRlbmRzIFNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICB9XHJcblxyXG4gIHNldChuYW1lLCBkYXRhKSB7XHJcbiAgICByZXR1cm4gKHN0YXRlc1tuYW1lXSA9IGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgZ2V0KG5hbWUpIHtcclxuICAgIHJldHVybiBzdGF0ZXNbbmFtZV07XHJcbiAgfVxyXG5cclxuICBsaXN0KCkge1xyXG4gICAgcmV0dXJuIHN0YXRlcztcclxuICB9XHJcblxyXG4gIGRlbGV0ZShuYW1lKSB7XHJcbiAgICBzdGF0ZXNbbmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBjbGVhcigpIHtcclxuICAgIHN0YXRlcyA9IHt9O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9hcHAtY29uc3RhbnRzXCI7XHJcbmltcG9ydCBIdHRwIGZyb20gXCJCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2h0dHBcIjtcclxuaW1wb3J0IFN0YXRlIGZyb20gXCJCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL3N0YXRlXCI7XHJcblxyXG5jb25zdCBnZXRNb2R1bGUgPSBmdW5jdGlvbihpZCwgaHR0cCA9IG5ldyBIdHRwKCksIHN0YXRlID0gbmV3IFN0YXRlKCkpIHtcclxuICByZXR1cm4gaHR0cC5nZXQoXHJcbiAgICBgYW1fbW9kdWxlcy8ke2lkIHx8IHN0YXRlLmdldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfTU9EVUxFKX1gXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldE1vZHVsZTtcclxuIiwiY29uc3QgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjQnKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHV1aWQ7XHJcbiIsImltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gJy4uL2FwcC1jb25zdGFudHMnO1xyXG5cclxuaW1wb3J0IFN0YXRlIGZyb20gJy4uL3NlcnZpY2VzL3N0YXRlJztcclxuaW1wb3J0IHV1aWQgZnJvbSAnLi91dWlkJztcclxuXHJcbmNvbnN0IGdldENoYXRCb3RVc2VySWQgPSBmdW5jdGlvbihzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgY29uc3QgdXNlcklkID0gc3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19VU0VSKS5pZDtcclxuICBsZXQgY2xpZW50VXNlcklkID0gc3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19DTElFTlRfVVNFUl9JRCk7XHJcblxyXG4gIGlmICghdXNlcklkKSB7XHJcbiAgICB0aHJvdyAnVG8gZ2V0IGEgY2hhdGJvdCB1c2VyLCB5b3UgbmVlZCBhIHZhbGlkIHVzZXIgd2l0aCBpZCc7XHJcbiAgfVxyXG5cclxuICBpZiAoIWNsaWVudFVzZXJJZCkge1xyXG4gICAgY2xpZW50VXNlcklkID0gdXVpZCgpO1xyXG4gICAgc3RhdGUuc2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19DTElFTlRfVVNFUl9JRCwgY2xpZW50VXNlcklkKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBgY2JfJHt1c2VySWR9LSR7Y2xpZW50VXNlcklkfWA7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRDaGF0Qm90VXNlcklkO1xyXG4iLCJpbXBvcnQgSHR0cCBmcm9tICdCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2h0dHAnO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9zdGF0ZSc7XHJcbmltcG9ydCBnZXRDaGF0Qm90VXNlcklkIGZyb20gJ0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9nZXQtY2hhdGJvdC11c2VyLWlkJztcclxuXHJcbmNvbnN0IGdldENoYXRib3RVc2VyID0gZnVuY3Rpb24oaWQsIGh0dHAgPSBuZXcgSHR0cCgpLCBzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgcmV0dXJuIGh0dHAuZ2V0KGBhbV9jbGllbnRfdXNlcnM/Y2xpZW50X3VzZXJfaWQ9JHtnZXRDaGF0Qm90VXNlcklkKHN0YXRlKX1gKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldENoYXRib3RVc2VyO1xyXG4iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIi4uL3NlcnZpY2VzL3N0YXRlXCI7XHJcbmltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gXCIuLi9hcHAtY29uc3RhbnRzXCI7XHJcbmltcG9ydCBnZXRDaGF0Qm90VXNlciBmcm9tIFwiLi9nZXQtY2hhdGJvdC11c2VyLWlkXCI7XHJcbmltcG9ydCBpc09iamVjdCBmcm9tIFwibG9kYXNoLmlzb2JqZWN0XCI7XHJcblxyXG5jb25zdCBfYnVpbGRQYXlsb2FkID0gZnVuY3Rpb24oaW5wdXQsIGNvbmZpZyA9IHt9LCBzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgIGF1dGg6IHtcclxuICAgICAgY2hhbm5lbF90b2tlbjogc3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkNIQU5ORUxfVE9LRU4pLFxyXG4gICAgICBjbGllbnRfdXNlcl9pZDogZ2V0Q2hhdEJvdFVzZXIoc3RhdGUpLFxyXG4gICAgICBzdGFnZTpcclxuICAgICAgICBBUFBfQ09OU1RBTlRTLkVOVklST05NRU5UX0lEU1tcclxuICAgICAgICAgIHN0YXRlLmdldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5FTlZJUk9OTUVOVClcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgY29udGV4dF92YXJpYWJsZXM6IHtcclxuICAgICAgZXh0cmFjdGVkX2VudGl0aWVzOiBbXSxcclxuICAgICAgYWN0aW9uczoge1xyXG4gICAgICAgIGNsb3NlX3Nlc3Npb246IHtcclxuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgaW5wdXRcclxuICB9O1xyXG5cclxuICBpZiAoY29uZmlnLmxvZ291dCkge1xyXG4gICAgcGF5bG9hZC5jb250ZXh0X3ZhcmlhYmxlcy5hY3Rpb25zLmNsb3NlX3Nlc3Npb24uZW5hYmxlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcGF5bG9hZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgb2JqZWN0IHdpdGggb25seSB0aGUgZGF0YSByZXF1aXJlZCBmb3IgdGhlIG1vZGVsXHJcbiAqIEBwYXJhbSB7T2JqZWN0fE1vZGVsfSBtb2RlbFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG4gKiBAcmV0dXJuIHtPYmplY3R8TW9kZWx9XHJcbiAqL1xyXG5jb25zdCBzZXRPcmNoZXN0cmF0b3JQYXlsb2FkID0ge1xyXG4gIHYzOiB7XHJcbiAgICB0ZXh0OiBmdW5jdGlvbih0ZXh0LCBzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgICAgIHJldHVybiBfYnVpbGRQYXlsb2FkKHsgdGV4dDogdGV4dCB9LCB7fSwgc3RhdGUpO1xyXG4gICAgfSxcclxuICAgIHZvaWNlOiBmdW5jdGlvbih2b2ljZSwgc3RhdGUgPSBuZXcgU3RhdGUoKSkge1xyXG4gICAgICByZXR1cm4gX2J1aWxkUGF5bG9hZCh7IHZvaWNlOiB2b2ljZSB9LCB7fSwgc3RhdGUpO1xyXG4gICAgfSxcclxuICAgIHBvc3RCYWNrOiBmdW5jdGlvbihwb3N0YmFjaywgc3RhdGUgPSBuZXcgU3RhdGUoKSkge1xyXG4gICAgICBpZiAoIWlzT2JqZWN0KHBvc3RiYWNrKSlcclxuICAgICAgICBwb3N0YmFjayA9IHtcclxuICAgICAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgICAgICBsYWJlbDogbnVsbCxcclxuICAgICAgICAgIHR5cGU6IG51bGwsXHJcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgIGFyZ1R5cGU6IG51bGxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgcG9zdGJhY2sudHlwZSA9IHBvc3RiYWNrLmFyZ1R5cGU7XHJcbiAgICAgIGRlbGV0ZSBwb3N0YmFjay5hcmdUeXBlO1xyXG5cclxuICAgICAgcmV0dXJuIF9idWlsZFBheWxvYWQoeyBwb3N0YmFjazogcG9zdGJhY2sgfSwge30sIHN0YXRlKTtcclxuICAgIH0sXHJcbiAgICBsb2dvdXQ6IGZ1bmN0aW9uKHN0YXRlID0gbmV3IFN0YXRlKCkpIHtcclxuICAgICAgcmV0dXJuIF9idWlsZFBheWxvYWQoe30sIHsgbG9nb3V0OiB0cnVlIH0sIHN0YXRlKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzZXRPcmNoZXN0cmF0b3JQYXlsb2FkO1xyXG4iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvc3RhdGVcIjtcclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5cclxuaW1wb3J0IHNldE9yY2hlc3RyYXRvclBheWxvYWQgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9zZXQtb3JjaGVzdHJhdG9yLXBheWxvYWRcIjtcclxuXHJcbmNvbnN0IHNlbmRMb2dvdXQgPSBmdW5jdGlvbih0ZXh0LCBodHRwID0gbmV3IEh0dHAoKSwgc3RhdGUgPSBuZXcgU3RhdGUoKSkge1xyXG4gIHJldHVybiBodHRwLnBvc3QoXCJvcmNoZXN0cmF0b3JfdjNcIiwgc2V0T3JjaGVzdHJhdG9yUGF5bG9hZC52My5sb2dvdXQoc3RhdGUpKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNlbmRMb2dvdXQ7XHJcbiIsImNvbnN0IEkxOE4gPSB7XHJcbiAgRVJST1I6IHtcclxuICAgIE1PRFVMRV9OT1RfRk9VTkQ6IFwiVGhlIGZvbGxvd2luZyBtb2R1bGUgd2FuJ3QgZm91bmRcIixcclxuICAgIFNFU1NJT05fQ1JFQVRFX1dJVEhPVVRfTE9HSU5fT1JfSU5JVDpcclxuICAgICAgXCJUbyBjcmVhdGUgYSBzZXNzaW9uIHlvdSBuZWVkIGEgbG9hZGVkIG1vZHVsZSBhbmQgdXNlciwgcGxlYXNlIHJ1biBsb2dpbiBhbmQgaW5pdC5cIixcclxuICAgIEdFVF9PUl9DUkVBVEVfU0VTU0lPTjogXCJFcnJvciBhdCBnZXRPckNyZWF0ZVNlc3Npb24oKVwiLFxyXG4gICAgTE9HSU5fRkFJTDogXCJMb2dpbiBGYWlsZWRcIixcclxuICAgIEVOQ1JZUFRJT05fTk9UX0lOSVRJQUxJWkVEOiBcIkVuY3J5cHRpb24gbm90IGluaXRpYWxpemVkXCIsXHJcbiAgICBJTlZBTElEX0NPR05VU19SRVNQT05TRV9PQkpFQ1Q6XHJcbiAgICAgIFwiVG8gZGVjcnlwdCBhIHBheWxvYWQgeW91IG11c3Qgc2VuZCBhIHZhbGlkIENvZ251c1Jlc3BvbnNlT2JqZWN0XCIsXHJcbiAgICBGQUlMRURfVE9fREVDUllQVDogXCJGYWlsZWQgdG8gZGVjcnlwdFwiLFxyXG4gICAgSFRUUF9SRVFVRVNUX0ZBSUw6IFwiSHR0cCByZXF1ZXN0IGZhaWxlZFwiXHJcbiAgfSxcclxuICBXQVJOOiB7XHJcbiAgICBBTFJFQURZX0lOU1RBTkNJQVRFRDogXCJBbHJlYWR5IGluc3RhbmNpYXRlZFwiLFxyXG4gICAgTk9fSUZSQU1FX0VMRU1FTlRfRk9VTkQ6IFwiQ2FuJ3Qgc2VuZCBwb3N0YmFjayBldmVudHMgaWYgbm8gZWxlbWVudCBpcyBmb3VuZFwiXHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgIEkxOE47XHJcbiIsImltcG9ydCBFbmNyeXB0aW9uIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9lbmNyeXB0aW9uXCI7XHJcbmltcG9ydCBIdHRwIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9odHRwXCI7XHJcbmltcG9ydCBTdGF0ZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvc3RhdGVcIjtcclxuaW1wb3J0IFN0b3JhZ2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3N0b3JhZ2VcIjtcclxuaW1wb3J0IFJlc3BvbnNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9yZXNwb25zZVwiO1xyXG5pbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tIFwiLi4vLi4vYXBwLWNvbnN0YW50c1wiO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY3JlZGVudGlhbHNcclxuICogQHBhcmFtICB7U3RyaW5nW2tleSwgdG9rZW4sIHVzZXJdfSBjcmVkZW50aWFsc1xyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKi9cclxuXHJcbmNvbnN0IHNldENyZWRlbnRpYWxzID0gZnVuY3Rpb24oXHJcbiAgY3JlZGVudGlhbHMsXHJcbiAgaHR0cCA9IG5ldyBIdHRwKCksXHJcbiAgZW5jcnlwdGlvbiA9IG5ldyBFbmNyeXB0aW9uKCksXHJcbiAgc3RhdGUgPSBuZXcgU3RhdGUoKSxcclxuICBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKSxcclxuICByZXNwb25zZSA9IG5ldyBSZXNwb25zZSgpXHJcbikge1xyXG4gIGNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHMuZGF0YSB8fCBjcmVkZW50aWFscztcclxuXHJcbiAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFscy50b2tlbjtcclxuICBjb25zdCBrZXkgPSBjcmVkZW50aWFscy5rZXk7XHJcbiAgY29uc3QgdXNlciA9IGNyZWRlbnRpYWxzLnVzZXIgfHwge307XHJcblxyXG4gIGVuY3J5cHRpb24udXBkYXRlS2V5KGtleSk7XHJcbiAgaHR0cC51cGRhdGVUb2tlbih0b2tlbik7XHJcblxyXG4gIHN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfVVNFUiwgdXNlcik7XHJcbiAgc3RhdGUuc2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19UT0tFTiwgdG9rZW4pO1xyXG4gIHN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfS0VZLCBrZXkpO1xyXG5cclxuICBzdG9yYWdlLnNldChBUFBfQ09OU1RBTlRTLlNUT1JBR0UuVVNFUiwgdXNlcik7XHJcblxyXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoXHJcbiAgICByZXNwb25zZS5vayh7XHJcbiAgICAgIHRva2VuLFxyXG4gICAgICBrZXksXHJcbiAgICAgIHVzZXJcclxuICAgIH0pXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNldENyZWRlbnRpYWxzO1xyXG4iLCJpbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tIFwiLi4vLi4vYXBwLWNvbnN0YW50c1wiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3N0YXRlXCI7XHJcblxyXG4vKipcclxuICogU2VsZiBleHBsYW5hdG9yeVxyXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IFtkZXNjcmlwdGlvbl1cclxuICovXHJcbmNvbnN0IHNldExvZ2dlZEluU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgc3RhdGUuc2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLklTX0xPR0dFRF9JTiwgdHJ1ZSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzZXRMb2dnZWRJblN0YXRlO1xyXG4iLCIvLyBpZiAoIWdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xyXG4vLyAgIHJlcXVpcmUoJ2JhYmVsLXBvbHlmaWxsJyk7XHJcbi8vIH1cclxuXHJcbmltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gJy4uLy4uL2FwcC1jb25zdGFudHMnO1xyXG5cclxuaW1wb3J0IHNldENyZWRlbnRpYWxzIGZyb20gJy4vc2V0LWNyZWRlbnRpYWxzJztcclxuaW1wb3J0IHNldExvZ2dlZEluU3RhdGUgZnJvbSAnLi9zZXQtbG9nZ2VkLWluLXN0YXRlJztcclxuaW1wb3J0IFB1YlN1YiBmcm9tICcuLi8uLi9zZXJ2aWNlcy9wdWItc3ViJztcclxuaW1wb3J0IEh0dHAgZnJvbSAnLi4vLi4vc2VydmljZXMvaHR0cCc7XHJcbmltcG9ydCBFbmNyeXB0aW9uIGZyb20gJy4uLy4uL3NlcnZpY2VzL2VuY3J5cHRpb24nO1xyXG5pbXBvcnQgUmVzcG9uc2UgZnJvbSAnLi4vLi4vc2VydmljZXMvcmVzcG9uc2UnO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSAnLi4vLi4vc2VydmljZXMvc3RhdGUnO1xyXG5pbXBvcnQgU3RvcmFnZSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9zdG9yYWdlJztcclxuXHJcbi8qKlxyXG4gKiBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSAge1N0cmluZ1tlbWFpbCwgcGFzc3dvcmRdfSBsb2dpblBhcmFtcyBbZGVzY3JpcHRpb25dXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICovXHJcblxyXG5jb25zdCBhcGlMb2dpbiA9IGFzeW5jIGZ1bmN0aW9uKFxyXG4gIGxvZ2luUGFyYW1zLFxyXG4gIGh0dHAgPSBuZXcgSHR0cCgpLFxyXG4gIGVuY3J5cHRpb24gPSBuZXcgRW5jcnlwdGlvbigpLFxyXG4gIHB1YlN1YiA9IG5ldyBQdWJTdWIoKSxcclxuICByZXNwb25zZSA9IG5ldyBSZXNwb25zZSgpLFxyXG4gIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpLFxyXG4gIHN0YXRlID0gbmV3IFN0YXRlKClcclxuKSB7XHJcbiAgdHJ5IHtcclxuICAgIGxldCBsb2dpbkRhdGE7XHJcblxyXG4gICAgY29uc3QgZW1haWwgPSBsb2dpblBhcmFtc1swXTtcclxuICAgIGNvbnN0IHBhc3N3b3JkID0gbG9naW5QYXJhbXNbMV07XHJcblxyXG4gICAgLy8gR2V0IGxvZ2luIGRhdGEgZnJvbSBzZXJ2ZXIgYW5kIGRlY3J5cHQgdGhlIHBheWxvYWRcclxuICAgIGxvZ2luRGF0YSA9IGF3YWl0IGh0dHAucG9zdChcclxuICAgICAgJ2xldG1laW4nLFxyXG4gICAgICB7XHJcbiAgICAgICAgZW1haWwsXHJcbiAgICAgICAgcGFzc3dvcmQ6IGVuY3J5cHRpb24uZW5jcnlwdFN0cmluZyhwYXNzd29yZClcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHNraXBFbmNyeXB0aW9uOiB0cnVlLFxyXG4gICAgICAgIGxvZ2luRGVjcnlwdGlvbjogcGFzc3dvcmQsXHJcbiAgICAgICAgZ2V0RnVsbFJlc3BvbnNlOiB0cnVlXHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLy9AVE9ETzogQ0hFQ0sgVEhJUyBCVUcgLSB0aGlzIHNob3VsZCBkZSBzdGFyZGFyZGl6ZWQgZm9yIGRldmVsb3BtZW50IGFuZCBwcm9kdWN0aW9uXHJcbiAgICBsb2dpbkRhdGEgPSBsb2dpbkRhdGEuZGF0YSB8fCBsb2dpbkRhdGE7XHJcbiAgICAvLyBTZXQgdGhlbSBjcmVkZW50aWFsc1xyXG4gICAgYXdhaXQgc2V0Q3JlZGVudGlhbHMobG9naW5EYXRhLCBodHRwLCBlbmNyeXB0aW9uLCBzdGF0ZSwgc3RvcmFnZSwgcmVzcG9uc2UpO1xyXG4gICAgLy8gVXBkYXRlIHN0YXRlIGZvciBtaWRkbGV3YXJlXHJcblxyXG4gICAgc2V0TG9nZ2VkSW5TdGF0ZShzdGF0ZSk7XHJcblxyXG4gICAgcHViU3ViLmVtaXQoQVBQX0NPTlNUQU5UUy5FVkVOVFMuTE9HR0VEX0lOKTtcclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2Uub2soe1xyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgaWQ6IGxvZ2luRGF0YS51c2VyLmlkLFxyXG4gICAgICAgIGtleTogbG9naW5EYXRhLmtleSxcclxuICAgICAgICB0b2tlbjogbG9naW5EYXRhLnRva2VuXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICBwdWJTdWIuZW1pdChBUFBfQ09OU1RBTlRTLkVWRU5UUy5MT0dJTl9GQUlMKTtcclxuICAgIHRocm93IHJlc3BvbnNlLmVycm9yKHtcclxuICAgICAgZGF0YTogZXgsXHJcbiAgICAgIG1lc3NhZ2U6ICdFUlJPUi5MT0dJTl9GQUlMJ1xyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXBpTG9naW47XHJcbiIsIi8vY29uc3QgcmVnZXggPSAoPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKTtcclxuXHJcbmNvbnN0IHJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XHJcbmNvbnN0IGlzRW1haWwgPSBmdW5jdGlvbihlbWFpbCkge1xyXG4gIHJldHVybiByZWdleC50ZXN0KGVtYWlsKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlzRW1haWw7XHJcbiIsImltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gXCIuLi8uLi9hcHAtY29uc3RhbnRzXCI7XHJcblxyXG5pbXBvcnQgaXNFbWFpbCBmcm9tIFwiLi4vcmVnZXgvaXMtZW1haWxcIjtcclxuaW1wb3J0IFN0YXRlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9zdGF0ZVwiO1xyXG5cclxuY29uc3QgY2hlY2tMb2dpblR5cGUgPSBmdW5jdGlvbihmaXJzdEFyZ3VtZW50LCBzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgbGV0IGxvZ2luVHlwZSA9IEFQUF9DT05TVEFOVFMuTE9HSU5fVFlQRVNbMV07XHJcblxyXG4gIGlmIChmaXJzdEFyZ3VtZW50ID09PSBcImNvZ251c1wiIHx8IGlzRW1haWwoZmlyc3RBcmd1bWVudCkpIHtcclxuICAgIGxvZ2luVHlwZSA9IEFQUF9DT05TVEFOVFMuTE9HSU5fVFlQRVNbMF07XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5zZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuTE9HSU5fTUVUSE9ELCBsb2dpblR5cGUpO1xyXG5cclxuICByZXR1cm4gbG9naW5UeXBlO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2hlY2tMb2dpblR5cGU7XHJcbiIsImltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gXCIuLi8uLi9hcHAtY29uc3RhbnRzXCI7XHJcblxyXG5pbXBvcnQgYXBpTG9naW4gZnJvbSBcIi4vYXBpLWxvZ2luXCI7XHJcbmltcG9ydCBzZXRDcmVkZW50aWFscyBmcm9tIFwiLi9zZXQtY3JlZGVudGlhbHNcIjtcclxuaW1wb3J0IGNoZWNrTG9naW5UeXBlIGZyb20gXCIuL2NoZWNrLWxvZ2luLXR5cGVcIjtcclxuXHJcbmltcG9ydCBTdGF0ZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvc3RhdGVcIjtcclxuaW1wb3J0IFB1YlN1YiBmcm9tIFwiLi4vLi4vc2VydmljZXMvcHViLXN1YlwiO1xyXG5pbXBvcnQgSHR0cCBmcm9tIFwiLi4vLi4vc2VydmljZXMvaHR0cFwiO1xyXG5pbXBvcnQgRW5jcnlwdGlvbiBmcm9tIFwiLi4vLi4vc2VydmljZXMvZW5jcnlwdGlvblwiO1xyXG5pbXBvcnQgUmVzcG9uc2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3Jlc3BvbnNlXCI7XHJcbmltcG9ydCBTdG9yYWdlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9zdG9yYWdlXCI7XHJcblxyXG4vKipcclxuICogRGVmaW5lcyB3aGF0IGtpbmQgb2YgbG9naW4gc2hvdWxkIGJlIHVzZWQgY2FsbHMgaXRcclxuICogQHBhcmFtICB7U3RyaW5nW119IGxvZ2luRGF0YSBbZGVzY3JpcHRpb25dXHJcbiAqIEByZXR1cm4ge1tQcm9taXNlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICovXHJcblxyXG5jb25zdCBsb2dpbiA9IGZ1bmN0aW9uKFxyXG4gIGxvZ2luRGF0YSxcclxuICBzdGF0ZSA9IG5ldyBTdGF0ZSgpLFxyXG4gIGh0dHAgPSBuZXcgSHR0cCgpLFxyXG4gIGVuY3J5cHRpb24gPSBuZXcgRW5jcnlwdGlvbigpLFxyXG4gIHB1YlN1YiA9IG5ldyBQdWJTdWIoKSxcclxuICByZXNwb25zZSA9IG5ldyBSZXNwb25zZSgpLFxyXG4gIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpXHJcbikge1xyXG4gIC8vIExvZ2luIHR5cGVcclxuICBjb25zdCBsb2dpblR5cGUgPSBjaGVja0xvZ2luVHlwZShsb2dpbkRhdGFbMF0sIHN0YXRlKTtcclxuICAvLyBUcmFjayBzdGF0ZSBmb3IgdW5pdCB0ZXN0aW5nIGFuZCBkZWJ1Z1xyXG4gIHN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5MT0dJTl9NRVRIT0QsIGxvZ2luVHlwZSk7XHJcbiAgLy8gUmV0dXJuIHByb21pc2VzXHJcblxyXG4gIGlmIChsb2dpblR5cGUgPT09IEFQUF9DT05TVEFOVFMuTE9HSU5fVFlQRVNbMF0pIHtcclxuICAgIHJldHVybiBhcGlMb2dpbihcclxuICAgICAgbG9naW5EYXRhLFxyXG4gICAgICBodHRwLFxyXG4gICAgICBlbmNyeXB0aW9uLFxyXG4gICAgICBwdWJTdWIsXHJcbiAgICAgIHJlc3BvbnNlLFxyXG4gICAgICBzdG9yYWdlLFxyXG4gICAgICBzdGF0ZVxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIHNldENyZWRlbnRpYWxzKGxvZ2luRGF0YSwgaHR0cCwgZW5jcnlwdGlvbiwgc3RhdGUsIHN0b3JhZ2UsIHJlc3BvbnNlKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGxvZ2luO1xyXG4iLCJ2YXIgQk9UUyA9IFtcclxuICBcIlxcXFwraHR0cHM6XFxcXC9cXFxcL2RldmVsb3BlcnMuZ29vZ2xlLmNvbVxcXFwvXFxcXCtcXFxcL3dlYlxcXFwvc25pcHBldFxcXFwvXCIsXHJcbiAgXCJnb29nbGVib3RcIixcclxuICBcImJhaWR1c3BpZGVyXCIsXHJcbiAgXCJndXJ1amlib3RcIixcclxuICBcInlhbmRleGJvdFwiLFxyXG4gIFwic2x1cnBcIixcclxuICBcIm1zbmJvdFwiLFxyXG4gIFwiYmluZ2JvdFwiLFxyXG4gIFwiZmFjZWJvb2tleHRlcm5hbGhpdFwiLFxyXG4gIFwibGlua2VkaW5ib3RcIixcclxuICBcInR3aXR0ZXJib3RcIixcclxuICBcInNsYWNrYm90XCIsXHJcbiAgXCJ0ZWxlZ3JhbWJvdFwiLFxyXG4gIFwiYXBwbGVib3RcIixcclxuICBcInBpbmdkb21cIixcclxuICBcInR1bWJsciBcIixcclxuICBcIkVtYmVkbHlcIixcclxuICBcInNwYm90XCJcclxuXTtcclxudmFyIElTX0JPVF9SRUdFWFAgPSBuZXcgUmVnRXhwKFwiXi4qKFwiICsgQk9UUy5qb2luKFwifFwiKSArIFwiKS4qJFwiKTtcclxuXHJcbnZhciBNQUNISU5FX1VVSURfS0VZID0gJ2JsdWVkYXJ3aW4tY2hhdGJvdF9fbWFjaGluZV91dWlkJztcclxuXHJcbnZhciB1dWlkdjQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XHJcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XHJcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciB0aW1lU3RhbXAgPSBmdW5jdGlvbigpe1xyXG4gICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKClcclxufVxyXG5cclxudmFyIERldmljZVVVSUQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XHJcbiAgdmFyIGRlZk9wdGlvbnMgPSB7XHJcbiAgICB2ZXJzaW9uOiBmYWxzZSxcclxuICAgIGxhbmd1YWdlOiBmYWxzZSxcclxuICAgIHBsYXRmb3JtOiB0cnVlLFxyXG4gICAgb3M6IHRydWUsXHJcbiAgICBwaXhlbERlcHRoOiB0cnVlLFxyXG4gICAgY29sb3JEZXB0aDogdHJ1ZSxcclxuICAgIHJlc29sdXRpb246IGZhbHNlLFxyXG4gICAgaXNBdXRob3JpdGF0aXZlOiB0cnVlLFxyXG4gICAgc2lsa0FjY2VsZXJhdGVkOiB0cnVlLFxyXG4gICAgaXNLaW5kbGVGaXJlOiB0cnVlLFxyXG4gICAgaXNEZXNrdG9wOiB0cnVlLFxyXG4gICAgaXNNb2JpbGU6IHRydWUsXHJcbiAgICBpc1RhYmxldDogdHJ1ZSxcclxuICAgIGlzV2luZG93czogdHJ1ZSxcclxuICAgIGlzTGludXg6IHRydWUsXHJcbiAgICBpc0xpbnV4NjQ6IHRydWUsXHJcbiAgICBpc0Nocm9tZU9TOiB0cnVlLFxyXG4gICAgaXNNYWM6IHRydWUsXHJcbiAgICBpc2lQYWQ6IHRydWUsXHJcbiAgICBpc2lQaG9uZTogdHJ1ZSxcclxuICAgIGlzaVBvZDogdHJ1ZSxcclxuICAgIGlzQW5kcm9pZDogdHJ1ZSxcclxuICAgIGlzU2Ftc3VuZzogdHJ1ZSxcclxuICAgIGlzU21hcnRUVjogdHJ1ZSxcclxuICAgIGlzUmFzcGJlcnJ5OiB0cnVlLFxyXG4gICAgaXNCbGFja2JlcnJ5OiB0cnVlLFxyXG4gICAgaXNUb3VjaFNjcmVlbjogdHJ1ZSxcclxuICAgIGlzT3BlcmE6IGZhbHNlLFxyXG4gICAgaXNJRTogZmFsc2UsXHJcbiAgICBpc0VkZ2U6IGZhbHNlLFxyXG4gICAgaXNJRUNvbXBhdGliaWxpdHlNb2RlOiBmYWxzZSxcclxuICAgIGlzU2FmYXJpOiBmYWxzZSxcclxuICAgIGlzRmlyZWZveDogZmFsc2UsXHJcbiAgICBpc1dlYmtpdDogZmFsc2UsXHJcbiAgICBpc0Nocm9tZTogZmFsc2UsXHJcbiAgICBpc0tvbnF1ZXJvcjogZmFsc2UsXHJcbiAgICBpc09tbmlXZWI6IGZhbHNlLFxyXG4gICAgaXNTZWFNb25rZXk6IGZhbHNlLFxyXG4gICAgaXNGbG9jazogZmFsc2UsXHJcbiAgICBpc0FtYXlhOiBmYWxzZSxcclxuICAgIGlzUGhhbnRvbUpTOiBmYWxzZSxcclxuICAgIGlzRXBpcGhhbnk6IGZhbHNlLFxyXG4gICAgc291cmNlOiBmYWxzZSxcclxuICAgIGNwdUNvcmVzOiBmYWxzZVxyXG4gIH07XHJcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIGRlZk9wdGlvbnNba2V5XSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICBkZWZPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMub3B0aW9ucyA9IGRlZk9wdGlvbnM7XHJcbiAgdGhpcy52ZXJzaW9uID0gXCIxLjAuMFwiO1xyXG4gIHRoaXMuX1ZlcnNpb25zID0ge1xyXG4gICAgRWRnZTogL0VkZ2VcXC8oW1xcZFxcd1xcLlxcLV0rKS9pLFxyXG4gICAgRmlyZWZveDogL2ZpcmVmb3hcXC8oW1xcZFxcd1xcLlxcLV0rKS9pLFxyXG4gICAgSUU6IC9tc2llXFxzKFtcXGRcXC5dK1tcXGRdKXx0cmlkZW50XFwvXFxkK1xcLlxcZCs7LipbcnY6XSsoXFxkK1xcLlxcZCkvaSxcclxuICAgIENocm9tZTogL2Nocm9tZVxcLyhbXFxkXFx3XFwuXFwtXSspL2ksXHJcbiAgICBDaHJvbWl1bTogLyg/OmNocm9taXVtfGNyaW9zKVxcLyhbXFxkXFx3XFwuXFwtXSspL2ksXHJcbiAgICBTYWZhcmk6IC92ZXJzaW9uXFwvKFtcXGRcXHdcXC5cXC1dKykvaSxcclxuICAgIE9wZXJhOiAvdmVyc2lvblxcLyhbXFxkXFx3XFwuXFwtXSspfE9QUlxcLyhbXFxkXFx3XFwuXFwtXSspL2ksXHJcbiAgICBQczM6IC8oW1xcZFxcd1xcLlxcLV0rKVxcKVxccyokL2ksXHJcbiAgICBQc3A6IC8oW1xcZFxcd1xcLlxcLV0rKVxcKT9cXHMqJC9pLFxyXG4gICAgQW1heWE6IC9hbWF5YVxcLyhbXFxkXFx3XFwuXFwtXSspL2ksXHJcbiAgICBTZWFNb25rZXk6IC9zZWFtb25rZXlcXC8oW1xcZFxcd1xcLlxcLV0rKS9pLFxyXG4gICAgT21uaVdlYjogL29tbml3ZWJcXC92KFtcXGRcXHdcXC5cXC1dKykvaSxcclxuICAgIEZsb2NrOiAvZmxvY2tcXC8oW1xcZFxcd1xcLlxcLV0rKS9pLFxyXG4gICAgRXBpcGhhbnk6IC9lcGlwaGFueVxcLyhbXFxkXFx3XFwuXFwtXSspL2ksXHJcbiAgICBXaW5KczogL21zYXBwaG9zdFxcLyhbXFxkXFx3XFwuXFwtXSspL2ksXHJcbiAgICBQaGFudG9tSlM6IC9waGFudG9tanNcXC8oW1xcZFxcd1xcLlxcLV0rKS9pLFxyXG4gICAgVUM6IC9VQ0Jyb3dzZXJcXC8oW1xcZFxcd1xcLl0rKS9pXHJcbiAgfTtcclxuICB0aGlzLl9Ccm93c2VycyA9IHtcclxuICAgIEVkZ2U6IC9lZGdlL2ksXHJcbiAgICBBbWF5YTogL2FtYXlhL2ksXHJcbiAgICBLb25xdWVyb3I6IC9rb25xdWVyb3IvaSxcclxuICAgIEVwaXBoYW55OiAvZXBpcGhhbnkvaSxcclxuICAgIFNlYU1vbmtleTogL3NlYW1vbmtleS9pLFxyXG4gICAgRmxvY2s6IC9mbG9jay9pLFxyXG4gICAgT21uaVdlYjogL29tbml3ZWIvaSxcclxuICAgIENocm9taXVtOiAvY2hyb21pdW18Y3Jpb3MvaSxcclxuICAgIENocm9tZTogL2Nocm9tZS9pLFxyXG4gICAgU2FmYXJpOiAvc2FmYXJpL2ksXHJcbiAgICBJRTogL21zaWV8dHJpZGVudC9pLFxyXG4gICAgT3BlcmE6IC9vcGVyYXxPUFIvaSxcclxuICAgIFBTMzogL3BsYXlzdGF0aW9uIDMvaSxcclxuICAgIFBTUDogL3BsYXlzdGF0aW9uIHBvcnRhYmxlL2ksXHJcbiAgICBGaXJlZm94OiAvZmlyZWZveC9pLFxyXG4gICAgV2luSnM6IC9tc2FwcGhvc3QvaSxcclxuICAgIFBoYW50b21KUzogL3BoYW50b21qcy9pLFxyXG4gICAgVUM6IC9VQ0Jyb3dzZXIvaVxyXG4gIH07XHJcbiAgdGhpcy5fT1MgPSB7XHJcbiAgICBXaW5kb3dzMTA6IC93aW5kb3dzIG50IDEwXFwuMC9pLFxyXG4gICAgV2luZG93czgxOiAvd2luZG93cyBudCA2XFwuMy9pLFxyXG4gICAgV2luZG93czg6IC93aW5kb3dzIG50IDZcXC4yL2ksXHJcbiAgICBXaW5kb3dzNzogL3dpbmRvd3MgbnQgNlxcLjEvaSxcclxuICAgIFVua25vd25XaW5kb3dzOiAvd2luZG93cyBudCA2XFwuXFxkKy9pLFxyXG4gICAgV2luZG93c1Zpc3RhOiAvd2luZG93cyBudCA2XFwuMC9pLFxyXG4gICAgV2luZG93czIwMDM6IC93aW5kb3dzIG50IDVcXC4yL2ksXHJcbiAgICBXaW5kb3dzWFA6IC93aW5kb3dzIG50IDVcXC4xL2ksXHJcbiAgICBXaW5kb3dzMjAwMDogL3dpbmRvd3MgbnQgNVxcLjAvaSxcclxuICAgIFdpbmRvd3NQaG9uZTg6IC93aW5kb3dzIHBob25lIDhcXC4vLFxyXG4gICAgT1NYQ2hlZXRhaDogL29zIHggMTBbLl9dMC9pLFxyXG4gICAgT1NYUHVtYTogL29zIHggMTBbLl9dMShcXER8JCkvaSxcclxuICAgIE9TWEphZ3VhcjogL29zIHggMTBbLl9dMi9pLFxyXG4gICAgT1NYUGFudGhlcjogL29zIHggMTBbLl9dMy9pLFxyXG4gICAgT1NYVGlnZXI6IC9vcyB4IDEwWy5fXTQvaSxcclxuICAgIE9TWExlb3BhcmQ6IC9vcyB4IDEwWy5fXTUvaSxcclxuICAgIE9TWFNub3dMZW9wYXJkOiAvb3MgeCAxMFsuX102L2ksXHJcbiAgICBPU1hMaW9uOiAvb3MgeCAxMFsuX103L2ksXHJcbiAgICBPU1hNb3VudGFpbkxpb246IC9vcyB4IDEwWy5fXTgvaSxcclxuICAgIE9TWE1hdmVyaWNrczogL29zIHggMTBbLl9dOS9pLFxyXG4gICAgT1NYWW9zZW1pdGU6IC9vcyB4IDEwWy5fXTEwL2ksXHJcbiAgICBPU1hFbENhcGl0YW46IC9vcyB4IDEwWy5fXTExL2ksXHJcbiAgICBPU1hTaWVycmE6IC9vcyB4IDEwWy5fXTEyL2ksXHJcbiAgICBNYWM6IC9vcyB4L2ksXHJcbiAgICBMaW51eDogL2xpbnV4L2ksXHJcbiAgICBMaW51eDY0OiAvbGludXggeDg2XzY0L2ksXHJcbiAgICBDaHJvbWVPUzogL2Nyb3MvaSxcclxuICAgIFdpaTogL3dpaS9pLFxyXG4gICAgUFMzOiAvcGxheXN0YXRpb24gMy9pLFxyXG4gICAgUFNQOiAvcGxheXN0YXRpb24gcG9ydGFibGUvaSxcclxuICAgIGlQYWQ6IC9cXChpUGFkLipvcyAoXFxkKylbLl9dKFxcZCspL2ksXHJcbiAgICBpUGhvbmU6IC9cXChpUGhvbmUuKm9zIChcXGQrKVsuX10oXFxkKykvaSxcclxuICAgIEJhZGE6IC9CYWRhXFwvKFxcZCspXFwuKFxcZCspL2ksXHJcbiAgICBDdXJsOiAvY3VybFxcLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKS9pXHJcbiAgfTtcclxuICB0aGlzLl9QbGF0Zm9ybSA9IHtcclxuICAgIFdpbmRvd3M6IC93aW5kb3dzIG50L2ksXHJcbiAgICBXaW5kb3dzUGhvbmU6IC93aW5kb3dzIHBob25lL2ksXHJcbiAgICBNYWM6IC9tYWNpbnRvc2gvaSxcclxuICAgIExpbnV4OiAvbGludXgvaSxcclxuICAgIFdpaTogL3dpaS9pLFxyXG4gICAgUGxheXN0YXRpb246IC9wbGF5c3RhdGlvbi9pLFxyXG4gICAgaVBhZDogL2lwYWQvaSxcclxuICAgIGlQb2Q6IC9pcG9kL2ksXHJcbiAgICBpUGhvbmU6IC9pcGhvbmUvaSxcclxuICAgIEFuZHJvaWQ6IC9hbmRyb2lkL2ksXHJcbiAgICBCbGFja2JlcnJ5OiAvYmxhY2tiZXJyeS9pLFxyXG4gICAgU2Ftc3VuZzogL3NhbXN1bmcvaSxcclxuICAgIEN1cmw6IC9jdXJsL2lcclxuICB9O1xyXG5cclxuICB0aGlzLkRlZmF1bHRBZ2VudCA9IHtcclxuICAgIGlzQXV0aG9yaXRhdGl2ZTogdHJ1ZSxcclxuICAgIGlzTW9iaWxlOiBmYWxzZSxcclxuICAgIGlzVGFibGV0OiBmYWxzZSxcclxuICAgIGlzaVBhZDogZmFsc2UsXHJcbiAgICBpc2lQb2Q6IGZhbHNlLFxyXG4gICAgaXNpUGhvbmU6IGZhbHNlLFxyXG4gICAgaXNBbmRyb2lkOiBmYWxzZSxcclxuICAgIGlzQmxhY2tiZXJyeTogZmFsc2UsXHJcbiAgICBpc09wZXJhOiBmYWxzZSxcclxuICAgIGlzSUU6IGZhbHNlLFxyXG4gICAgaXNFZGdlOiBmYWxzZSxcclxuICAgIGlzSUVDb21wYXRpYmlsaXR5TW9kZTogZmFsc2UsXHJcbiAgICBpc1NhZmFyaTogZmFsc2UsXHJcbiAgICBpc0ZpcmVmb3g6IGZhbHNlLFxyXG4gICAgaXNXZWJraXQ6IGZhbHNlLFxyXG4gICAgaXNDaHJvbWU6IGZhbHNlLFxyXG4gICAgaXNLb25xdWVyb3I6IGZhbHNlLFxyXG4gICAgaXNPbW5pV2ViOiBmYWxzZSxcclxuICAgIGlzU2VhTW9ua2V5OiBmYWxzZSxcclxuICAgIGlzRmxvY2s6IGZhbHNlLFxyXG4gICAgaXNBbWF5YTogZmFsc2UsXHJcbiAgICBpc1BoYW50b21KUzogZmFsc2UsXHJcbiAgICBpc0VwaXBoYW55OiBmYWxzZSxcclxuICAgIGlzRGVza3RvcDogZmFsc2UsXHJcbiAgICBpc1dpbmRvd3M6IGZhbHNlLFxyXG4gICAgaXNMaW51eDogZmFsc2UsXHJcbiAgICBpc0xpbnV4NjQ6IGZhbHNlLFxyXG4gICAgaXNNYWM6IGZhbHNlLFxyXG4gICAgaXNDaHJvbWVPUzogZmFsc2UsXHJcbiAgICBpc0JhZGE6IGZhbHNlLFxyXG4gICAgaXNTYW1zdW5nOiBmYWxzZSxcclxuICAgIGlzUmFzcGJlcnJ5OiBmYWxzZSxcclxuICAgIGlzQm90OiBmYWxzZSxcclxuICAgIGlzQ3VybDogZmFsc2UsXHJcbiAgICBpc0FuZHJvaWRUYWJsZXQ6IGZhbHNlLFxyXG4gICAgaXNXaW5KczogZmFsc2UsXHJcbiAgICBpc0tpbmRsZUZpcmU6IGZhbHNlLFxyXG4gICAgaXNTaWxrOiBmYWxzZSxcclxuICAgIGlzQ2FwdGl2ZTogZmFsc2UsXHJcbiAgICBpc1NtYXJ0VFY6IGZhbHNlLFxyXG4gICAgaXNVQzogZmFsc2UsXHJcbiAgICBpc1RvdWNoU2NyZWVuOiBmYWxzZSxcclxuICAgIHNpbGtBY2NlbGVyYXRlZDogZmFsc2UsXHJcbiAgICBjb2xvckRlcHRoOiAtMSxcclxuICAgIHBpeGVsRGVwdGg6IC0xLFxyXG4gICAgcmVzb2x1dGlvbjogW10sXHJcbiAgICBjcHVDb3JlczogLTEsXHJcbiAgICBsYW5ndWFnZTogXCJ1bmtub3duXCIsXHJcbiAgICBicm93c2VyOiBcInVua25vd25cIixcclxuICAgIHZlcnNpb246IFwidW5rbm93blwiLFxyXG4gICAgb3M6IFwidW5rbm93blwiLFxyXG4gICAgcGxhdGZvcm06IFwidW5rbm93blwiLFxyXG4gICAgZ2VvSXA6IHt9LFxyXG4gICAgc291cmNlOiBcIlwiLFxyXG4gICAgaGFzaEludDogZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAgIHZhciBoYXNoID0gMCxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGNocixcclxuICAgICAgICBsZW47XHJcbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY2hyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjtcclxuICAgICAgICBoYXNoIHw9IDA7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9LFxyXG4gICAgaGFzaE1ENTogZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAgIGZ1bmN0aW9uIHJvdGF0ZUxlZnQobFZhbHVlLCBpU2hpZnRCaXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIChsVmFsdWUgPDwgaVNoaWZ0Qml0cykgfCAobFZhbHVlID4+PiAoMzIgLSBpU2hpZnRCaXRzKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGFkZFVuc2lnbmVkKGxYLCBsWSkge1xyXG4gICAgICAgIHZhciBsWDQsIGxZNCwgbFg4LCBsWTgsIGxSZXN1bHQ7XHJcbiAgICAgICAgbFg4ID0gbFggJiAweDgwMDAwMDAwO1xyXG4gICAgICAgIGxZOCA9IGxZICYgMHg4MDAwMDAwMDtcclxuICAgICAgICBsWDQgPSBsWCAmIDB4NDAwMDAwMDA7XHJcbiAgICAgICAgbFk0ID0gbFkgJiAweDQwMDAwMDAwO1xyXG4gICAgICAgIGxSZXN1bHQgPSAobFggJiAweDNmZmZmZmZmKSArIChsWSAmIDB4M2ZmZmZmZmYpO1xyXG5cclxuICAgICAgICBpZiAobFg0ICYgbFk0KSB7XHJcbiAgICAgICAgICByZXR1cm4gbFJlc3VsdCBeIDB4ODAwMDAwMDAgXiBsWDggXiBsWTg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsWDQgfCBsWTQpIHtcclxuICAgICAgICAgIGlmIChsUmVzdWx0ICYgMHg0MDAwMDAwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbFJlc3VsdCBeIDB4YzAwMDAwMDAgXiBsWDggXiBsWTg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbFJlc3VsdCBeIDB4NDAwMDAwMDAgXiBsWDggXiBsWTg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBsUmVzdWx0IF4gbFg4IF4gbFk4O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZ0YoeCwgeSwgeikge1xyXG4gICAgICAgIHJldHVybiAoeCAmIHkpIHwgKH54ICYgeik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdHKHgsIHksIHopIHtcclxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBnSCh4LCB5LCB6KSB7XHJcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZ0koeCwgeSwgeikge1xyXG4gICAgICAgIHJldHVybiB5IF4gKHggfCB+eik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdGRihhLCBiLCBjLCBkLCB4LCBzLCBhYykge1xyXG4gICAgICAgIGEgPSBhZGRVbnNpZ25lZChhLCBhZGRVbnNpZ25lZChhZGRVbnNpZ25lZChnRihiLCBjLCBkKSwgeCksIGFjKSk7XHJcbiAgICAgICAgcmV0dXJuIGFkZFVuc2lnbmVkKHJvdGF0ZUxlZnQoYSwgcyksIGIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBnR0coYSwgYiwgYywgZCwgeCwgcywgYWMpIHtcclxuICAgICAgICBhID0gYWRkVW5zaWduZWQoYSwgYWRkVW5zaWduZWQoYWRkVW5zaWduZWQoZ0coYiwgYywgZCksIHgpLCBhYykpO1xyXG4gICAgICAgIHJldHVybiBhZGRVbnNpZ25lZChyb3RhdGVMZWZ0KGEsIHMpLCBiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZ0hIKGEsIGIsIGMsIGQsIHgsIHMsIGFjKSB7XHJcbiAgICAgICAgYSA9IGFkZFVuc2lnbmVkKGEsIGFkZFVuc2lnbmVkKGFkZFVuc2lnbmVkKGdIKGIsIGMsIGQpLCB4KSwgYWMpKTtcclxuICAgICAgICByZXR1cm4gYWRkVW5zaWduZWQocm90YXRlTGVmdChhLCBzKSwgYik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdJSShhLCBiLCBjLCBkLCB4LCBzLCBhYykge1xyXG4gICAgICAgIGEgPSBhZGRVbnNpZ25lZChhLCBhZGRVbnNpZ25lZChhZGRVbnNpZ25lZChnSShiLCBjLCBkKSwgeCksIGFjKSk7XHJcbiAgICAgICAgcmV0dXJuIGFkZFVuc2lnbmVkKHJvdGF0ZUxlZnQoYSwgcyksIGIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb252ZXJ0VG9Xb3JkQXJyYXkoc3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGxXb3JkQ291bnQ7XHJcbiAgICAgICAgdmFyIGxNZXNzYWdlTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcclxuICAgICAgICB2YXIgbE51bWJlck9mV29yZHNUZW1wMSA9IGxNZXNzYWdlTGVuZ3RoICsgODtcclxuICAgICAgICB2YXIgbE51bWJlck9mV29yZHNUZW1wMiA9XHJcbiAgICAgICAgICAobE51bWJlck9mV29yZHNUZW1wMSAtIChsTnVtYmVyT2ZXb3Jkc1RlbXAxICUgNjQpKSAvIDY0O1xyXG4gICAgICAgIHZhciBsTnVtYmVyT2ZXb3JkcyA9IChsTnVtYmVyT2ZXb3Jkc1RlbXAyICsgMSkgKiAxNjtcclxuICAgICAgICB2YXIgbFdvcmRBcnJheSA9IG5ldyBBcnJheShsTnVtYmVyT2ZXb3JkcyAtIDEpO1xyXG4gICAgICAgIHZhciBsQnl0ZVBvc2l0aW9uID0gMDtcclxuICAgICAgICB2YXIgbEJ5dGVDb3VudCA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChsQnl0ZUNvdW50IDwgbE1lc3NhZ2VMZW5ndGgpIHtcclxuICAgICAgICAgIGxXb3JkQ291bnQgPSAobEJ5dGVDb3VudCAtIChsQnl0ZUNvdW50ICUgNCkpIC8gNDtcclxuICAgICAgICAgIGxCeXRlUG9zaXRpb24gPSAobEJ5dGVDb3VudCAlIDQpICogODtcclxuICAgICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gPVxyXG4gICAgICAgICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdIHxcclxuICAgICAgICAgICAgKHN0cmluZy5jaGFyQ29kZUF0KGxCeXRlQ291bnQpIDw8IGxCeXRlUG9zaXRpb24pO1xyXG4gICAgICAgICAgbEJ5dGVDb3VudCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbFdvcmRDb3VudCA9IChsQnl0ZUNvdW50IC0gKGxCeXRlQ291bnQgJSA0KSkgLyA0O1xyXG4gICAgICAgIGxCeXRlUG9zaXRpb24gPSAobEJ5dGVDb3VudCAlIDQpICogODtcclxuICAgICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdID1cclxuICAgICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfCAoMHg4MCA8PCBsQnl0ZVBvc2l0aW9uKTtcclxuICAgICAgICBsV29yZEFycmF5W2xOdW1iZXJPZldvcmRzIC0gMl0gPSBsTWVzc2FnZUxlbmd0aCA8PCAzO1xyXG4gICAgICAgIGxXb3JkQXJyYXlbbE51bWJlck9mV29yZHMgLSAxXSA9IGxNZXNzYWdlTGVuZ3RoID4+PiAyOTtcclxuICAgICAgICByZXR1cm4gbFdvcmRBcnJheTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gd29yZFRvSGV4KGxWYWx1ZSkge1xyXG4gICAgICAgIHZhciB3b3JkVG9IZXhWYWx1ZSA9IFwiXCIsXHJcbiAgICAgICAgICB3b3JkVG9IZXhWYWx1ZVRlbXAgPSBcIlwiLFxyXG4gICAgICAgICAgbEJ5dGUsXHJcbiAgICAgICAgICBsQ291bnQ7XHJcbiAgICAgICAgZm9yIChsQ291bnQgPSAwOyBsQ291bnQgPD0gMzsgbENvdW50KyspIHtcclxuICAgICAgICAgIGxCeXRlID0gKGxWYWx1ZSA+Pj4gKGxDb3VudCAqIDgpKSAmIDI1NTtcclxuICAgICAgICAgIHdvcmRUb0hleFZhbHVlVGVtcCA9IFwiMFwiICsgbEJ5dGUudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgd29yZFRvSGV4VmFsdWUgPVxyXG4gICAgICAgICAgICB3b3JkVG9IZXhWYWx1ZSArXHJcbiAgICAgICAgICAgIHdvcmRUb0hleFZhbHVlVGVtcC5zdWJzdHIod29yZFRvSGV4VmFsdWVUZW1wLmxlbmd0aCAtIDIsIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd29yZFRvSGV4VmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHV0ZjhFbmNvZGUoc3RyaW5nKSB7XHJcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKTtcclxuICAgICAgICB2YXIgdXRmdGV4dCA9IFwiXCI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgc3RyaW5nLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xyXG4gICAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjID4gMTI3ICYmIGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiA2KSB8IDE5Mik7XHJcbiAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDYzKSB8IDEyOCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gMTIpIHwgMjI0KTtcclxuICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyA+PiA2KSAmIDYzKSB8IDEyOCk7XHJcbiAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDYzKSB8IDEyOCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1dGZ0ZXh0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeCA9IFtdO1xyXG4gICAgICB2YXIgaywgQUEsIEJCLCBDQywgREQsIGEsIGIsIGMsIGQ7XHJcbiAgICAgIHZhciBTMTEgPSA3LFxyXG4gICAgICAgIFMxMiA9IDEyLFxyXG4gICAgICAgIFMxMyA9IDE3LFxyXG4gICAgICAgIFMxNCA9IDIyO1xyXG4gICAgICB2YXIgUzIxID0gNSxcclxuICAgICAgICBTMjIgPSA5LFxyXG4gICAgICAgIFMyMyA9IDE0LFxyXG4gICAgICAgIFMyNCA9IDIwO1xyXG4gICAgICB2YXIgUzMxID0gNCxcclxuICAgICAgICBTMzIgPSAxMSxcclxuICAgICAgICBTMzMgPSAxNixcclxuICAgICAgICBTMzQgPSAyMztcclxuICAgICAgdmFyIFM0MSA9IDYsXHJcbiAgICAgICAgUzQyID0gMTAsXHJcbiAgICAgICAgUzQzID0gMTUsXHJcbiAgICAgICAgUzQ0ID0gMjE7XHJcbiAgICAgIHN0cmluZyA9IHV0ZjhFbmNvZGUoc3RyaW5nKTtcclxuICAgICAgeCA9IGNvbnZlcnRUb1dvcmRBcnJheShzdHJpbmcpO1xyXG4gICAgICBhID0gMHg2NzQ1MjMwMTtcclxuICAgICAgYiA9IDB4ZWZjZGFiODk7XHJcbiAgICAgIGMgPSAweDk4YmFkY2ZlO1xyXG4gICAgICBkID0gMHgxMDMyNTQ3NjtcclxuXHJcbiAgICAgIGZvciAoayA9IDA7IGsgPCB4Lmxlbmd0aDsgayArPSAxNikge1xyXG4gICAgICAgIEFBID0gYTtcclxuICAgICAgICBCQiA9IGI7XHJcbiAgICAgICAgQ0MgPSBjO1xyXG4gICAgICAgIEREID0gZDtcclxuICAgICAgICBhID0gZ0ZGKGEsIGIsIGMsIGQsIHhbayArIDBdLCBTMTEsIDB4ZDc2YWE0NzgpO1xyXG4gICAgICAgIGQgPSBnRkYoZCwgYSwgYiwgYywgeFtrICsgMV0sIFMxMiwgMHhlOGM3Yjc1Nik7XHJcbiAgICAgICAgYyA9IGdGRihjLCBkLCBhLCBiLCB4W2sgKyAyXSwgUzEzLCAweDI0MjA3MGRiKTtcclxuICAgICAgICBiID0gZ0ZGKGIsIGMsIGQsIGEsIHhbayArIDNdLCBTMTQsIDB4YzFiZGNlZWUpO1xyXG4gICAgICAgIGEgPSBnRkYoYSwgYiwgYywgZCwgeFtrICsgNF0sIFMxMSwgMHhmNTdjMGZhZik7XHJcbiAgICAgICAgZCA9IGdGRihkLCBhLCBiLCBjLCB4W2sgKyA1XSwgUzEyLCAweDQ3ODdjNjJhKTtcclxuICAgICAgICBjID0gZ0ZGKGMsIGQsIGEsIGIsIHhbayArIDZdLCBTMTMsIDB4YTgzMDQ2MTMpO1xyXG4gICAgICAgIGIgPSBnRkYoYiwgYywgZCwgYSwgeFtrICsgN10sIFMxNCwgMHhmZDQ2OTUwMSk7XHJcbiAgICAgICAgYSA9IGdGRihhLCBiLCBjLCBkLCB4W2sgKyA4XSwgUzExLCAweDY5ODA5OGQ4KTtcclxuICAgICAgICBkID0gZ0ZGKGQsIGEsIGIsIGMsIHhbayArIDldLCBTMTIsIDB4OGI0NGY3YWYpO1xyXG4gICAgICAgIGMgPSBnRkYoYywgZCwgYSwgYiwgeFtrICsgMTBdLCBTMTMsIDB4ZmZmZjViYjEpO1xyXG4gICAgICAgIGIgPSBnRkYoYiwgYywgZCwgYSwgeFtrICsgMTFdLCBTMTQsIDB4ODk1Y2Q3YmUpO1xyXG4gICAgICAgIGEgPSBnRkYoYSwgYiwgYywgZCwgeFtrICsgMTJdLCBTMTEsIDB4NmI5MDExMjIpO1xyXG4gICAgICAgIGQgPSBnRkYoZCwgYSwgYiwgYywgeFtrICsgMTNdLCBTMTIsIDB4ZmQ5ODcxOTMpO1xyXG4gICAgICAgIGMgPSBnRkYoYywgZCwgYSwgYiwgeFtrICsgMTRdLCBTMTMsIDB4YTY3OTQzOGUpO1xyXG4gICAgICAgIGIgPSBnRkYoYiwgYywgZCwgYSwgeFtrICsgMTVdLCBTMTQsIDB4NDliNDA4MjEpO1xyXG4gICAgICAgIGEgPSBnR0coYSwgYiwgYywgZCwgeFtrICsgMV0sIFMyMSwgMHhmNjFlMjU2Mik7XHJcbiAgICAgICAgZCA9IGdHRyhkLCBhLCBiLCBjLCB4W2sgKyA2XSwgUzIyLCAweGMwNDBiMzQwKTtcclxuICAgICAgICBjID0gZ0dHKGMsIGQsIGEsIGIsIHhbayArIDExXSwgUzIzLCAweDI2NWU1YTUxKTtcclxuICAgICAgICBiID0gZ0dHKGIsIGMsIGQsIGEsIHhbayArIDBdLCBTMjQsIDB4ZTliNmM3YWEpO1xyXG4gICAgICAgIGEgPSBnR0coYSwgYiwgYywgZCwgeFtrICsgNV0sIFMyMSwgMHhkNjJmMTA1ZCk7XHJcbiAgICAgICAgZCA9IGdHRyhkLCBhLCBiLCBjLCB4W2sgKyAxMF0sIFMyMiwgMHgyNDQxNDUzKTtcclxuICAgICAgICBjID0gZ0dHKGMsIGQsIGEsIGIsIHhbayArIDE1XSwgUzIzLCAweGQ4YTFlNjgxKTtcclxuICAgICAgICBiID0gZ0dHKGIsIGMsIGQsIGEsIHhbayArIDRdLCBTMjQsIDB4ZTdkM2ZiYzgpO1xyXG4gICAgICAgIGEgPSBnR0coYSwgYiwgYywgZCwgeFtrICsgOV0sIFMyMSwgMHgyMWUxY2RlNik7XHJcbiAgICAgICAgZCA9IGdHRyhkLCBhLCBiLCBjLCB4W2sgKyAxNF0sIFMyMiwgMHhjMzM3MDdkNik7XHJcbiAgICAgICAgYyA9IGdHRyhjLCBkLCBhLCBiLCB4W2sgKyAzXSwgUzIzLCAweGY0ZDUwZDg3KTtcclxuICAgICAgICBiID0gZ0dHKGIsIGMsIGQsIGEsIHhbayArIDhdLCBTMjQsIDB4NDU1YTE0ZWQpO1xyXG4gICAgICAgIGEgPSBnR0coYSwgYiwgYywgZCwgeFtrICsgMTNdLCBTMjEsIDB4YTllM2U5MDUpO1xyXG4gICAgICAgIGQgPSBnR0coZCwgYSwgYiwgYywgeFtrICsgMl0sIFMyMiwgMHhmY2VmYTNmOCk7XHJcbiAgICAgICAgYyA9IGdHRyhjLCBkLCBhLCBiLCB4W2sgKyA3XSwgUzIzLCAweDY3NmYwMmQ5KTtcclxuICAgICAgICBiID0gZ0dHKGIsIGMsIGQsIGEsIHhbayArIDEyXSwgUzI0LCAweDhkMmE0YzhhKTtcclxuICAgICAgICBhID0gZ0hIKGEsIGIsIGMsIGQsIHhbayArIDVdLCBTMzEsIDB4ZmZmYTM5NDIpO1xyXG4gICAgICAgIGQgPSBnSEgoZCwgYSwgYiwgYywgeFtrICsgOF0sIFMzMiwgMHg4NzcxZjY4MSk7XHJcbiAgICAgICAgYyA9IGdISChjLCBkLCBhLCBiLCB4W2sgKyAxMV0sIFMzMywgMHg2ZDlkNjEyMik7XHJcbiAgICAgICAgYiA9IGdISChiLCBjLCBkLCBhLCB4W2sgKyAxNF0sIFMzNCwgMHhmZGU1MzgwYyk7XHJcbiAgICAgICAgYSA9IGdISChhLCBiLCBjLCBkLCB4W2sgKyAxXSwgUzMxLCAweGE0YmVlYTQ0KTtcclxuICAgICAgICBkID0gZ0hIKGQsIGEsIGIsIGMsIHhbayArIDRdLCBTMzIsIDB4NGJkZWNmYTkpO1xyXG4gICAgICAgIGMgPSBnSEgoYywgZCwgYSwgYiwgeFtrICsgN10sIFMzMywgMHhmNmJiNGI2MCk7XHJcbiAgICAgICAgYiA9IGdISChiLCBjLCBkLCBhLCB4W2sgKyAxMF0sIFMzNCwgMHhiZWJmYmM3MCk7XHJcbiAgICAgICAgYSA9IGdISChhLCBiLCBjLCBkLCB4W2sgKyAxM10sIFMzMSwgMHgyODliN2VjNik7XHJcbiAgICAgICAgZCA9IGdISChkLCBhLCBiLCBjLCB4W2sgKyAwXSwgUzMyLCAweGVhYTEyN2ZhKTtcclxuICAgICAgICBjID0gZ0hIKGMsIGQsIGEsIGIsIHhbayArIDNdLCBTMzMsIDB4ZDRlZjMwODUpO1xyXG4gICAgICAgIGIgPSBnSEgoYiwgYywgZCwgYSwgeFtrICsgNl0sIFMzNCwgMHg0ODgxZDA1KTtcclxuICAgICAgICBhID0gZ0hIKGEsIGIsIGMsIGQsIHhbayArIDldLCBTMzEsIDB4ZDlkNGQwMzkpO1xyXG4gICAgICAgIGQgPSBnSEgoZCwgYSwgYiwgYywgeFtrICsgMTJdLCBTMzIsIDB4ZTZkYjk5ZTUpO1xyXG4gICAgICAgIGMgPSBnSEgoYywgZCwgYSwgYiwgeFtrICsgMTVdLCBTMzMsIDB4MWZhMjdjZjgpO1xyXG4gICAgICAgIGIgPSBnSEgoYiwgYywgZCwgYSwgeFtrICsgMl0sIFMzNCwgMHhjNGFjNTY2NSk7XHJcbiAgICAgICAgYSA9IGdJSShhLCBiLCBjLCBkLCB4W2sgKyAwXSwgUzQxLCAweGY0MjkyMjQ0KTtcclxuICAgICAgICBkID0gZ0lJKGQsIGEsIGIsIGMsIHhbayArIDddLCBTNDIsIDB4NDMyYWZmOTcpO1xyXG4gICAgICAgIGMgPSBnSUkoYywgZCwgYSwgYiwgeFtrICsgMTRdLCBTNDMsIDB4YWI5NDIzYTcpO1xyXG4gICAgICAgIGIgPSBnSUkoYiwgYywgZCwgYSwgeFtrICsgNV0sIFM0NCwgMHhmYzkzYTAzOSk7XHJcbiAgICAgICAgYSA9IGdJSShhLCBiLCBjLCBkLCB4W2sgKyAxMl0sIFM0MSwgMHg2NTViNTljMyk7XHJcbiAgICAgICAgZCA9IGdJSShkLCBhLCBiLCBjLCB4W2sgKyAzXSwgUzQyLCAweDhmMGNjYzkyKTtcclxuICAgICAgICBjID0gZ0lJKGMsIGQsIGEsIGIsIHhbayArIDEwXSwgUzQzLCAweGZmZWZmNDdkKTtcclxuICAgICAgICBiID0gZ0lJKGIsIGMsIGQsIGEsIHhbayArIDFdLCBTNDQsIDB4ODU4NDVkZDEpO1xyXG4gICAgICAgIGEgPSBnSUkoYSwgYiwgYywgZCwgeFtrICsgOF0sIFM0MSwgMHg2ZmE4N2U0Zik7XHJcbiAgICAgICAgZCA9IGdJSShkLCBhLCBiLCBjLCB4W2sgKyAxNV0sIFM0MiwgMHhmZTJjZTZlMCk7XHJcbiAgICAgICAgYyA9IGdJSShjLCBkLCBhLCBiLCB4W2sgKyA2XSwgUzQzLCAweGEzMDE0MzE0KTtcclxuICAgICAgICBiID0gZ0lJKGIsIGMsIGQsIGEsIHhbayArIDEzXSwgUzQ0LCAweDRlMDgxMWExKTtcclxuICAgICAgICBhID0gZ0lJKGEsIGIsIGMsIGQsIHhbayArIDRdLCBTNDEsIDB4Zjc1MzdlODIpO1xyXG4gICAgICAgIGQgPSBnSUkoZCwgYSwgYiwgYywgeFtrICsgMTFdLCBTNDIsIDB4YmQzYWYyMzUpO1xyXG4gICAgICAgIGMgPSBnSUkoYywgZCwgYSwgYiwgeFtrICsgMl0sIFM0MywgMHgyYWQ3ZDJiYik7XHJcbiAgICAgICAgYiA9IGdJSShiLCBjLCBkLCBhLCB4W2sgKyA5XSwgUzQ0LCAweGViODZkMzkxKTtcclxuICAgICAgICBhID0gYWRkVW5zaWduZWQoYSwgQUEpO1xyXG4gICAgICAgIGIgPSBhZGRVbnNpZ25lZChiLCBCQik7XHJcbiAgICAgICAgYyA9IGFkZFVuc2lnbmVkKGMsIENDKTtcclxuICAgICAgICBkID0gYWRkVW5zaWduZWQoZCwgREQpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0ZW1wID0gd29yZFRvSGV4KGEpICsgd29yZFRvSGV4KGIpICsgd29yZFRvSGV4KGMpICsgd29yZFRvSGV4KGQpO1xyXG4gICAgICByZXR1cm4gdGVtcC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMuQWdlbnQgPSB7fTtcclxuXHJcbiAgdGhpcy5nZXRCcm93c2VyID0gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgY2FzZSB0aGlzLl9Ccm93c2Vycy5FZGdlLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzRWRnZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiRWRnZVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX0Jyb3dzZXJzLlBoYW50b21KUy50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc1BoYW50b21KUyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiUGhhbnRvbUpTXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fQnJvd3NlcnMuS29ucXVlcm9yLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzS29ucXVlcm9yID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJLb25xdWVyb3JcIjtcclxuICAgICAgY2FzZSB0aGlzLl9Ccm93c2Vycy5BbWF5YS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc0FtYXlhID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJBbWF5YVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX0Jyb3dzZXJzLkVwaXBoYW55LnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzRXBpcGhhbnkgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIkVwaXBoYW55XCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fQnJvd3NlcnMuU2VhTW9ua2V5LnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzU2VhTW9ua2V5ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJTZWFNb25rZXlcIjtcclxuICAgICAgY2FzZSB0aGlzLl9Ccm93c2Vycy5GbG9jay50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc0Zsb2NrID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJGbG9ja1wiO1xyXG4gICAgICBjYXNlIHRoaXMuX0Jyb3dzZXJzLk9tbmlXZWIudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNPbW5pV2ViID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJPbW5pV2ViXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fQnJvd3NlcnMuT3BlcmEudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNPcGVyYSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiT3BlcmFcIjtcclxuICAgICAgY2FzZSB0aGlzLl9Ccm93c2Vycy5DaHJvbWl1bS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc0Nocm9tZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiQ2hyb21pdW1cIjtcclxuICAgICAgY2FzZSB0aGlzLl9Ccm93c2Vycy5DaHJvbWUudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNDaHJvbWUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIkNocm9tZVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX0Jyb3dzZXJzLlNhZmFyaS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc1NhZmFyaSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiU2FmYXJpXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fQnJvd3NlcnMuV2luSnMudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNXaW5KcyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiV2luSnNcIjtcclxuICAgICAgY2FzZSB0aGlzLl9Ccm93c2Vycy5JRS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc0lFID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJJRVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX0Jyb3dzZXJzLlBTMy50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgcmV0dXJuIFwicHMzXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fQnJvd3NlcnMuUFNQLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICByZXR1cm4gXCJwc3BcIjtcclxuICAgICAgY2FzZSB0aGlzLl9Ccm93c2Vycy5GaXJlZm94LnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzRmlyZWZveCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiRmlyZWZveFwiO1xyXG4gICAgICBjYXNlIHRoaXMuX0Jyb3dzZXJzLlVDLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzVUMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIlVDQnJvd3NlclwiO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vIElmIHRoZSBVQSBkb2VzIG5vdCBzdGFydCB3aXRoIE1vemlsbGEgZ3Vlc3MgdGhlIHVzZXIgYWdlbnQuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgc3RyaW5nLmluZGV4T2YoXCJNb3ppbGxhXCIpICE9PSAwICYmXHJcbiAgICAgICAgICAvXihbXFxkXFx3XFwtXFwuXSspXFwvW1xcZFxcd1xcLlxcLV0rL2kudGVzdChzdHJpbmcpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICB0aGlzLkFnZW50LmlzQXV0aG9yaXRhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMuZ2V0QnJvd3NlclZlcnNpb24gPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHZhciByZWdleDtcclxuICAgIHN3aXRjaCAodGhpcy5BZ2VudC5icm93c2VyKSB7XHJcbiAgICAgIGNhc2UgXCJFZGdlXCI6XHJcbiAgICAgICAgaWYgKHRoaXMuX1ZlcnNpb25zLkVkZ2UudGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIlBoYW50b21KU1wiOlxyXG4gICAgICAgIGlmICh0aGlzLl9WZXJzaW9ucy5QaGFudG9tSlMudGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIkNocm9tZVwiOlxyXG4gICAgICAgIGlmICh0aGlzLl9WZXJzaW9ucy5DaHJvbWUudGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIkNocm9taXVtXCI6XHJcbiAgICAgICAgaWYgKHRoaXMuX1ZlcnNpb25zLkNocm9taXVtLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJTYWZhcmlcIjpcclxuICAgICAgICBpZiAodGhpcy5fVmVyc2lvbnMuU2FmYXJpLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJPcGVyYVwiOlxyXG4gICAgICAgIGlmICh0aGlzLl9WZXJzaW9ucy5PcGVyYS50ZXN0KHN0cmluZykpIHtcclxuICAgICAgICAgIHJldHVybiBSZWdFeHAuJDEgPyBSZWdFeHAuJDEgOiBSZWdFeHAuJDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiRmlyZWZveFwiOlxyXG4gICAgICAgIGlmICh0aGlzLl9WZXJzaW9ucy5GaXJlZm94LnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJXaW5Kc1wiOlxyXG4gICAgICAgIGlmICh0aGlzLl9WZXJzaW9ucy5XaW5Kcy50ZXN0KHN0cmluZykpIHtcclxuICAgICAgICAgIHJldHVybiBSZWdFeHAuJDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiSUVcIjpcclxuICAgICAgICBpZiAodGhpcy5fVmVyc2lvbnMuSUUudGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVnRXhwLiQyID8gUmVnRXhwLiQyIDogUmVnRXhwLiQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInBzM1wiOlxyXG4gICAgICAgIGlmICh0aGlzLl9WZXJzaW9ucy5QczMudGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInBzcFwiOlxyXG4gICAgICAgIGlmICh0aGlzLl9WZXJzaW9ucy5Qc3AudGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIkFtYXlhXCI6XHJcbiAgICAgICAgaWYgKHRoaXMuX1ZlcnNpb25zLkFtYXlhLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJFcGlwaGFueVwiOlxyXG4gICAgICAgIGlmICh0aGlzLl9WZXJzaW9ucy5FcGlwaGFueS50ZXN0KHN0cmluZykpIHtcclxuICAgICAgICAgIHJldHVybiBSZWdFeHAuJDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiU2VhTW9ua2V5XCI6XHJcbiAgICAgICAgaWYgKHRoaXMuX1ZlcnNpb25zLlNlYU1vbmtleS50ZXN0KHN0cmluZykpIHtcclxuICAgICAgICAgIHJldHVybiBSZWdFeHAuJDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiRmxvY2tcIjpcclxuICAgICAgICBpZiAodGhpcy5fVmVyc2lvbnMuRmxvY2sudGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIk9tbmlXZWJcIjpcclxuICAgICAgICBpZiAodGhpcy5fVmVyc2lvbnMuT21uaVdlYi50ZXN0KHN0cmluZykpIHtcclxuICAgICAgICAgIHJldHVybiBSZWdFeHAuJDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiVUNCcm93c2VyXCI6XHJcbiAgICAgICAgaWYgKHRoaXMuX1ZlcnNpb25zLlVDLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgaWYgKHRoaXMuQWdlbnQuYnJvd3NlciAhPT0gXCJ1bmtub3duXCIpIHtcclxuICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgdGhpcy5BZ2VudC5icm93c2VyICsgXCJbXFxcXC8gXShbXFxcXGRcXFxcd1xcXFwuXFxcXC1dKylcIixcclxuICAgICAgICAgICAgXCJpXCJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBpZiAocmVnZXgudGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWdFeHAuJDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMuZ2V0T1MgPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIHRoaXMuX09TLldpbmRvd3NWaXN0YS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc1dpbmRvd3MgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIldpbmRvd3MgVmlzdGFcIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5XaW5kb3dzNy50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc1dpbmRvd3MgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIldpbmRvd3MgN1wiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLldpbmRvd3M4LnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzV2luZG93cyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiV2luZG93cyA4XCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuV2luZG93czgxLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzV2luZG93cyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiV2luZG93cyA4LjFcIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5XaW5kb3dzMTAudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNXaW5kb3dzID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJXaW5kb3dzIDEwLjBcIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5XaW5kb3dzMjAwMy50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc1dpbmRvd3MgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIldpbmRvd3MgMjAwM1wiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLldpbmRvd3NYUC50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc1dpbmRvd3MgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIldpbmRvd3MgWFBcIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5XaW5kb3dzMjAwMC50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc1dpbmRvd3MgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIldpbmRvd3MgMjAwMFwiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLldpbmRvd3NQaG9uZTgudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHJldHVybiBcIldpbmRvd3MgUGhvbmUgOFwiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLkxpbnV4NjQudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNMaW51eCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc0xpbnV4NjQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIkxpbnV4IDY0XCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuTGludXgudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNMaW51eCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiTGludXhcIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5DaHJvbWVPUy50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc0Nocm9tZU9TID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJDaHJvbWUgT1NcIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5XaWkudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHJldHVybiBcIldpaVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLlBTMy50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgcmV0dXJuIFwiUGxheXN0YXRpb25cIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5QU1AudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHJldHVybiBcIlBsYXlzdGF0aW9uXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuT1NYQ2hlZXRhaC50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc01hYyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiT1MgWCBDaGVldGFoXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuT1NYUHVtYS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc01hYyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiT1MgWCBQdW1hXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuT1NYSmFndWFyLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzTWFjID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJPUyBYIEphZ3VhclwiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLk9TWFBhbnRoZXIudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNNYWMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIk9TIFggUGFudGhlclwiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLk9TWFRpZ2VyLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzTWFjID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJPUyBYIFRpZ2VyXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuT1NYTGVvcGFyZC50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc01hYyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiT1MgWCBMZW9wYXJkXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuT1NYU25vd0xlb3BhcmQudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNNYWMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIk9TIFggU25vdyBMZW9wYXJkXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuT1NYTGlvbi50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc01hYyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiT1MgWCBMaW9uXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuT1NYTW91bnRhaW5MaW9uLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzTWFjID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJPUyBYIE1vdW50YWluIExpb25cIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5PU1hNYXZlcmlja3MudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNNYWMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIk9TIFggTWF2ZXJpY2tzXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuT1NYWW9zZW1pdGUudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNNYWMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIk9TIFggWW9zZW1pdGVcIjtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5PU1hFbENhcGl0YW4udGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNNYWMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIk9TIFggRWwgQ2FwaXRhblwiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLk9TWFNpZXJyYS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc01hYyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwibWFjT1MgU2llcnJhXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuTWFjLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzTWFjID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJPUyBYXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fT1MuaVBhZC50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc2lQYWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcubWF0Y2godGhpcy5fT1MuaVBhZClbMF0ucmVwbGFjZShcIl9cIiwgXCIuXCIpO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLmlQaG9uZS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc2lQaG9uZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaCh0aGlzLl9PUy5pUGhvbmUpWzBdLnJlcGxhY2UoXCJfXCIsIFwiLlwiKTtcclxuICAgICAgY2FzZSB0aGlzLl9PUy5CYWRhLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzQmFkYSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiQmFkYVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX09TLkN1cmwudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNDdXJsID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJDdXJsXCI7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMuZ2V0UGxhdGZvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIHRoaXMuX1BsYXRmb3JtLldpbmRvd3MudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHJldHVybiBcIk1pY3Jvc29mdCBXaW5kb3dzXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fUGxhdGZvcm0uV2luZG93c1Bob25lLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzV2luZG93c1Bob25lID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJNaWNyb3NvZnQgV2luZG93cyBQaG9uZVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX1BsYXRmb3JtLk1hYy50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgcmV0dXJuIFwiQXBwbGUgTWFjXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fUGxhdGZvcm0uQ3VybC50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgcmV0dXJuIFwiQ3VybFwiO1xyXG4gICAgICBjYXNlIHRoaXMuX1BsYXRmb3JtLkFuZHJvaWQudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNBbmRyb2lkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJBbmRyb2lkXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fUGxhdGZvcm0uQmxhY2tiZXJyeS50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc0JsYWNrYmVycnkgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIkJsYWNrYmVycnlcIjtcclxuICAgICAgY2FzZSB0aGlzLl9QbGF0Zm9ybS5MaW51eC50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgcmV0dXJuIFwiTGludXhcIjtcclxuICAgICAgY2FzZSB0aGlzLl9QbGF0Zm9ybS5XaWkudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHJldHVybiBcIldpaVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX1BsYXRmb3JtLlBsYXlzdGF0aW9uLnRlc3Qoc3RyaW5nKTpcclxuICAgICAgICByZXR1cm4gXCJQbGF5c3RhdGlvblwiO1xyXG4gICAgICBjYXNlIHRoaXMuX1BsYXRmb3JtLmlQYWQudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNpUGFkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJpUGFkXCI7XHJcbiAgICAgIGNhc2UgdGhpcy5fUGxhdGZvcm0uaVBvZC50ZXN0KHN0cmluZyk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc2lQb2QgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcImlQb2RcIjtcclxuICAgICAgY2FzZSB0aGlzLl9QbGF0Zm9ybS5pUGhvbmUudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNpUGhvbmUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcImlQaG9uZVwiO1xyXG4gICAgICBjYXNlIHRoaXMuX1BsYXRmb3JtLlNhbXN1bmcudGVzdChzdHJpbmcpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNpU2Ftc3VuZyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiU2Ftc3VuZ1wiO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBcInVua25vd25cIjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLnRlc3RDb21wYXRpYmlsaXR5TW9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHVhID0gdGhpcztcclxuICAgIGlmICh0aGlzLkFnZW50LmlzSUUpIHtcclxuICAgICAgaWYgKC9UcmlkZW50XFwvKFxcZClcXC4wL2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpKSB7XHJcbiAgICAgICAgdmFyIHRyaWRlbnRWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICAgICAgdmFyIHZlcnNpb24gPSBwYXJzZUludCh1YS5BZ2VudC52ZXJzaW9uLCAxMCk7XHJcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDcgJiYgdHJpZGVudFZlcnNpb24gPT09IDcpIHtcclxuICAgICAgICAgIHVhLkFnZW50LmlzSUVDb21wYXRpYmlsaXR5TW9kZSA9IHRydWU7XHJcbiAgICAgICAgICB1YS5BZ2VudC52ZXJzaW9uID0gMTEuMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2ZXJzaW9uID09PSA3ICYmIHRyaWRlbnRWZXJzaW9uID09PSA2KSB7XHJcbiAgICAgICAgICB1YS5BZ2VudC5pc0lFQ29tcGF0aWJpbGl0eU1vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgdWEuQWdlbnQudmVyc2lvbiA9IDEwLjA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gNyAmJiB0cmlkZW50VmVyc2lvbiA9PT0gNSkge1xyXG4gICAgICAgICAgdWEuQWdlbnQuaXNJRUNvbXBhdGliaWxpdHlNb2RlID0gdHJ1ZTtcclxuICAgICAgICAgIHVhLkFnZW50LnZlcnNpb24gPSA5LjA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gNyAmJiB0cmlkZW50VmVyc2lvbiA9PT0gNCkge1xyXG4gICAgICAgICAgdWEuQWdlbnQuaXNJRUNvbXBhdGliaWxpdHlNb2RlID0gdHJ1ZTtcclxuICAgICAgICAgIHVhLkFnZW50LnZlcnNpb24gPSA4LjA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGhpcy50ZXN0U2lsayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHVhID0gdGhpcztcclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIG5ldyBSZWdFeHAoXCJzaWxrXCIsIFwiZ2lcIikudGVzdCh1YS5BZ2VudC5zb3VyY2UpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNTaWxrID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgIH1cclxuXHJcbiAgICBpZiAoL1NpbGstQWNjZWxlcmF0ZWQ9dHJ1ZS9naS50ZXN0KHVhLkFnZW50LnNvdXJjZSkpIHtcclxuICAgICAgdGhpcy5BZ2VudC5TaWxrQWNjZWxlcmF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuQWdlbnQuaXNTaWxrID8gXCJTaWxrXCIgOiBmYWxzZTtcclxuICB9O1xyXG5cclxuICB0aGlzLnRlc3RLaW5kbGVGaXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdWEgPSB0aGlzO1xyXG4gICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgIGNhc2UgL0tGT1QvZ2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNLaW5kbGVGaXJlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJLaW5kbGUgRmlyZVwiO1xyXG4gICAgICBjYXNlIC9LRlRUL2dpLnRlc3QodWEuQWdlbnQuc291cmNlKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzS2luZGxlRmlyZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiS2luZGxlIEZpcmUgSERcIjtcclxuICAgICAgY2FzZSAvS0ZKV0kvZ2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNLaW5kbGVGaXJlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJLaW5kbGUgRmlyZSBIRCA4LjlcIjtcclxuICAgICAgY2FzZSAvS0ZKV0EvZ2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNLaW5kbGVGaXJlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJLaW5kbGUgRmlyZSBIRCA4LjkgNEdcIjtcclxuICAgICAgY2FzZSAvS0ZTT1dJL2dpLnRlc3QodWEuQWdlbnQuc291cmNlKTpcclxuICAgICAgICB0aGlzLkFnZW50LmlzS2luZGxlRmlyZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFwiS2luZGxlIEZpcmUgSEQgN1wiO1xyXG4gICAgICBjYXNlIC9LRlRIV0kvZ2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNLaW5kbGVGaXJlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJLaW5kbGUgRmlyZSBIRFggN1wiO1xyXG4gICAgICBjYXNlIC9LRlRIV0EvZ2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNLaW5kbGVGaXJlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJLaW5kbGUgRmlyZSBIRFggNyA0R1wiO1xyXG4gICAgICBjYXNlIC9LRkFQV0kvZ2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpOlxyXG4gICAgICAgIHRoaXMuQWdlbnQuaXNLaW5kbGVGaXJlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gXCJLaW5kbGUgRmlyZSBIRFggOC45XCI7XHJcbiAgICAgIGNhc2UgL0tGQVBXQS9naS50ZXN0KHVhLkFnZW50LnNvdXJjZSk6XHJcbiAgICAgICAgdGhpcy5BZ2VudC5pc0tpbmRsZUZpcmUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBcIktpbmRsZSBGaXJlIEhEWCA4LjkgNEdcIjtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGhpcy50ZXN0Q2FwdGl2ZU5ldHdvcmsgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB1YSA9IHRoaXM7XHJcbiAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgY2FzZSAvQ2FwdGl2ZU5ldHdvcmsvZ2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpOlxyXG4gICAgICAgIHVhLkFnZW50LmlzQ2FwdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdWEuQWdlbnQuaXNNYWMgPSB0cnVlO1xyXG4gICAgICAgIHVhLkFnZW50LnBsYXRmb3JtID0gXCJBcHBsZSBNYWNcIjtcclxuICAgICAgICByZXR1cm4gXCJDYXB0aXZlTmV0d29ya1wiO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLnRlc3RNb2JpbGUgPSBmdW5jdGlvbiB0ZXN0TW9iaWxlKCkge1xyXG4gICAgdmFyIHVhID0gdGhpcztcclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIHVhLkFnZW50LmlzV2luZG93czpcclxuICAgICAgY2FzZSB1YS5BZ2VudC5pc0xpbnV4OlxyXG4gICAgICBjYXNlIHVhLkFnZW50LmlzTWFjOlxyXG4gICAgICBjYXNlIHVhLkFnZW50LmlzQ2hyb21lT1M6XHJcbiAgICAgICAgdWEuQWdlbnQuaXNEZXNrdG9wID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSB1YS5BZ2VudC5pc0FuZHJvaWQ6XHJcbiAgICAgIGNhc2UgdWEuQWdlbnQuaXNTYW1zdW5nOlxyXG4gICAgICAgIHVhLkFnZW50LmlzTW9iaWxlID0gdHJ1ZTtcclxuICAgICAgICB1YS5BZ2VudC5pc0Rlc2t0b3AgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgIH1cclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIHVhLkFnZW50LmlzaVBhZDpcclxuICAgICAgY2FzZSB1YS5BZ2VudC5pc2lQb2Q6XHJcbiAgICAgIGNhc2UgdWEuQWdlbnQuaXNpUGhvbmU6XHJcbiAgICAgIGNhc2UgdWEuQWdlbnQuaXNCYWRhOlxyXG4gICAgICBjYXNlIHVhLkFnZW50LmlzQmxhY2tiZXJyeTpcclxuICAgICAgY2FzZSB1YS5BZ2VudC5pc0FuZHJvaWQ6XHJcbiAgICAgIGNhc2UgdWEuQWdlbnQuaXNXaW5kb3dzUGhvbmU6XHJcbiAgICAgICAgdWEuQWdlbnQuaXNNb2JpbGUgPSB0cnVlO1xyXG4gICAgICAgIHVhLkFnZW50LmlzRGVza3RvcCA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgfVxyXG4gICAgaWYgKC9tb2JpbGUvaS50ZXN0KHVhLkFnZW50LnNvdXJjZSkpIHtcclxuICAgICAgdWEuQWdlbnQuaXNNb2JpbGUgPSB0cnVlO1xyXG4gICAgICB1YS5BZ2VudC5pc0Rlc2t0b3AgPSBmYWxzZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLnRlc3RUYWJsZXQgPSBmdW5jdGlvbiB0ZXN0VGFibGV0KCkge1xyXG4gICAgdmFyIHVhID0gdGhpcztcclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIHVhLkFnZW50LmlzaVBhZDpcclxuICAgICAgY2FzZSB1YS5BZ2VudC5pc0FuZHJvaWRUYWJsZXQ6XHJcbiAgICAgIGNhc2UgdWEuQWdlbnQuaXNLaW5kbGVGaXJlOlxyXG4gICAgICAgIHVhLkFnZW50LmlzVGFibGV0ID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmICgvdGFibGV0L2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpKSB7XHJcbiAgICAgIHVhLkFnZW50LmlzVGFibGV0ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLnRlc3ROZ2lueEdlb0lQID0gZnVuY3Rpb24gdGVzdE5naW54R2VvSVAoaGVhZGVycykge1xyXG4gICAgdmFyIHVhID0gdGhpcztcclxuICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgIGlmICgvXkdFT0lQL2kudGVzdChrZXkpKSB7XHJcbiAgICAgICAgdWEuQWdlbnQuZ2VvSXBba2V5XSA9IGhlYWRlcnNba2V5XTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy50ZXN0Qm90ID0gZnVuY3Rpb24gdGVzdEJvdCgpIHtcclxuICAgIHZhciB1YSA9IHRoaXM7XHJcbiAgICB2YXIgaXNCb3QgPSBJU19CT1RfUkVHRVhQLmV4ZWModWEuQWdlbnQuc291cmNlLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgaWYgKGlzQm90KSB7XHJcbiAgICAgIHVhLkFnZW50LmlzQm90ID0gaXNCb3RbMV07XHJcbiAgICB9IGVsc2UgaWYgKCF1YS5BZ2VudC5pc0F1dGhvcml0YXRpdmUpIHtcclxuICAgICAgLy8gVGVzdCB1bmF1dGhvcml0YXRpdmUgcGFyc2UgZm9yIGBib3RgIGluIFVBIHRvIGZsYWcgZm9yIGJvdFxyXG4gICAgICB1YS5BZ2VudC5pc0JvdCA9IC9ib3QvaS50ZXN0KHVhLkFnZW50LnNvdXJjZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGhpcy50ZXN0U21hcnRUViA9IGZ1bmN0aW9uIHRlc3RCb3QoKSB7XHJcbiAgICB2YXIgdWEgPSB0aGlzO1xyXG4gICAgdmFyIGlzU21hcnRUViA9IG5ldyBSZWdFeHAoXHJcbiAgICAgIFwic21hcnQtdHZ8c21hcnR0dnxnb29nbGV0dnxhcHBsZXR2fGhiYnR2fHBvdl90dnxuZXRjYXN0LnR2XCIsXHJcbiAgICAgIFwiZ2lcIlxyXG4gICAgKS5leGVjKHVhLkFnZW50LnNvdXJjZS50b0xvd2VyQ2FzZSgpKTtcclxuICAgIGlmIChpc1NtYXJ0VFYpIHtcclxuICAgICAgdWEuQWdlbnQuaXNTbWFydFRWID0gaXNTbWFydFRWWzFdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMudGVzdEFuZHJvaWRUYWJsZXQgPSBmdW5jdGlvbiB0ZXN0QW5kcm9pZFRhYmxldCgpIHtcclxuICAgIHZhciB1YSA9IHRoaXM7XHJcbiAgICBpZiAodWEuQWdlbnQuaXNBbmRyb2lkICYmICEvbW9iaWxlL2kudGVzdCh1YS5BZ2VudC5zb3VyY2UpKSB7XHJcbiAgICAgIHVhLkFnZW50LmlzQW5kcm9pZFRhYmxldCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGhpcy50ZXN0VG91Y2hTdXBwb3J0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdWEgPSB0aGlzO1xyXG4gICAgdWEuQWdlbnQuaXNUb3VjaFNjcmVlbiA9XHJcbiAgICAgIFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93IHx8XHJcbiAgICAgIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHxcclxuICAgICAgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuZ2V0TGFndWFnZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHVhID0gdGhpcztcclxuICAgIHVhLkFnZW50Lmxhbmd1YWdlID0gKFxyXG4gICAgICBuYXZpZ2F0b3IubGFuZ3VhZ2UgfHxcclxuICAgICAgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fFxyXG4gICAgICBuYXZpZ2F0b3IuYnJvd3Nlckxhbmd1YWdlIHx8XHJcbiAgICAgIG5hdmlnYXRvci5zeXN0ZW1MYW5ndWFnZSB8fFxyXG4gICAgICBcIlwiXHJcbiAgICApLnRvTG93ZXJDYXNlKCk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5nZXRDb2xvckRlcHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdWEgPSB0aGlzO1xyXG4gICAgdWEuQWdlbnQuY29sb3JEZXB0aCA9IHNjcmVlbi5jb2xvckRlcHRoIHx8IC0xO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuZ2V0U2NyZWVuUmVzb2x1dGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHVhID0gdGhpcztcclxuICAgIHVhLkFnZW50LnJlc29sdXRpb24gPSBbc2NyZWVuLmF2YWlsV2lkdGgsIHNjcmVlbi5hdmFpbEhlaWdodF07XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5nZXRQaXhlbERlcHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdWEgPSB0aGlzO1xyXG4gICAgdWEuQWdlbnQucGl4ZWxEZXB0aCA9IHNjcmVlbi5waXhlbERlcHRoIHx8IC0xO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuZ2V0Q1BVID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdWEgPSB0aGlzO1xyXG4gICAgdWEuQWdlbnQuY3B1Q29yZXMgPSBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCAtMTtcclxuICB9O1xyXG5cclxuICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICB2YXIgdWEgPSB0aGlzO1xyXG4gICAgZm9yICh2YXIga2V5IGluIHVhLkRlZmF1bHRBZ2VudCkge1xyXG4gICAgICBpZiAodWEuRGVmYXVsdEFnZW50Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICB1YS5BZ2VudFtrZXldID0gdWEuRGVmYXVsdEFnZW50W2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1YTtcclxuICB9O1xyXG5cclxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24gZ2V0KHNvdXJjZSkge1xyXG4gICAgc291cmNlID0gc291cmNlIHx8IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgICB2YXIgdWEgPSBuZXcgRGV2aWNlVVVJRCgpO1xyXG4gICAgdWEuQWdlbnQuc291cmNlID0gc291cmNlLnJlcGxhY2UoL15cXHMqLywgXCJcIikucmVwbGFjZSgvXFxzKiQvLCBcIlwiKTtcclxuICAgIHVhLkFnZW50Lm9zID0gdWEuZ2V0T1ModWEuQWdlbnQuc291cmNlKTtcclxuICAgIHVhLkFnZW50LnBsYXRmb3JtID0gdWEuZ2V0UGxhdGZvcm0odWEuQWdlbnQuc291cmNlKTtcclxuICAgIHVhLkFnZW50LmJyb3dzZXIgPSB1YS5nZXRCcm93c2VyKHVhLkFnZW50LnNvdXJjZSk7XHJcbiAgICB1YS5BZ2VudC52ZXJzaW9uID0gdWEuZ2V0QnJvd3NlclZlcnNpb24odWEuQWdlbnQuc291cmNlKTtcclxuICAgIHVhLnRlc3RCb3QoKTtcclxuICAgIHVhLnRlc3RTbWFydFRWKCk7XHJcbiAgICB1YS50ZXN0TW9iaWxlKCk7XHJcbiAgICB1YS50ZXN0QW5kcm9pZFRhYmxldCgpO1xyXG4gICAgdWEudGVzdFRhYmxldCgpO1xyXG4gICAgdWEudGVzdENvbXBhdGliaWxpdHlNb2RlKCk7XHJcbiAgICB1YS50ZXN0U2lsaygpO1xyXG4gICAgdWEudGVzdEtpbmRsZUZpcmUoKTtcclxuICAgIHVhLnRlc3RDYXB0aXZlTmV0d29yaygpO1xyXG4gICAgdWEudGVzdFRvdWNoU3VwcG9ydCgpO1xyXG4gICAgdWEuZ2V0TGFndWFnZSgpO1xyXG4gICAgdWEuZ2V0Q29sb3JEZXB0aCgpO1xyXG4gICAgdWEuZ2V0UGl4ZWxEZXB0aCgpO1xyXG4gICAgdWEuZ2V0U2NyZWVuUmVzb2x1dGlvbigpO1xyXG4gICAgdWEuZ2V0Q1BVKCk7XHJcbiAgICByZXR1cm4gdWEuQWdlbnQ7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5nZXQgPSBmdW5jdGlvbihjdXN0b21EYXRhKSB7XHJcbiAgICB2YXIgcHJlZiA9IFwiYVwiLFxyXG4gICAgICBkdSA9IHRoaXMucGFyc2UoKTtcclxuICAgIHZhciBkdWEgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLm9wdGlvbnMpIHtcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHRoaXMub3B0aW9uc1trZXldID09PSB0cnVlKSB7XHJcbiAgICAgICAgZHVhLnB1c2goZHVba2V5XSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjdXN0b21EYXRhKSB7XHJcbiAgICAgIGR1YS5wdXNoKGN1c3RvbURhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAmJiBkdS5pc01vYmlsZSkge1xyXG4gICAgICBkdWEucHVzaChkdS5yZXNvbHV0aW9uKTtcclxuICAgIH1cclxuICAgIC8vIDgsIDksIGEsIGJcclxuICAgIHByZWYgPSBcImJcIjtcclxuICAgIHZhciB0bXBVdWlkID0gZHUuaGFzaE1ENShkdWEuam9pbihcIjpcIikpO1xyXG4gICAgdmFyIHV1aWQgPSBbXHJcbiAgICAgIHRtcFV1aWQuc2xpY2UoMCwgOCksXHJcbiAgICAgIHRtcFV1aWQuc2xpY2UoOCwgMTIpLFxyXG4gICAgICBcIjRcIiArIHRtcFV1aWQuc2xpY2UoMTIsIDE1KSxcclxuICAgICAgcHJlZiArIHRtcFV1aWQuc2xpY2UoMTUsIDE4KSxcclxuICAgICAgdG1wVXVpZC5zbGljZSgyMClcclxuICAgIF07XHJcbiAgICByZXR1cm4gdXVpZC5qb2luKFwiLVwiKTtcclxuICB9O1xyXG5cclxuICB0aGlzLkFnZW50ID0gdGhpcy5EZWZhdWx0QWdlbnQ7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5jb25zdCBkZXZpY2VJbmZvVXVpZCA9IHtcclxuICBpbmZvKCkge1xyXG4gICAgcmV0dXJuIG5ldyBEZXZpY2VVVUlEKCkucGFyc2UoKTtcclxuICB9LFxyXG4gIG1hY2hpbmUoKSB7XHJcbiAgICB2YXIgbWFjaGluZVV1aWRLZXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShNQUNISU5FX1VVSURfS0VZKTtcclxuICAgIGlmKG1hY2hpbmVVdWlkS2V5KSByZXR1cm4gbWFjaGluZVV1aWRLZXk7XHJcbiAgICBtYWNoaW5lVXVpZEtleSA9IG5ldyBEZXZpY2VVVUlEKCkuZ2V0KCkgKyAnXycgKyB0aW1lU3RhbXAoKSArICdfJyArIHV1aWR2NCgpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oTUFDSElORV9VVUlEX0tFWSwgbWFjaGluZVV1aWRLZXkpXHJcbiAgICByZXR1cm4gbWFjaGluZVV1aWRLZXlcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBkZXZpY2VJbmZvVXVpZDtcclxuIiwiLy8gaWYgKCFnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcclxuLy8gICByZXF1aXJlKCdiYWJlbC1wb2x5ZmlsbCcpO1xyXG4vLyB9XHJcblxyXG5pbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tICcuLi8uLi9hcHAtY29uc3RhbnRzJztcclxuXHJcbmltcG9ydCBzZXRDcmVkZW50aWFscyBmcm9tICcuL3NldC1jcmVkZW50aWFscyc7XHJcbmltcG9ydCBzZXRMb2dnZWRJblN0YXRlIGZyb20gJy4vc2V0LWxvZ2dlZC1pbi1zdGF0ZSc7XHJcbmltcG9ydCBQdWJTdWIgZnJvbSAnLi4vLi4vc2VydmljZXMvcHViLXN1Yic7XHJcbmltcG9ydCBIdHRwIGZyb20gJy4uLy4uL3NlcnZpY2VzL2h0dHAnO1xyXG5pbXBvcnQgRW5jcnlwdGlvbiBmcm9tICcuLi8uLi9zZXJ2aWNlcy9lbmNyeXB0aW9uJztcclxuaW1wb3J0IFJlc3BvbnNlIGZyb20gJy4uLy4uL3NlcnZpY2VzL3Jlc3BvbnNlJztcclxuaW1wb3J0IFN0YXRlIGZyb20gJy4uLy4uL3NlcnZpY2VzL3N0YXRlJztcclxuaW1wb3J0IFN0b3JhZ2UgZnJvbSAnLi4vLi4vc2VydmljZXMvc3RvcmFnZSc7XHJcbmltcG9ydCBkZXZpY2VJbmZvVXVpZCBmcm9tICcuLi9kZXZpY2UtaW5mby11dWlkJztcclxuXHJcbi8qKlxyXG4gKiBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSAge1N0cmluZ1tlbWFpbCwgcGFzc3dvcmRdfSBsb2dpblBhcmFtcyBbZGVzY3JpcHRpb25dXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICovXHJcblxyXG5jb25zdCBsb2dpbkNoYXRib3QgPSBhc3luYyBmdW5jdGlvbihcclxuICBsb2dpblBhcmFtcyxcclxuICBzdGF0ZSA9IG5ldyBTdGF0ZSgpLFxyXG4gIGh0dHAgPSBuZXcgSHR0cCgpLFxyXG4gIGVuY3J5cHRpb24gPSBuZXcgRW5jcnlwdGlvbigpLFxyXG4gIHB1YlN1YiA9IG5ldyBQdWJTdWIoKSxcclxuICByZXNwb25zZSA9IG5ldyBSZXNwb25zZSgpLFxyXG4gIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpXHJcbikge1xyXG4gIHRyeSB7XHJcbiAgICBsZXQgbG9naW5EYXRhO1xyXG5cclxuICAgIC8vIENIQU5HRVMgSU5JVFxyXG4gICAgLypcclxuICAgIGNvbnN0IHByb2plY3QgPSBwYXJzZUludChsb2dpblBhcmFtc1swXSk7XHJcbiAgICBjb25zdCBhcGlLZXkgPSBlbmNyeXB0aW9uLmVuY3J5cHRTdHJpbmcobG9naW5QYXJhbXNbMV0pO1xyXG4gICAgKi9cclxuICAgIGNvbnN0IGNoYW5uZWxUb2tlbiA9IGxvZ2luUGFyYW1zWzBdO1xyXG4gICAgY29uc3QgYXBpS2V5ID0gbG9naW5QYXJhbXNbMV07XHJcbiAgICAvLyBDSEFOR0VTIEVORFxyXG5cclxuICAgIGxldCBtYWNoaW5lVXVpZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdibHVlZGFyd2luLWNoYXRib3RfX21hY2hpbmVfdXVpZCcpXHJcbiAgICBpZighbWFjaGluZVV1aWQpe1xyXG4gICAgICBtYWNoaW5lVXVpZCA9IGRldmljZUluZm9VdWlkLm1hY2hpbmUoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxMCk7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdibHVlZGFyd2luLWNoYXRib3RfX21hY2hpbmVfdXVpZCcsbWFjaGluZVV1aWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBsb2dpbiBkYXRhIGZyb20gc2VydmVyIGFuZCBkZWNyeXB0IHRoZSBwYXlsb2FkXHJcbiAgICBsb2dpbkRhdGEgPSBhd2FpdCBodHRwLnBvc3QoXHJcbiAgICAgICdsZXQtdGhlLWNoYXRib3QtaW4tdjInLFxyXG4gICAgICB7XHJcbiAgICAgICAgLy8gU1RBUlQgQ0hBTkdFU1xyXG4gICAgICAgIC8vIHByb2plY3QsXHJcbiAgICAgICAgY2hhbm5lbFRva2VuLFxyXG4gICAgICAgIC8vIEVORCBDSEFOR0VTXHJcbiAgICAgICAgYXBpS2V5LFxyXG4gICAgICAgIG1hY2hpbmVVdWlkXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBza2lwRW5jcnlwdGlvbjogdHJ1ZSxcclxuICAgICAgICBsb2dpbkRlY3J5cHRpb246IGxvZ2luUGFyYW1zWzFdLFxyXG4gICAgICAgIGdldEZ1bGxSZXNwb25zZTogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vQFRPRE86IENIRUNLIFRISVMgQlVHIC0gdGhpcyBzaG91bGQgZGUgc3RhcmRhcmRpemVkIGZvciBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvblxyXG4gICAgbG9naW5EYXRhID0gbG9naW5EYXRhLmRhdGEgfHwgbG9naW5EYXRhO1xyXG5cclxuICAgIC8vIGxvZ2luRGF0YSA9IGVuY3J5cHRpb24uZGVjcnlwdFBheWxvYWQobG9naW5EYXRhLCBsb2dpblBhcmFtc1sxXSwge2ZvcmNlOiB0cnVlfSlcclxuXHJcbiAgICAvLyBTZXQgdGhlbSBjcmVkZW50aWFsc1xyXG4gICAgYXdhaXQgc2V0Q3JlZGVudGlhbHMobG9naW5EYXRhLCBodHRwLCBlbmNyeXB0aW9uLCBzdGF0ZSwgc3RvcmFnZSwgcmVzcG9uc2UpO1xyXG4gICAgLy8gVXBkYXRlIHN0YXRlIGZvciBtaWRkbGV3YXJlXHJcbiAgICBzZXRMb2dnZWRJblN0YXRlKHN0YXRlKTtcclxuXHJcbiAgICBwdWJTdWIuZW1pdChBUFBfQ09OU1RBTlRTLkVWRU5UUy5MT0dHRURfSU4pO1xyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5vayh7XHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICAvLyBTVEFSVCBDSEFOR0VTXHJcbiAgICAgICAgbW9kdWxlOiBsb2dpbkRhdGEubW9kdWxlLFxyXG4gICAgICAgIC8vIEVORCBDSEFOR0VTXHJcbiAgICAgICAga2V5OiBsb2dpbkRhdGEua2V5LFxyXG4gICAgICAgIHRva2VuOiBsb2dpbkRhdGEudG9rZW4sXHJcbiAgICAgICAgdXNlcjogbG9naW5EYXRhLnVzZXJcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSBjYXRjaCAoZXgpIHtcclxuICAgIHB1YlN1Yi5lbWl0KEFQUF9DT05TVEFOVFMuRVZFTlRTLkxPR0lOX0ZBSUwpO1xyXG4gICAgdGhyb3cgcmVzcG9uc2UuZXJyb3Ioe1xyXG4gICAgICBkYXRhOiBleCxcclxuICAgICAgbWVzc2FnZTogJ0VSUk9SLkxPR0lOX0ZBSUwnXHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBsb2dpbkNoYXRib3Q7XHJcbiIsImltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gXCIuLi8uLi9hcHAtY29uc3RhbnRzXCI7XHJcblxyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3N0YXRlXCI7XHJcbmltcG9ydCBQdWJTdWIgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3B1Yi1zdWJcIjtcclxuaW1wb3J0IFN0b3JhZ2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3N0b3JhZ2VcIjtcclxuXHJcbmNvbnN0IGxvZ291dCA9IGZ1bmN0aW9uKFxyXG4gIHN0YXRlID0gbmV3IFN0YXRlKCksXHJcbiAgcHViU3ViID0gbmV3IFB1YlN1YigpLFxyXG4gIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpXHJcbikge1xyXG4gIHN0YXRlLmRlbGV0ZShBUFBfQ09OU1RBTlRTLlNUQVRFUy5JU19MT0dHRURfSU4pO1xyXG4gIHN0YXRlLmRlbGV0ZShBUFBfQ09OU1RBTlRTLlNUQVRFUy5MT0dJTl9NRVRIT0QpO1xyXG4gIHN0YXRlLmRlbGV0ZShBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfVVNFUik7XHJcbiAgc3RhdGUuZGVsZXRlKEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19UT0tFTik7XHJcbiAgc3RhdGUuZGVsZXRlKEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19LRVkpO1xyXG4gIHN0YXRlLmRlbGV0ZShBUFBfQ09OU1RBTlRTLlNUQVRFUy5NT0RFTF9JTlRFTlQpO1xyXG4gIHN0YXRlLmRlbGV0ZShBUFBfQ09OU1RBTlRTLlNUQVRFUy5NT0RFTF9NT0RVTEUpO1xyXG4gIHN0YXRlLmRlbGV0ZShBUFBfQ09OU1RBTlRTLlNUQVRFUy5NT0RFTF9DSEFOTkVMUyk7XHJcbiAgc3RhdGUuZGVsZXRlKEFQUF9DT05TVEFOVFMuU1RBVEVTLk1PREVMX1NFU1NJT04pO1xyXG5cclxuICBzdG9yYWdlLmRlbGV0ZShBUFBfQ09OU1RBTlRTLlNUT1JBR0UuVE9LRU4pO1xyXG4gIHN0b3JhZ2UuZGVsZXRlKEFQUF9DT05TVEFOVFMuU1RPUkFHRS5LRVkpO1xyXG4gIHN0b3JhZ2UuZGVsZXRlKEFQUF9DT05TVEFOVFMuU1RPUkFHRS5PTERfS0VZKTtcclxuICBzdG9yYWdlLmRlbGV0ZShBUFBfQ09OU1RBTlRTLlNUT1JBR0UuVVNFUik7XHJcblxyXG4gIHB1YlN1Yi5lbWl0KEFQUF9DT05TVEFOVFMuRVZFTlRTLkxPR0dFRF9PVVQpO1xyXG5cclxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBsb2dvdXQ7XHJcbiIsImltcG9ydCBsb2dpbiBmcm9tIFwiLi4vaGVscGVycy9hdXRoL2xvZ2luXCI7XHJcbmltcG9ydCBsb2dpbkNoYXRib3QgZnJvbSBcIi4uL2hlbHBlcnMvYXV0aC9sb2dpbi1jaGF0Ym90XCI7XHJcbmltcG9ydCBsb2dvdXQgZnJvbSBcIi4uL2hlbHBlcnMvYXV0aC9sb2dvdXRcIjtcclxuaW1wb3J0IFNlcnZpY2UgZnJvbSBcIi5cIjtcclxuaW1wb3J0IFN0YXRlIGZyb20gXCIuL3N0YXRlXCI7XHJcbmltcG9ydCBQdWJTdWIgZnJvbSBcIi4vcHViLXN1YlwiO1xyXG5pbXBvcnQgRW5jcnlwdGlvbiBmcm9tIFwiLi9lbmNyeXB0aW9uXCI7XHJcbmltcG9ydCBIdHRwIGZyb20gXCIuL2h0dHBcIjtcclxuaW1wb3J0IFJlc3BvbnNlIGZyb20gXCIuL3Jlc3BvbnNlXCI7XHJcbmltcG9ydCBTdG9yYWdlIGZyb20gXCIuL3N0b3JhZ2VcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dGggZXh0ZW5kcyBTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFN0YXRlLCBIdHRwLCBFbmNyeXB0aW9uLCBIdHRwLCBQdWJTdWIsIFJlc3BvbnNlLCBTdG9yYWdlKTtcclxuICB9XHJcblxyXG4gIGxvZ2luKGxvZ2luUGFyYW1zID0gW10pIHtcclxuICAgIHJldHVybiBsb2dpbihcclxuICAgICAgbG9naW5QYXJhbXMsXHJcbiAgICAgIHRoaXMuU3RhdGUsXHJcbiAgICAgIHRoaXMuSHR0cCxcclxuICAgICAgdGhpcy5FbmNyeXB0aW9uLFxyXG4gICAgICB0aGlzLlB1YlN1YixcclxuICAgICAgdGhpcy5SZXNwb25zZSxcclxuICAgICAgdGhpcy5TdG9yYWdlXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbG9naW5DaGF0Ym90KGxvZ2luUGFyYW1zID0gW10pIHtcclxuICAgIHJldHVybiBsb2dpbkNoYXRib3QoXHJcbiAgICAgIGxvZ2luUGFyYW1zLFxyXG4gICAgICB0aGlzLlN0YXRlLFxyXG4gICAgICB0aGlzLkh0dHAsXHJcbiAgICAgIHRoaXMuRW5jcnlwdGlvbixcclxuICAgICAgdGhpcy5QdWJTdWIsXHJcbiAgICAgIHRoaXMuUmVzcG9uc2UsXHJcbiAgICAgIHRoaXMuU3RvcmFnZVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGxvZ291dCgpIHtcclxuICAgIHJldHVybiBsb2dvdXQodGhpcy5TdGF0ZSwgdGhpcy5QdWJTdWIsIHRoaXMuU3RvcmFnZSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmltcG9ydCBnZXRNb2R1bGVzIGZyb20gJy4vaGVscGVycy9yZXN0LWFwaS9nZXQtbW9kdWxlcyc7XHJcbmltcG9ydCBnZXRNb2R1bGUgZnJvbSAnLi9oZWxwZXJzL3Jlc3QtYXBpL2dldC1tb2R1bGUnO1xyXG5pbXBvcnQgZ2V0Q2hhdGJvdFVzZXIgZnJvbSAnLi9oZWxwZXJzL3Jlc3QtYXBpL2dldC1jaGF0Ym90LXVzZXInO1xyXG5pbXBvcnQgc2VuZExvZ291dCBmcm9tICcuL2hlbHBlcnMvcmVzdC1hcGkvc2VuZC1sb2dvdXQnO1xyXG5cclxuaW1wb3J0IEkxOE4gZnJvbSAnLi9pMThuL2VuX0VOJztcclxuXHJcbmltcG9ydCBpbmplY3REZXBlbmRlbmNpZXMgZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2RlcGVuZGVuY2llcy9pbmplY3QtZGVwZW5kZW5jaWVzJztcclxuXHJcbmltcG9ydCBDb25maWd1cmF0aW9uIGZyb20gJ0JsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvY29uZmlndXJhdGlvbic7XHJcbmltcG9ydCBUcmFuc2xhdGUgZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy90cmFuc2xhdGUnO1xyXG5pbXBvcnQgSHR0cCBmcm9tICdCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2h0dHAnO1xyXG5pbXBvcnQgRW5jcnlwdGlvbiBmcm9tICdCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2VuY3J5cHRpb24nO1xyXG5pbXBvcnQgQXV0aCBmcm9tICdCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2F1dGgnO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9zdGF0ZSc7XHJcbmltcG9ydCBQdWJTdWIgZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9wdWItc3ViJztcclxuaW1wb3J0IFJlc3BvbnNlIGZyb20gJ0JsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvcmVzcG9uc2UnO1xyXG5cclxuY2xhc3MgQ2hhdGJvdCB7XHJcbiAgLy8gTG9jayBvbmx5IG9uZSB3cml0ZSBzZXR0aW5ncyBmb3IgY29uZmlnXHJcbiAgI2NvbmZpZyA9IG51bGw7XHJcbiAgI3RtcExvZ2luUGFyYW1zID0gW107XHJcbiAgbW9kdWxlO1xyXG4gIGNoYXRib3RVc2VyO1xyXG5cclxuICBnZXQgY29uZmlnKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI2NvbmZpZztcclxuICB9XHJcblxyXG4gIHNldCBjb25maWcoZGF0YSkge1xyXG4gICAgaWYgKG51bGwgPT09IHRoaXMuI2NvbmZpZykge1xyXG4gICAgICB0aGlzLiNjb25maWcgPSBkYXRhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLndoaXNwZXIoKTtcclxuXHJcbiAgICBjb25zdCBhcmdzID0gWy4uLmFyZ3VtZW50c107XHJcbiAgICBjb25zdCBjb25maWcgPSBhcmdzWzJdIHx8IHt9O1xyXG4gICAgY29uc3QgbG9naW5QYXJhbXMgPSBhcmdzLnNsaWNlKDAsIDIpO1xyXG5cclxuICAgIC8vIFNldHVwIGNvbmZpZ3VyYXRpb25cclxuICAgIHRoaXMuY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnKTtcclxuXHJcbiAgICBpbmplY3REZXBlbmRlbmNpZXMoXHJcbiAgICAgIFtFbmNyeXB0aW9uLCBIdHRwLCBBdXRoLCBUcmFuc2xhdGUsIFN0YXRlLCBQdWJTdWIsIFJlc3BvbnNlXSxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTZXR1cCBsYW5ndWFnZVxyXG4gICAgdGhpcy5UcmFuc2xhdGUuc2V0TGFuZ3VhZ2UoSTE4Tik7XHJcbiAgICAvLyBTZXR1cCB0aGlzIGNoYXRib3RcclxuICAgIHRoaXMuI3RtcExvZ2luUGFyYW1zID0gbG9naW5QYXJhbXM7XHJcbiAgICAvLyB0aGlzLm1vZHVsZSA9IGFtTW9kdWxlO1xyXG4gICAgdGhpcy5jaGF0Ym90VXNlciA9IGNvbmZpZy5jaGF0Ym90VXNlcjtcclxuXHJcbiAgICAvLyB0aGlzLlN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfTU9EVUxFLCB0aGlzLm1vZHVsZSk7XHJcbiAgICB0aGlzLlN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfQ0xJRU5UX1VTRVJfSUQsIHRoaXMuY2hhdGJvdFVzZXIpO1xyXG4gICAgdGhpcy5TdGF0ZS5zZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuRU5WSVJPTk1FTlQsIHRoaXMuY29uZmlnLmVudmlyb25tZW50KTtcclxuICB9XHJcblxyXG4gIC8vIFNpbGVudCBsb2cgb3VyIHBhY2thZ2UgYW5kIHZlcnNpb25cclxuICB3aGlzcGVyKCkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGAlYyBDb2dudXMgQ2hhdGJvdCAgICAgICAgOiAke0FQUF9DT05TVEFOVFMuVkVSU0lPTn1gLFxyXG4gICAgICAnY29sb3I6IHRyYW5zcGFyZW50J1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGdldE1vZHVsZXMoKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxlcyh0aGlzLkh0dHApO1xyXG4gIH1cclxuXHJcbiAgZ2V0TW9kdWxlKGlkKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxlKGlkLCB0aGlzLkh0dHApO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2hhdGJvdFVzZXIoaWQpIHtcclxuICAgIHJldHVybiBnZXRDaGF0Ym90VXNlcihpZCwgdGhpcy5IdHRwKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZUNoYXRib3RVc2VyKHBhcmFtcykge1xyXG4gICAgLy9yZXR1cm4gZ2VuZXJhdGVDaGF0Ym90VXNlcihwYXJhbXMpO1xyXG4gIH1cclxuXHJcbiAgc2V0dXAoKSB7XHJcbiAgICAvLyBTZXR1cCBFcnJvciBMb2dnZXI7XHJcbiAgICAvLyBSdW4gTG9naW5cclxuICAgIHJldHVybiB0aGlzLmxvZ2luKCk7XHJcbiAgfVxyXG5cclxuICAvLyBwcml2YXRlIG1ldGhvZCBsb2dpbiByZXF1aXJlcyBhIG5ldyBTeW1ib2wgZGVjbGFyYXRlZCBvbiB0b3BcclxuICBsb2dpbihLZXkxLCBLZXkyKSB7XHJcbiAgICBpZiAoS2V5MSAmJiBLZXkyKSB0aGlzLiN0bXBMb2dpblBhcmFtcyA9IFtLZXkxLCBLZXkyXTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XHJcbiAgICAgIHRoaXMuQXV0aC5sb2dpbkNoYXRib3QoXHJcbiAgICAgICAgdGhpcy4jdG1wTG9naW5QYXJhbXMsXHJcbiAgICAgICAgdGhpcy5TdGF0ZSxcclxuICAgICAgICB0aGlzLkh0dHAsXHJcbiAgICAgICAgdGhpcy5FbmNyeXB0aW9uLFxyXG4gICAgICAgIHRoaXMuUHViU3ViLFxyXG4gICAgICAgIHRoaXMuUmVzcG9uc2UsXHJcbiAgICAgICAgdGhpcy5TdG9yYWdlXHJcbiAgICAgIClcclxuICAgICAgICAudGhlbihzdWNjZXNzID0+IHtcclxuICAgICAgICAgIHRoaXMuU3RhdGUuc2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19NT0RVTEUsIHN1Y2Nlc3MuZGF0YS5tb2R1bGUpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5TdGF0ZS5zZXQoXHJcbiAgICAgICAgICAgICAgQVBQX0NPTlNUQU5UUy5TVEFURVMuSEFTX0NMSUVOVF9VU0VSX0lELFxyXG4gICAgICAgICAgICAgIHN1Y2Nlc3MuZGF0YS51c2VyLmlkXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuI3RtcExvZ2luUGFyYW1zID0ge307XHJcbiAgICAgICAgICByZXMoc3VjY2Vzcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXggPT4ge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGV4KTtcclxuICAgICAgICAgIHJlaihleCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGNsb3NlU2Vzc2lvbigpIHtcclxuICAgIGF3YWl0IHNlbmRMb2dvdXQoKTtcclxuICAgIHRoaXMuUHViU3ViLmVtaXQoJ0xPR09VVCcpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hhdGJvdDtcclxuIiwiaW1wb3J0IEFQUF9DT05TVEFOVFMgZnJvbSBcIi4uL2FwcC1jb25zdGFudHNcIjtcclxuaW1wb3J0IFN0YXRlIGZyb20gXCIuLi9zZXJ2aWNlcy9zdGF0ZVwiO1xyXG5pbXBvcnQgUmVzcG9uc2UgZnJvbSBcIi4uL3NlcnZpY2VzL3Jlc3BvbnNlXCI7XHJcblxyXG5jb25zdCBfZ2V0UG9zdE1lc3NhZ2VUYXJnZXRPcmlnaW4gPSBmdW5jdGlvbigpIHtcclxuICAvLyBAVE9ET1xyXG4gIHJldHVybiBcIipcIjtcclxufTtcclxuXHJcbmNvbnN0IHNlbmQgPSBmdW5jdGlvbihcclxuICBldmVudCA9IFwiXCIsXHJcbiAgZGF0YSA9IHt9LFxyXG4gIHN0YXRlID0gbmV3IFN0YXRlKCksXHJcbiAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoKVxyXG4pIHtcclxuICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkVMRU1FTlRfSUZSQU1FKTtcclxuXHJcbiAgaWYgKCFlbGVtZW50KVxyXG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcclxuICAgICAgcmVzcG9uc2Uub2soe1xyXG4gICAgICAgIG1lc3NhZ2U6IFwiQ2FuJ3Qgc2VuZCBwb3N0YmFjayBldmVudHMgaWYgbm8gZWxlbWVudCBpcyBmb3VuZFwiXHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICBlbGVtZW50LmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoXHJcbiAgICBKU09OLnBhcnNlKFxyXG4gICAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgY29nbnVzRXZlbnQ6IHtcclxuICAgICAgICAgIGV2ZW50LFxyXG4gICAgICAgICAgZGF0YVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICksXHJcbiAgICBfZ2V0UG9zdE1lc3NhZ2VUYXJnZXRPcmlnaW4oKVxyXG4gICk7XHJcbn07XHJcblxyXG5jb25zdCByZWNpZXZlID0gZnVuY3Rpb24oKSB7XHJcbiAgLy9AVE9ET1xyXG59O1xyXG5cclxuY29uc3QgUG9zdE1lc3NhZ2UgPSB7XHJcbiAgc2VuZCxcclxuICByZWNpZXZlXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQb3N0TWVzc2FnZTtcclxuIiwiLyoqXHJcbiAqIFJldHVybnMgYSBvYmplY3Qgd2l0aCBvbmx5IHRoZSBkYXRhIHJlcXVpcmVkIGZvciB0aGUgbW9kZWxcclxuICogQHBhcmFtIHtPYmplY3R8TW9kZWx9IG1vZGVsXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAqIEByZXR1cm4ge09iamVjdHxNb2RlbH1cclxuICpcclxuICovXHJcblxyXG5jb25zdCBleHRlbmRBbmRLZWVwU3RydWN0dXJlID0gZnVuY3Rpb24obW9kZWwsIGRhdGEpIHtcclxuICBjb25zdCB1cGRhdGVkTW9kZWwgPSB7fTtcclxuXHJcbiAgT2JqZWN0LmtleXMobW9kZWwpLmZvckVhY2goa2V5ID0+IHtcclxuICAgIHVwZGF0ZWRNb2RlbFtrZXldID0gZGF0YVtrZXldIHx8IG1vZGVsW2tleV07XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB1cGRhdGVkTW9kZWw7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBleHRlbmRBbmRLZWVwU3RydWN0dXJlO1xyXG4iLCJpbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tIFwiLi4vLi4vYXBwLWNvbnN0YW50c1wiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3N0YXRlXCI7XHJcbmltcG9ydCBQb3N0TWVzc2FnZSBmcm9tIFwiLi4vcG9zdC1tZXNzYWdlXCI7XHJcbmltcG9ydCBleHRlbmRBbmRLZWVwU3RydWN0dXJlIGZyb20gXCIuLi9leHRlbmQtYW5kLWtlZXAtc3RydWN0dXJlXCI7XHJcblxyXG5jb25zdCBNb2RlbCA9IHtcclxuICB0b2tlbjogXCJsb2dpbi50b2tlblwiLFxyXG4gIHVzZXJJZDogXCJsb2dpbi51c2VyLmlkXCIsXHJcbiAga2V5OiBcImxvZ2luLmtleVwiLFxyXG4gIHVzZXI6IFwiSlNPTi5zdHJpbmdpZnkobG9naW4udXNlcilcIlxyXG59O1xyXG5jb25zdCBpZnJhbWVTZXR1cENsaWVudCA9IGZ1bmN0aW9uKHN0YXRlID0gbmV3IFN0YXRlKCkpIHtcclxuICBjb25zdCBldmVudCA9IFwic2V0dXBDbGllbnRcIjtcclxuICBjb25zdCB0b2tlbiA9IHN0YXRlLmdldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfVE9LRU4pO1xyXG4gIGNvbnN0IHVzZXJJZCA9IHN0YXRlLmdldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfVVNFUikuaWQ7XHJcbiAgY29uc3Qga2V5ID0gc3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19LRVkpO1xyXG4gIGNvbnN0IHVzZXIgPSBKU09OLnN0cmluZ2lmeShzdGF0ZS5nZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuSEFTX1VTRVIpIHx8IHt9KTtcclxuXHJcbiAgY29uc3QgZGF0YSA9IHtcclxuICAgIHRva2VuLFxyXG4gICAgdXNlcklkLFxyXG4gICAga2V5LFxyXG4gICAgdXNlclxyXG4gIH07XHJcblxyXG4gIFBvc3RNZXNzYWdlLnNlbmQoZXZlbnQsIGV4dGVuZEFuZEtlZXBTdHJ1Y3R1cmUoTW9kZWwsIGRhdGEpKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlmcmFtZVNldHVwQ2xpZW50O1xyXG4iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3N0YXRlXCI7XHJcbmltcG9ydCBQb3N0TWVzc2FnZSBmcm9tIFwiLi4vcG9zdC1tZXNzYWdlXCI7XHJcbmltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gXCIuLi8uLi9hcHAtY29uc3RhbnRzXCI7XHJcblxyXG5jb25zdCBpZnJhbWVTZXR1cFVzZXIgPSBmdW5jdGlvbihzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgY29uc3QgaWQgPSBzdGF0ZS5nZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuSEFTX0NMSUVOVF9VU0VSX0lEKTtcclxuICBjb25zdCBldmVudCA9IFwic2V0dXBVc2VyXCI7XHJcbiAgUG9zdE1lc3NhZ2Uuc2VuZChldmVudCwge1xyXG4gICAgaWRcclxuICB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlmcmFtZVNldHVwVXNlcjtcclxuIiwiLypcclxuY29uc3QgQVBQX0NPTlNUQU5UUyA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtY29uc3RhbnRzXCIpO1xyXG5cclxuY29uc3QgUG9zdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vcG9zdC1tZXNzYWdlXCIpO1xyXG5jb25zdCBTdGF0ZSA9IHJlcXVpcmUoXCIuLi8uLi9zZXJ2aWNlcy9zdGF0ZVwiKTtcclxuXHJcblxyXG5cclxuY29uc3QgYWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgUG9zdE1lc3NhZ2Uuc2VuZChldmVudCwgU3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19NT0RVTEUpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYWN0aW9uO1xyXG4qL1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL3N0YXRlXCI7XHJcbmltcG9ydCBQb3N0TWVzc2FnZSBmcm9tIFwiLi4vcG9zdC1tZXNzYWdlXCI7XHJcbmltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gXCIuLi8uLi9hcHAtY29uc3RhbnRzXCI7XHJcblxyXG5jb25zdCBpZnJhbWVTZXRNb2R1bGVCeUlkID0gZnVuY3Rpb24oc3RhdGUgPSBuZXcgU3RhdGUoKSkge1xyXG4gIGNvbnN0IGV2ZW50ID0gXCJzZXRNb2R1bGVCeUlkXCI7XHJcbiAgUG9zdE1lc3NhZ2Uuc2VuZChldmVudCwgc3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19NT0RVTEUpKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlmcmFtZVNldE1vZHVsZUJ5SWQ7XHJcbiIsImltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gJy4uL2NvbnN0YW50cyc7XHJcblxyXG5pbXBvcnQgaWZyYW1lU2V0dXBDbGllbnQgZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL3Bvc3QtbWVzc2FnZS9pZnJhbWUtc2V0dXAtY2xpZW50JztcclxuaW1wb3J0IGlmcmFtZVNldHVwVXNlciBmcm9tICdCbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvcG9zdC1tZXNzYWdlL2lmcmFtZS1zZXR1cC11c2VyJztcclxuaW1wb3J0IGlmcmFtZVNldERlYnVnTW9kZSBmcm9tICdCbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvcG9zdC1tZXNzYWdlL2lmcmFtZS1zZXQtZGVidWctbW9kZSc7XHJcbmltcG9ydCBpZnJhbWVTZXRNb2R1bGVCeUlkIGZyb20gJ0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9wb3N0LW1lc3NhZ2UvaWZyYW1lLXNldC1tb2R1bGUtYnktaWQnO1xyXG5cclxuaW1wb3J0IENvbmZpZ3VyYXRpb24gZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9jb25maWd1cmF0aW9uJztcclxuaW1wb3J0IFN0YXRlIGZyb20gJ0JsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvc3RhdGUnO1xyXG5pbXBvcnQgUmVzcG9uc2UgZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9yZXNwb25zZSc7XHJcbmltcG9ydCBQdWJTdWIgZnJvbSAnQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9wdWItc3ViJztcclxuaW1wb3J0IGluamVjdERlcGVuZGVuY2llcyBmcm9tICdCbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvZGVwZW5kZW5jaWVzL2luamVjdC1kZXBlbmRlbmNpZXMnO1xyXG5cclxubGV0IGluc3RhbmNpYXRlZDtcclxuY2xhc3MgSWZyYW1lIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGluamVjdERlcGVuZGVuY2llcyhbQ29uZmlndXJhdGlvbiwgU3RhdGUsIFJlc3BvbnNlLCBQdWJTdWJdLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIC8vIEBUT0RPXHJcbiAgI3BhcnNlSWZyYW1lU3R5bGVzKGNvbmZpZyA9IHt9KSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSBBUFBfQ09OU1RBTlRTLkRFRkFVTFRTLklGUkFNRV9DU1M7XHJcbiAgICByZXR1cm4gc3R5bGVzO1xyXG4gIH1cclxuXHJcbiAgI2FkZElmcmFtZVRvRG9jdW1lbnQoY29uZmlnID0ge30pIHtcclxuICAgIC8vIENvdW50ZXIgZm9yIGlmcmFtZSByZXJhZHkgc3RhdGUgYXR0ZW1wdHNcclxuICAgIGxldCBfY291bnRlciA9IDA7XHJcbiAgICBsZXQgX2xpbWl0QXR0ZW1wdHMgPSAxMDA7XHJcblxyXG4gICAgLy8gUmV0dXJuIGEgcHJvbWlzZVxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xyXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5TdGF0ZS5nZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuRUxFTUVOVF9JRlJBTUUpO1xyXG4gICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2dudXMtY2hhdGJvdC1idXR0b24nKTtcclxuICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy4jcGFyc2VJZnJhbWVTdHlsZXMoY29uZmlnKTtcclxuXHJcbiAgICAgIGlmcmFtZS5zcmMgPSB0aGlzLkNvbmZpZ3VyYXRpb24udXJsLmlmcmFtZTtcclxuICAgICAgLy8gaWZyYW1lLnNyYyA9IFwiaHR0cDovL2xvY2FsaG9zdDo0MjAxXCI7XHJcbiAgICAgIGlmcmFtZS5hbGxvdyA9ICdtaWNyb3Bob25lJztcclxuICAgICAgLy9cclxuICAgICAgLy8gQmluZCBkZWZhdWx0IHN0eWxlc1xyXG4gICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpZnJhbWUuc3R5bGVba2V5XSA9IHN0eWxlc1trZXldO1xyXG4gICAgICB9KTtcclxuICAgICAgLy9cclxuICAgICAgLy8gSWYgbm8gaWZyYW1lIHRocm93IGVycm9yXHJcbiAgICAgIGlmICghaWZyYW1lKVxyXG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICB0aGlzLlJlc3BvbnNlLmVycm9yKHtcclxuICAgICAgICAgICAgbWVzc2FnZTogXCJDYW4ndCBhZGQgYSBpZnJhbWUgdG8gZG9jdW1lbnQgYmVjYXVzZSB0aGVyZSdzIG5vIGVsZW1lbnRcIlxyXG4gICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgICAvL1xyXG4gICAgICAvLyAvLyBVcGRhdGUgZG9jdW1lbnQgYW5kIGFwcGVuZCBpZnJhbWVcclxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG5cclxuICAgICAgLy8gQUREIENMSUNLIEVWRU5UXHJcbiAgICAgIGRvY3VtZW50XHJcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoJ2NvZ251cy1jaGF0Ym90LWJ1dHRvbicpXHJcbiAgICAgICAgLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI2NvZ251cy1jaGF0Ym90X19idXR0b24nKVxyXG4gICAgICAgIC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbW91c2Vkb3duJykpO1xyXG5cclxuICAgICAgdGhpcy5QdWJTdWIub24oQVBQX0NPTlNUQU5UUy5FVkVOVFMuSUZSQU1FX0xPQURFRCwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuU3RhdGUuc2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkVMRU1FTlRfSUZSQU1FLCBpZnJhbWUuJGlmcmFtZSk7XHJcbiAgICAgICAgcmVzKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAjc2VuZFBvc3RiYWNrRXZlbnRzVG9JZnJhbWUoKSB7XHJcbiAgICBpZnJhbWVTZXR1cENsaWVudCh0aGlzLlN0YXRlKTtcclxuICAgIGlmcmFtZVNldHVwVXNlcih0aGlzLlN0YXRlKTtcclxuICAgIGlmcmFtZVNldE1vZHVsZUJ5SWQodGhpcy5TdGF0ZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW5kZXIoaWZyYW1lU2V0dXAgPSB7fSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFpbnN0YW5jaWF0ZWQpIHtcclxuICAgICAgICAvLyBCaW5kIHRoZSBpZnJhbWUgdG8gdGhlIGRvY3VtZW50XHJcbiAgICAgICAgYXdhaXQgdGhpcy4jYWRkSWZyYW1lVG9Eb2N1bWVudChpZnJhbWVTZXR1cCk7XHJcbiAgICAgICAgaW5zdGFuY2lhdGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLiNzZW5kUG9zdGJhY2tFdmVudHNUb0lmcmFtZSgpO1xyXG4gICAgICAvLyBCaW5kIEV2ZW50c1xyXG4gICAgICByZXR1cm4gdGhpcy5SZXNwb25zZS5vayh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0lGUkFNRV9SRU5ERVJfU1VDQ0VTUydcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICB0aHJvdyB0aGlzLlJlc3BvbnNlLmVycm9yKHsgbWVzc2FnZTogJ0lGUkFNRV9SRU5ERVJfRkFJTCcsIGRhdGE6IGV4IH0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSWZyYW1lO1xyXG4iLCJjb25zdCBURU1QTEFURSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XHJcblRFTVBMQVRFLmlubmVySFRNTCA9IGBcclxuPHN0eWxlPlxyXG4vKiEgQ1NTIFVzZWQgZnJvbTogaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9pY29uP2ZhbWlseT1NYXRlcmlhbCtJY29ucyAqLy5tYXRlcmlhbC1pY29uc3tmb250LWZhbWlseTonTWF0ZXJpYWwgSWNvbnMnO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbDtmb250LXNpemU6MjRweDtsaW5lLWhlaWdodDoxO2xldHRlci1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3doaXRlLXNwYWNlOm5vd3JhcDt3b3JkLXdyYXA6bm9ybWFsO2RpcmVjdGlvbjpsdHI7LXdlYmtpdC1mb250LWZlYXR1cmUtc2V0dGluZ3M6J2xpZ2EnOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWR9LyohIENTUyBVc2VkIGZyb206IGh0dHBzOi8vYmx1ZWRhcndpbi1jaGF0Ym90LWlmcmFtZS5ldS1kZS5teWJsdWVtaXgubmV0L2Fzc2V0cy9jaGF0Ym90LXVpLmNzcyAqLyNvcGVuLWNoYXQtYnV0dG9ue2JhY2tncm91bmQ6dXJsKGh0dHBzOi8vY29nbnVzLWNoYXRib3QtcHJvZC5ldS1kZS5teWJsdWVtaXgubmV0L2Fzc2V0cy9pbWFnZXMvbGluZS1pbi1tb3Rpb24uc3ZnKSwjMTY2YmU5O2JhY2tncm91bmQ6dXJsKGh0dHBzOi8vY29nbnVzLWNoYXRib3QtcHJvZC5ldS1kZS5teWJsdWVtaXgubmV0L2Fzc2V0cy9pbWFnZXMvbGluZS1pbi1tb3Rpb24uc3ZnKSwtbW96LWxpbmVhci1ncmFkaWVudCgtNDVkZWcsIzE2NmJlOSAxJSwjMDA0YWI1IDc3JSwjMDA0YWI1IDc3JSk7YmFja2dyb3VuZDp1cmwoaHR0cHM6Ly9jb2dudXMtY2hhdGJvdC1wcm9kLmV1LWRlLm15Ymx1ZW1peC5uZXQvYXNzZXRzL2ltYWdlcy9saW5lLWluLW1vdGlvbi5zdmcpLC13ZWJraXQtbGluZWFyLWdyYWRpZW50KC00NWRlZywjMTY2YmU5IDElLCMwMDRhYjUgNzclLCMwMDRhYjUgNzclKTtiYWNrZ3JvdW5kOnVybChodHRwczovL2NvZ251cy1jaGF0Ym90LXByb2QuZXUtZGUubXlibHVlbWl4Lm5ldC9hc3NldHMvaW1hZ2VzL2xpbmUtaW4tbW90aW9uLnN2ZyksbGluZWFyLWdyYWRpZW50KDEzNWRlZywjMTY2YmU5IDElLCMwMDRhYjUgNzclLCMwMDRhYjUgNzclKTttYXJnaW4tdG9wOjhweH0ubWRsLWJ1dHRvbi0tZmFiLm1kbC1idXR0b24tLWNvbG9yZWR7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCMxNjZiZTkgMSUsIzAwNGFiNSA3NyUsIzAwNGFiNSA3NyUpO2NvbG9yOiNmZmY7YmFja2dyb3VuZDp1cmwoaHR0cHM6Ly9jb2dudXMtY2hhdGJvdC1wcm9kLmV1LWRlLm15Ymx1ZW1peC5uZXQvYXNzZXRzL2ltYWdlcy9saW5lLWluLW1vdGlvbi5zdmcpLCMxNjZiZTk7YmFja2dyb3VuZDp1cmwoaHR0cHM6Ly9jb2dudXMtY2hhdGJvdC1wcm9kLmV1LWRlLm15Ymx1ZW1peC5uZXQvYXNzZXRzL2ltYWdlcy9saW5lLWluLW1vdGlvbi5zdmcpLC1tb3otbGluZWFyLWdyYWRpZW50KC00NWRlZywjMTY2YmU5IDElLCMwMDRhYjUgNzclLCMwMDRhYjUgNzclKTtiYWNrZ3JvdW5kOnVybChodHRwczovL2NvZ251cy1jaGF0Ym90LXByb2QuZXUtZGUubXlibHVlbWl4Lm5ldC9hc3NldHMvaW1hZ2VzL2xpbmUtaW4tbW90aW9uLnN2ZyksLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoLTQ1ZGVnLCMxNjZiZTkgMSUsIzAwNGFiNSA3NyUsIzAwNGFiNSA3NyUpO2JhY2tncm91bmQ6dXJsKGh0dHBzOi8vY29nbnVzLWNoYXRib3QtcHJvZC5ldS1kZS5teWJsdWVtaXgubmV0L2Fzc2V0cy9pbWFnZXMvbGluZS1pbi1tb3Rpb24uc3ZnKSxsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCMxNjZiZTkgMSUsIzAwNGFiNSA3NyUsIzAwNGFiNSA3NyUpfS5zbmlwcGV0LW9wZW4tY2hhdC1idXR0b257ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjEwcHg7bWFyZ2luLXRvcDoxMHB4fWJ1dHRvbnt0ZXh0LXRyYW5zZm9ybTppbml0aWFsIWltcG9ydGFudH0vKiEgQ1NTIFVzZWQgZnJvbTogaHR0cHM6Ly9ibHVlZGFyd2luLWNoYXRib3QtaWZyYW1lLmV1LWRlLm15Ymx1ZW1peC5uZXQvbWF0ZXJpYWwubWluLmNzcyAqLzo6LW1vei1zZWxlY3Rpb257YmFja2dyb3VuZDojYjNkNGZjO3RleHQtc2hhZG93Om5vbmV9OjpzZWxlY3Rpb257YmFja2dyb3VuZDojYjNkNGZjO3RleHQtc2hhZG93Om5vbmV9QG1lZGlhIHByaW50eyosOmFmdGVyLDpiZWZvcmUsOmZpcnN0LWxldHRlcntiYWNrZ3JvdW5kOjAgMCFpbXBvcnRhbnQ7Y29sb3I6IzAwMCFpbXBvcnRhbnQ7Ym94LXNoYWRvdzpub25lIWltcG9ydGFudH19Lm1kbC1idXR0b257LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjpyZ2JhKDI1NSwyNTUsMjU1LDApfS5tYXRlcmlhbC1pY29uc3tmb250LWZhbWlseTonTWF0ZXJpYWwgSWNvbnMnO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbDtmb250LXNpemU6MjRweDtsaW5lLWhlaWdodDoxO2xldHRlci1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dvcmQtd3JhcDpub3JtYWw7LW1vei1mb250LWZlYXR1cmUtc2V0dGluZ3M6J2xpZ2EnO2ZvbnQtZmVhdHVyZS1zZXR0aW5nczonbGlnYSc7LXdlYmtpdC1mb250LWZlYXR1cmUtc2V0dGluZ3M6J2xpZ2EnOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWR9Lm1kbC1idXR0b257YmFja2dyb3VuZDowIDA7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czoycHg7Y29sb3I6IzAwMDtwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MzZweDttYXJnaW46MDttaW4td2lkdGg6NjRweDtwYWRkaW5nOjAgMTZweDtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpSb2JvdG8sSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NTAwO3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZTtsZXR0ZXItc3BhY2luZzowO292ZXJmbG93OmhpZGRlbjt3aWxsLWNoYW5nZTpib3gtc2hhZG93O3RyYW5zaXRpb246Ym94LXNoYWRvdyAuMnMgY3ViaWMtYmV6aWVyKC40LDAsMSwxKSxiYWNrZ3JvdW5kLWNvbG9yIC4ycyBjdWJpYy1iZXppZXIoLjQsMCwuMiwxKSxjb2xvciAuMnMgY3ViaWMtYmV6aWVyKC40LDAsLjIsMSk7b3V0bGluZTowO2N1cnNvcjpwb2ludGVyO3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtYWxpZ246Y2VudGVyO2xpbmUtaGVpZ2h0OjM2cHg7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tZGwtYnV0dG9uOjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowfS5tZGwtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgxNTgsMTU4LDE1OCwuMil9Lm1kbC1idXR0b246YWN0aXZle2JhY2tncm91bmQtY29sb3I6cmdiYSgxNTgsMTU4LDE1OCwuNCl9Lm1kbC1idXR0b24ubWRsLWJ1dHRvbi0tY29sb3JlZHtjb2xvcjojM2Y1MWI1fS5tZGwtYnV0dG9uLS1mYWJ7Ym9yZGVyLXJhZGl1czo1MCU7Zm9udC1zaXplOjI0cHg7aGVpZ2h0OjU2cHg7bWFyZ2luOmF1dG87bWluLXdpZHRoOjU2cHg7d2lkdGg6NTZweDtwYWRkaW5nOjA7b3ZlcmZsb3c6aGlkZGVuO2JhY2tncm91bmQ6cmdiYSgxNTgsMTU4LDE1OCwuMik7Ym94LXNoYWRvdzowIDFweCAxLjVweCAwIHJnYmEoMCwwLDAsLjEyKSwwIDFweCAxcHggMCByZ2JhKDAsMCwwLC4yNCk7cG9zaXRpb246cmVsYXRpdmU7bGluZS1oZWlnaHQ6bm9ybWFsfS5tZGwtYnV0dG9uLS1mYWIgLm1hdGVyaWFsLWljb25ze3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKC0xMnB4LC0xMnB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlKC0xMnB4LC0xMnB4KTtsaW5lLWhlaWdodDoyNHB4O3dpZHRoOjI0cHh9Lm1kbC1idXR0b24tLWZhYjphY3RpdmV7Ym94LXNoYWRvdzowIDRweCA1cHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggMTBweCAwIHJnYmEoMCwwLDAsLjEyKSwwIDJweCA0cHggLTFweCByZ2JhKDAsMCwwLC4yKTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMTU4LDE1OCwxNTgsLjQpfS5tZGwtYnV0dG9uIC5tYXRlcmlhbC1pY29uc3t2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LyohIENTUyBVc2VkIGZyb206IGh0dHBzOi8vYmx1ZWRhcndpbi1jaGF0Ym90LWlmcmFtZS5ldS1kZS5teWJsdWVtaXgubmV0L2ZvbnRzLmNzcyAqLy5tYXRlcmlhbC1pY29uc3tmb250LWZhbWlseTonTWF0ZXJpYWwgSWNvbnMnO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbDtmb250LXNpemU6MjRweDtsaW5lLWhlaWdodDoxO2xldHRlci1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3doaXRlLXNwYWNlOm5vd3JhcDt3b3JkLXdyYXA6bm9ybWFsO2RpcmVjdGlvbjpsdHI7LXdlYmtpdC1mb250LWZlYXR1cmUtc2V0dGluZ3M6J2xpZ2EnOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWR9XHJcblxyXG5pZnJhbWV7ZGlzcGxheTpub25lOyBib3JkZXI6IG5vbmU7d2lkdGg6IDM1MHB4O2hlaWdodDogNjkwcHg7IG1heC1oZWlnaHQ6IDEwMCU7ICBwb3NpdGlvbjphYnNvbHV0ZTsgcmlnaHQ6NHB4OyBib3R0b206IDA7fVxyXG4ubWRsLWJ1dHRvbi5tZGwtanMtYnV0dG9uLm1kbC1idXR0b24tLWZhYi5tZGwtYnV0dG9uLS1jb2xvcmVkLnNuaXBwZXQtb3Blbi1jaGF0LWJ1dHRvbntib3gtc2hhZG93OiAwIDNweCAxMHB4IHJnYmEoMCwwLDAsMC4xNSl9XHJcbiNjb2dudXMtY2hhdGJvdF9fY29udGFpbmVye1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgaGVpZ2h0OiAwO1xyXG4gICAgd2lkdGg6IDA7XHJcbiAgICBmbG9hdDogcmlnaHQ7XHJcbn1cclxuXHJcbmNvZ251cy1jaGF0Ym90LWJ1dHRvbntcclxuICB3aWR0aDogMHB4O1xyXG4gIGhlaWdodDogMHB4O1xyXG59XHJcblxyXG48L3N0eWxlPlxyXG48ZGl2IGlkPVwiY29nbnVzLWNoYXRib3RfX2NvbnRhaW5lclwiPlxyXG48aWZyYW1lIGNsYXNzPVwiY2xvc2VkXCIgaWQ9XCJjb2dudXMtY2hhdGJvdF9faWZyYW1lXCIgYWxsb3c9XCJtaWNyb3Bob25lXCI+PC9pZnJhbWU+XHJcbjxidXR0b24gaWQ9XCJjb2dudXMtY2hhdGJvdF9fYnV0dG9uXCIgIGNsYXNzPVwibWRsLWJ1dHRvbiBtZGwtanMtYnV0dG9uXHJcbiAgICAgICAgICAgICAgbWRsLWJ1dHRvbi0tZmFiXHJcbiAgICAgICAgICAgICAgbWRsLWJ1dHRvbi0tY29sb3JlZFxyXG4gICAgICAgICAgICAgIHNuaXBwZXQtb3Blbi1jaGF0LWJ1dHRvblwiICBkYXRhLXVwZ3JhZGVkPVwiLE1hdGVyaWFsQnV0dG9uXCI+XHJcblxyXG48aSBpZD1cImNvZ251cy1jaGF0Ym90X19pY29uLWNsb3NlXCIgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPlxyXG4gIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgIDxwYXRoIGZpbGw9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMFYwelwiLz5cclxuICAgIDxwYXRoIGZpbGw9XCJ3aGl0ZVwiIGQ9XCJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyIDE5IDYuNDF6XCIvPjwvc3ZnPlxyXG48L2k+XHJcbjxpIGlkPVwiY29nbnVzLWNoYXRib3RfX2ljb24tb3BlblwiIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5cclxuICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgIDxwYXRoIGZpbGw9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMFYwelwiLz5cclxuICAgIDxwYXRoIGZpbGw9XCJ3aGl0ZVwiIGQ9XCJNMjIgMkgydjIwbDQtNGgxNlYyelwiLz48L3N2Zz5cclxuPC9pPlxyXG48L2J1dHRvbj5cclxuPC9kaXY+XHJcbmA7XHJcbmV4cG9ydCBkZWZhdWx0IFRFTVBMQVRFO1xyXG4iLCIvLyBpZiAoIU9iamVjdC5wcm90b3R5cGUuZXh0ZW5kRGVmYXVsdCkge1xyXG4vLyAgIE9iamVjdC5wcm90b3R5cGUuZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbihkZWZhdWx0cykge1xyXG4vLyAgICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goa2V5ID0+IHtcclxuLy8gICAgICAgaWYgKCF0aGlzW2tleV0pIHRoaXNba2V5XSA9IGRlZmF1bHRzW2tleV07XHJcbi8vICAgICB9KTtcclxuLy8gICB9O1xyXG4vLyAgIHJldHVybiB0aGlzO1xyXG4vLyB9XHJcblxyXG4vLyBOb3RlLCB0aGlzIGlzIG5vdCBhIHByb3RvdHlwZSB5ZXQgYnV0IHdpbGwgYmUgaW4gZnV0dXJlXHJcbmNvbnN0IGV4dGVuZENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbihvYmosIGNvbmZpZ3VyYXRpb24pIHtcclxuICBPYmplY3Qua2V5cyhjb25maWd1cmF0aW9uKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICBpZiAoIW9ialtrZXldKSBvYmpba2V5XSA9IGNvbmZpZ3VyYXRpb25ba2V5XTtcclxuICB9KTtcclxuICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZXh0ZW5kQ29uZmlndXJhdGlvbjtcclxuIiwiaW1wb3J0IGV4dGVuZENvbmZpZ3VyYXRpb24gZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvcHJvdG90eXBlcy9leHRlbmQtY29uZmlndXJhdGlvblwiO1xyXG5cclxuY29uc3QgQ09ORklHID0ge1xyXG4gIGRpc3BsYXk6IFwiYmxvY2tcIixcclxuICB0aW1lOiBcIjAuNHNcIixcclxuICBkZWxheTogMFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmFkZUluKCRlbCwgY29uZmlnID0ge30pIHtcclxuICBjb25maWcgPSBleHRlbmRDb25maWd1cmF0aW9uKGNvbmZpZywgQ09ORklHKTtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAkZWwuc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgJGVsLnN0eWxlLmRpc3BsYXkgPSBjb25maWcuZGlzcGxheTtcclxuXHJcbiAgICAgICAgJGVsLnN0eWxlLldlYmtpdFRyYW5zaXRpb24gPSBgb3BhY2l0eSAke2NvbmZpZy50aW1lfWA7XHJcbiAgICAgICAgJGVsLnN0eWxlLk1velRyYW5zaXRpb24gPSBgb3BhY2l0eSAke2NvbmZpZy50aW1lfWA7XHJcblxyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiAoJGVsLnN0eWxlLm9wYWNpdHkgPSAxKSk7XHJcbiAgICAgICAgcmVzKCk7XHJcbiAgICAgIH0sIGNvbmZpZy5kZWxheSk7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICByZWooZXgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiIsImltcG9ydCBleHRlbmRDb25maWd1cmF0aW9uIGZyb20gXCJCbHVlRGFyd2luSlMvc3JjL3Byb3RvdHlwZXMvZXh0ZW5kLWNvbmZpZ3VyYXRpb25cIjtcclxuXHJcbmNvbnN0IENPTkZJRyA9IHtcclxuICB0aW1lOiBcIjAuNHNcIixcclxuICBkZWxheTogMFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmFkZU91dCgkZWwsIGNvbmZpZyA9IHt9KSB7XHJcbiAgY29uZmlnID0gZXh0ZW5kQ29uZmlndXJhdGlvbihjb25maWcsIENPTkZJRyk7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgJGVsLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG5cclxuICAgICAgICAkZWwuc3R5bGUuV2Via2l0VHJhbnNpdGlvbiA9IGBvcGFjaXR5ICR7Y29uZmlnLnRpbWV9YDtcclxuICAgICAgICAkZWwuc3R5bGUuTW96VHJhbnNpdGlvbiA9IGBvcGFjaXR5ICR7Y29uZmlnLnRpbWV9YDtcclxuXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+ICgkZWwuc3R5bGUub3BhY2l0eSA9IDApKTtcclxuICAgICAgICByZXMoKTtcclxuICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICByZWooZXgpO1xyXG4gICAgICB9XHJcbiAgICB9LCBjb25maWcuZGVsYXkpO1xyXG4gIH0pO1xyXG59XHJcbiIsImltcG9ydCBBUFBfQ09OU1RBTlRTIGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XHJcbmltcG9ydCBURU1QTEFURSBmcm9tICcuL3RlbXBsYXRlcy9jb2dudXMtY2hhdGJvdC1idXR0b24nO1xyXG5pbXBvcnQgZmFkZUluIGZyb20gJy4uL2FuaW1hdGlvbnMvZmFkZS1pbic7XHJcbmltcG9ydCBmYWRlT3V0IGZyb20gJy4uL2FuaW1hdGlvbnMvZmFkZS1vdXQnO1xyXG5pbXBvcnQgUHViU3ViIGZyb20gJ0JsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvcHViLXN1Yic7XHJcbmltcG9ydCBQb3N0TWVzc2FnZSBmcm9tICdCbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvcG9zdC1tZXNzYWdlJztcclxuY29uc3QgZXZlbnRMaXN0ZW5lckVsZW1lbnRzID0gW1xyXG4gIC8vIHsgaWQ6IFwiJGJ1dHRvblwiLCBhY3Rpb246IFwiaGFuZGxlQ2xpY2tcIiwgdHlwZTogXCJjbGlja1wiIH0sXHJcbiAgeyBpZDogJyRidXR0b24nLCBhY3Rpb246ICdzdGFydEJ1dHRvblByZXNzJywgdHlwZTogJ21vdXNlZG93bicgfSxcclxuICB7IGlkOiAnJGJ1dHRvbicsIGFjdGlvbjogJ2VuZEJ1dHRvblByZXNzJywgdHlwZTogJ21vdXNldXAnIH0sXHJcbiAgeyBpZDogJyRpZnJhbWUnLCBhY3Rpb246ICdicm9hZGNhc3RJZnJhbWVMb2FkZWQnLCB0eXBlOiAnbG9hZCcgfVxyXG5dO1xyXG5cclxuY29uc3QgQU5JTUFUSU9OUyA9IHtcclxuICBJRlJBTUVfT1BFTl9BRlRFUjogMCxcclxuICBJRlJBTUVfQ0xPU0VfQUZURVI6IDAsIC8vIDEwMDAwXHJcbiAgSUNPTl9UUkFOU0lUSU9OOiAwLCAvLyA0MDBcclxuICBJQ09OX1RSQU5TSVRJT05fREVMQVk6IDAgLy8gMzAwXHJcbn07XHJcblxyXG5jb25zdCBMT05HUFJFU1MgPSAwOyAvLyAxMDBcclxuXHJcbmxldCBwdWJTdWI7XHJcblxyXG5jbGFzcyBDb2dudXNDaGF0Ym90QnV0dG9uIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xyXG4gIGlzTG9ja2VkID0gZmFsc2U7XHJcbiAgaXNDaGF0Ym90V2luZG93T3BlbiA9IGZhbHNlO1xyXG4gIGRlbGF5ID0gMDtcclxuICBpc0J1dHRvblByZXNzZWQgPSBmYWxzZTtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8vIGFsd2F5cyBjYWxsIHN1cGVyKCkgZmlyc3RcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XHJcbiAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFRFTVBMQVRFLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciBhY3Rpb25zXHJcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5zdGFydEJ1dHRvblByZXNzID0gdGhpcy5zdGFydEJ1dHRvblByZXNzLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmVuZEJ1dHRvblByZXNzID0gdGhpcy5lbmRCdXR0b25QcmVzcy5iaW5kKHRoaXMpO1xyXG4gICAgLy8gZGVmaW5lIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBnb2luZyB0byBiZSB1c2VkXHJcbiAgICB0aGlzLiRjb250YWluZXIgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFxyXG4gICAgICAnY29nbnVzLWNoYXRib3RfX2NvbnRhaW5lcidcclxuICAgICk7XHJcbiAgICB0aGlzLiRidXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjb2dudXMtY2hhdGJvdF9fYnV0dG9uJyk7XHJcbiAgICB0aGlzLiRpZnJhbWUgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjb2dudXMtY2hhdGJvdF9faWZyYW1lJyk7XHJcbiAgICB0aGlzLiRpY29uQ2xvc2UgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFxyXG4gICAgICAnY29nbnVzLWNoYXRib3RfX2ljb24tY2xvc2UnXHJcbiAgICApO1xyXG4gICAgdGhpcy4kaWNvbk9wZW4gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFxyXG4gICAgICAnY29nbnVzLWNoYXRib3RfX2ljb24tb3BlbidcclxuICAgICk7XHJcblxyXG4gICAgcHViU3ViID0gbmV3IFB1YlN1YigpO1xyXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgaGFuZGxlQ2xpY2soKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodGhpcy5pc0xvY2tlZCkgcmV0dXJuO1xyXG4gICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcclxuICAgICAgaWYgKHRoaXMuaXNDaGF0Ym90V2luZG93T3Blbikge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2VDaGF0Ym90V2luZG93KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5vcGVuQ2hhdGJvdFdpbmRvdygpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihleCk7XHJcbiAgICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNsb3NlQ2hhdGJvdFdpbmRvdygpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcclxuICAgICAgUG9zdE1lc3NhZ2Uuc2VuZCgnY2xvc2VDaGF0Ym90V2luZG93Jyk7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuaXNDaGF0Ym90V2luZG93T3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIHJlcygpO1xyXG4gICAgICB9LCBBTklNQVRJT05TLklDT05fVFJBTlNJVElPTik7XHJcblxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLiRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgfSwgQU5JTUFUSU9OUy5JRlJBTUVfQ0xPU0VfQUZURVIpO1xyXG5cclxuICAgICAgZmFkZUluKHRoaXMuJGljb25PcGVuLCB7IGRlbGF5OiBBTklNQVRJT05TLklDT05fVFJBTlNJVElPTl9ERUxBWSB9KTtcclxuICAgICAgZmFkZU91dCh0aGlzLiRpY29uQ2xvc2UpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBvcGVuQ2hhdGJvdFdpbmRvdygpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcclxuICAgICAgdGhpcy4kaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICBQb3N0TWVzc2FnZS5zZW5kKCdvcGVuQ2hhdGJvdFdpbmRvdycpO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLmlzQ2hhdGJvdFdpbmRvd09wZW4gPSB0cnVlO1xyXG4gICAgICAgIHJlcygpO1xyXG4gICAgICB9LCBBTklNQVRJT05TLklDT05fVFJBTlNJVElPTik7XHJcblxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLmlzQ2hhdGJvdFdpbmRvd09wZW4gPSB0cnVlO1xyXG4gICAgICAgIHJlcygpO1xyXG4gICAgICB9LCBBTklNQVRJT05TLklGUkFNRV9PUEVOX0FGVEVSKTtcclxuXHJcbiAgICAgIGZhZGVJbih0aGlzLiRpY29uQ2xvc2UsIHsgZGVsYXk6IEFOSU1BVElPTlMuSUNPTl9UUkFOU0lUSU9OX0RFTEFZIH0pO1xyXG4gICAgICBmYWRlT3V0KHRoaXMuJGljb25PcGVuKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYnJvYWRjYXN0SWZyYW1lTG9hZGVkKCkge1xyXG4gICAgcHViU3ViLmVtaXQoQVBQX0NPTlNUQU5UUy5FVkVOVFMuSUZSQU1FX0xPQURFRCk7XHJcbiAgfVxyXG4gIC8vIE9CU0VSVkVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xyXG4gICAgcmV0dXJuIFsnc3JjJ107XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgY2FzZSAnc3JjJzpcclxuICAgICAgICB0aGlzLiRpZnJhbWUuc3JjID0gbmV3VmFsdWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGFydEJ1dHRvblByZXNzKCkge1xyXG4gICAgdGhpcy5oYW5kbGVDbGljaygpO1xyXG4gICAgLypcclxuICAgIHRoaXMuaXNCdXR0b25QcmVzc2VkID0gdHJ1ZTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5pc0J1dHRvblByZXNzZWQpIHtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKCk7XHJcbiAgICAgIH1cclxuICAgIH0sIExPTkdQUkVTUyk7XHJcbiAgICAqL1xyXG4gIH1cclxuXHJcbiAgZW5kQnV0dG9uUHJlc3MoZSkge1xyXG4gICAgdGhpcy5pc0J1dHRvblByZXNzZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEdFVFRFUlMgLyBTRVRURVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICBnZXQgc3JjKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzcmMnKTtcclxuICB9XHJcblxyXG4gIHNldCBzcmMobmV3VmFsdWUpIHtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLCBuZXdWYWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvLyBFVkVOVCBMSVNURU5FUlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICBhZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgIC8vIGRlZmluZSBldmVudCBsaXN0ZW5lcnNcclxuICAgIGV2ZW50TGlzdGVuZXJFbGVtZW50cy5mb3JFYWNoKCRlbCA9PiB7XHJcbiAgICAgIHRoaXNbJGVsLmlkXS5hZGRFdmVudExpc3RlbmVyKCRlbC50eXBlLCB0aGlzWyRlbC5hY3Rpb25dKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyByZW1vdmVFdmVudExpc3RlbmVycygpIHtcclxuICAvLyAgIC8vIGRlZmluZSBldmVudCBsaXN0ZW5lcnNcclxuICAvLyAgIGV2ZW50TGlzdGVuZXJFbGVtZW50cy5mb3JFYWNoKCRlbCA9PiB7XHJcbiAgLy8gICAgIHRoaXNbJGVsLmlkXS5yZW1vdmVFdmVudExpc3RlbmVyKCRlbC50eXBlLCB0aGlzWyRlbC5hY3Rpb25dKTtcclxuICAvLyAgIH0pO1xyXG4gIC8vIH1cclxuXHJcbiAgLy8gTElGRUNZQ0xFXHJcbiAgLy8gZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XHJcbiAgLy8gICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgLy8gfVxyXG59XHJcblxyXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjb2dudXMtY2hhdGJvdC1idXR0b24nLCBDb2dudXNDaGF0Ym90QnV0dG9uKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvZ251c0NoYXRib3RCdXR0b247XHJcbiIsIi8vIGltcG9ydCBcImlkZW1wb3RlbnQtYmFiZWwtcG9seWZpbGxcIjtcclxuLy8gaW1wb3J0IFwiLi4vcG9seWZpbGxzL3dlYi1jb21wb25lbnRzXCI7XHJcblxyXG5pbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XHJcbmltcG9ydCBDaGF0Ym90IGZyb20gXCIuLi9jaGF0Ym90XCI7XHJcbmltcG9ydCBJZnJhbWUgZnJvbSBcIi4uL3V0aWxzL2lmcmFtZVwiO1xyXG5cclxuaW1wb3J0IFBvc3RNZXNzYWdlIGZyb20gXCJCbHVlRGFyd2luSlMvc3JjL2hlbHBlcnMvcG9zdC1tZXNzYWdlXCI7XHJcbmltcG9ydCBDb2dudXNDaGF0Ym90QnV0dG9uIGZyb20gXCIuLi9kb20vY3VzdG9tLWVsZW1lbnRzL2NvZ251cy1jaGF0Ym90LWJ1dHRvblwiO1xyXG5cclxuY2xhc3MgaUZyYW1lIGV4dGVuZHMgQ2hhdGJvdCB7XHJcbiAgI29wdGlvbnMgPSB7fTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcm9qZWN0LFxyXG4gICAgYXBpS2V5LFxyXG4gICAgYW1Nb2R1bGUsXHJcbiAgICBjb25maWcgPSB7XHJcbiAgICAgIGNoYXRib3RVc2VyOiB1bmRlZmluZWRcclxuICAgIH1cclxuICApIHtcclxuICAgIC8vIFN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVuZGVyKGlmcmFtZVNldHVwID0ge30pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2V0dXAoKTtcclxuXHJcbiAgICAgIHRoaXMuI29wdGlvbnMgPSB0aGlzLiNvcHRpb25zIHx8IGlmcmFtZVNldHVwO1xyXG5cclxuICAgICAgdGhpcy5TdGF0ZS5zZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuSVNfSU5JVElBTElaRUQsIHRydWUpO1xyXG5cclxuICAgICAgLy8gSWYgbm90IGxvZ2dlZCB3YWl0cyBmb3IgbG9naW4gdG8gdHJpZ2dlciBiZWZvcmUgcmVuZGVyaW5nIGFuZCBpbnN0YW5jaWF0aW5nIGlmcmFtZVxyXG4gICAgICBpZiAoIXRoaXMuU3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLklTX0xPR0dFRF9JTikpIHtcclxuICAgICAgICBjb25zdCByZWplY3Rpb24gPSB0aGlzLlJlc3BvbnNlLm9rKHtcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiQ2hhdGJvdCBpZnJhbWUgaW5pdDogV2FpdGluZyBmb3IgbG9naW5cIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWplY3Rpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW5kZXIgdGhlIGlmcmFtZVxyXG4gICAgICBuZXcgSWZyYW1lKHRoaXMuY29uZmlnKS5yZW5kZXIoaWZyYW1lU2V0dXApO1xyXG5cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuUmVzcG9uc2UuZXJyb3IoeyBkYXRhOiBleCB9KSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsaXN0RGVmYXVsdFN0eWxlcygpIHtcclxuICAgIHJldHVybiBBUFBfQ09OU1RBTlRTLkRFRkFVTFRTLklGUkFNRV9DU1M7XHJcbiAgfVxyXG5cclxuICBnZXRJZnJhbWVFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuU3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkVMRU1FTlRfSUZSQU1FKTtcclxuICB9XHJcblxyXG4gIGV2ZW50cyA9IHtcclxuICAgIG9uOiBQb3N0TWVzc2FnZS5yZWNpZXZlLFxyXG4gICAgZW1pdDogUG9zdE1lc3NhZ2Uuc2VuZFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlGcmFtZTtcclxuIiwiY29uc3QgQ2hhdGJvdFVzZXJNb2RlbCA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIFBhcmFtZXRyb3MgZGVmYXVsdCBkZXN0ZSBtb2RlbG9cclxuICBjb25zdCBtb2RlbCA9IHtcclxuICAgIGF2YXRhcjogdW5kZWZpbmVkLFxyXG4gICAgbmFtZTogdW5kZWZpbmVkXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG1vZGVsKTtcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgIENoYXRib3RVc2VyTW9kZWw7XHJcbiIsIi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBuZXcgY2hhdGJvdCB1c2VyXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gdXNlcm5hbWUgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfENoYXRib3RVc2VyTW9kZWx9ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKi9cclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5cclxuY29uc3Qgc2V0Q2hhdGJvdFVzZXJOYW1lID0gZnVuY3Rpb24oaWQsIHVzZXJuYW1lLCBodHRwID0gbmV3IEh0dHAoKSkge1xyXG4gIHJldHVybiBodHRwLnBvc3QoYGFtX2NsaWVudF91c2Vycy8ke2lkfWAsIHtcclxuICAgIHVzZXJfc2V0dGluZ3M6IHtcclxuICAgICAgdXNlcm5hbWVcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNldENoYXRib3RVc2VyTmFtZTtcclxuIiwiLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG5ldyBjaGF0Ym90IHVzZXJcclxuICogQHBhcmFtICB7U3RyaW5nfSB1c2VybmFtZSBbZGVzY3JpcHRpb25dXHJcbiAqIEByZXR1cm4ge1Byb21pc2V8Q2hhdGJvdFVzZXJNb2RlbH0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG5pbXBvcnQgSHR0cCBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9odHRwXCI7XHJcblxyXG5jb25zdCBzZXRDaGF0Ym90VXNlckF2YXRhciA9IGZ1bmN0aW9uKGlkLCB1c2VybmFtZSwgaHR0cCA9IG5ldyBIdHRwKCkpIHtcclxuICByZXR1cm4gaHR0cC5wb3N0KGBhbV9jbGllbnRfdXNlcnMvJHtpZH1gLCB7XHJcbiAgICB1c2VyX3NldHRpbmdzOiB7XHJcbiAgICAgIGF2YXRhclxyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2V0Q2hhdGJvdFVzZXJBdmF0YXI7XHJcbiIsImltcG9ydCBDaGF0Ym90VXNlck1vZGVsIGZyb20gJy4uL21vZGVscy9jaGF0Ym90LXVzZXInO1xyXG5pbXBvcnQgc2V0Q2hhdGJvdFVzZXJOYW1lIGZyb20gJy4uL2hlbHBlcnMvcmVzdC1hcGkvc2V0LWNoYXRib3QtdXNlci1uYW1lJztcclxuaW1wb3J0IHNldENoYXRib3RVc2VyQXZhdGFyIGZyb20gJy4uL2hlbHBlcnMvcmVzdC1hcGkvc2V0LWNoYXRib3QtdXNlci1hdmF0YXInO1xyXG5pbXBvcnQgSHR0cCBmcm9tICdCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2h0dHAnO1xyXG5pbXBvcnQgaW5qZWN0RGVwZW5kZW5jaWVzIGZyb20gJ0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9kZXBlbmRlbmNpZXMvaW5qZWN0LWRlcGVuZGVuY2llcyc7XHJcblxyXG5jb25zdCBNb2RlbCA9IENoYXRib3RVc2VyTW9kZWwoKTtcclxuTW9kZWwuaWQgPSBmYWxzZTtcclxuXHJcbmNsYXNzIENiVXNlciB7XHJcbiAgI21ldGEgPSBNb2RlbDtcclxuXHJcbiAgY29uc3RydWN0b3IobW9kZWwpIHtcclxuICAgIHRoaXMuI21ldGEgPSBtb2RlbDtcclxuICAgIGluamVjdERlcGVuZGVuY2llcyhbSHR0cF0sIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGlkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI21ldGEuaWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgbmFtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLiNtZXRhLnVzZXJfc2V0dGluZ3MudXNlcm5hbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgYXZhdGFyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI21ldGEudXNlcl9zZXR0aW5ncy5hdmF0YXI7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZXROYW1lKG5hbWUpIHtcclxuICAgIGNvbnN0IHJvbGxiYWNrID0gdGhpcy4jbWV0YS51c2VyX3NldHRpbmdzLnVzZXJuYW1lO1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy4jbWV0YS51c2VyX3NldHRpbmdzLnVzZXJuYW1lID0gbmFtZTtcclxuICAgICAgYXdhaXQgc2V0Q2hhdGJvdFVzZXJOYW1lKHRoaXMuI21ldGEuaWQsIG5hbWUsIHRoaXMuSHR0cCk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmFtZSk7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICB0aGlzLiNtZXRhLnVzZXJfc2V0dGluZ3MudXNlcm5hbWUgPSByb2xsYmFjaztcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJvbGxiYWNrKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHNldEF2YXRhcihhdmF0YXIpIHtcclxuICAgIGNvbnN0IHJvbGxiYWNrID0gdGhpcy4jbWV0YS51c2VyX3NldHRpbmdzLmF2YXRhcjtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuI21ldGEudXNlcl9zZXR0aW5ncy5hdmF0YXIgPSBhdmF0YXI7XHJcbiAgICAgIGF3YWl0IHNldENoYXRib3RVc2VyQXZhdGFyKHRoaXMuI21ldGEuaWQsIGF2YXRhciwgdGhpcy5IdHRwKTtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhdmF0YXIpO1xyXG4gICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgdGhpcy4jbWV0YS51c2VyX3NldHRpbmdzLmF2YXRhciA9IHJvbGxiYWNrO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qocm9sbGJhY2spO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2JVc2VyO1xyXG4iLCJpbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XHJcbmltcG9ydCBTdGF0ZSBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9zdGF0ZVwiO1xyXG5pbXBvcnQgSHR0cCBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9odHRwXCI7XHJcblxyXG5jb25zdCBfYnVpbGRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0YXRlID0gbmV3IFN0YXRlKCkpIHtcclxuICBsZXQgdXJsU3RyID0gXCJcIjtcclxuXHJcbiAgY29uc3QgcGFyYW1zID0ge1xyXG4gICAgYW1fdXNlcjogMTIzMjMsIC8vU3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19DSEFUQk9UX1VTRVIpLFxyXG4gICAgc3RhZ2U6XHJcbiAgICAgIEFQUF9DT05TVEFOVFMuRU5WSVJPTk1FTlRfSURTW1xyXG4gICAgICAgIHN0YXRlLmdldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5FTlZJUk9OTUVOVClcclxuICAgICAgXSxcclxuICAgIHByb2plY3Q6IHN0YXRlLmdldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfUFJPSkVDVCksXHJcbiAgICBzdGF0dXM6IFwib3BlblwiXHJcbiAgfTtcclxuXHJcbiAgLy8gQWRkIHRoZSBwYXJhbXMgdG8gdGhlIHN0cmluZztcclxuICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGlmIChwYXJhbXNba2V5XSkge1xyXG4gICAgICB1cmxTdHIgKz0gYCYke2tleX09JHtwYXJhbXNba2V5XX1gO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBSZW1vdmUgdGhlIGZpcnN0IC8gZnJvbSB0aGUgdXJsXHJcbiAgdXJsU3RyID0gdXJsU3RyLnN1YnN0cigxKTtcclxuXHJcbiAgLy8gQWRkIHF1ZXN0aW9ubWFyayBpZiBzdHJpbmcgZXhpc3RzXHJcbiAgdXJsU3RyID0gdXJsU3RyLmxlbmd0aCA+IDAgPyBcIj9cIi5jb25jYXQodXJsU3RyKSA6IHVybFN0cjtcclxuXHJcbiAgcmV0dXJuIHVybFN0cjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBbZGVzY3JpcHRpb25dXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKi9cclxuY29uc3QgZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uKGh0dHAgPSBuZXcgSHR0cCgpKSB7XHJcbiAgcmV0dXJuIGh0dHAuZ2V0KGBhbV9zZXNzaW9ucyR7X2J1aWxkUXVlcnlTdHJpbmcoKX1gKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldFNlc3Npb247XHJcbiIsIi8qXHJcbmNvbnN0IGdldFNlc3Npb24gPSByZXF1aXJlKFwiLi9nZXQtc2Vzc2lvblwiKTtcclxuY29uc3QgY3JlYXRlU2Vzc2lvbiA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1zZXNzaW9uXCIpO1xyXG5jb25zdCBSZXNwb25zZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9yZXNwb25zZVwiKTtcclxuKi9cclxuXHJcbmltcG9ydCBSZXNwb25zZSBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9yZXNwb25zZVwiO1xyXG5pbXBvcnQgZ2V0U2Vzc2lvbiBmcm9tIFwiLi9nZXQtc2Vzc2lvblwiO1xyXG5cclxuY29uc3QgZ2V0T3JDcmVhdGVDaGF0Ym90U2Vzc2lvbiA9IGFzeW5jIGZ1bmN0aW9uKHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKCkpIHtcclxuICB0cnkge1xyXG4gICAgbGV0IHNlc3Npb24gPSBhd2FpdCBnZXRTZXNzaW9uKCk7XHJcblxyXG4gICAgaWYgKCFzZXNzaW9uIHx8IDAgPT09IHNlc3Npb24ubGVuZ3RoKSB7XHJcbiAgICAgIHNlc3Npb24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2Vzc2lvblswXTtcclxuICB9IGNhdGNoIChleCkge1xyXG4gICAgdGhyb3cgUmVzcG9uc2UuZXJyb3IoeyBtZXNzYWdlOiBcIkVSUk9SLkdFVF9PUl9DUkVBVEVfU0VTU0lPTlwiLCBkYXRhOiBleCB9KTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRPckNyZWF0ZUNoYXRib3RTZXNzaW9uO1xyXG4iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvc3RhdGVcIjtcclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5cclxuaW1wb3J0IHNldE9yY2hlc3RyYXRvclBheWxvYWQgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9zZXQtb3JjaGVzdHJhdG9yLXBheWxvYWRcIjtcclxuXHJcbmNvbnN0IHNlbmRUZXh0ID0gZnVuY3Rpb24odGV4dCwgaHR0cCA9IG5ldyBIdHRwKCksIHN0YXRlID0gbmV3IFN0YXRlKCkpIHtcclxuICByZXR1cm4gaHR0cC5wb3N0KFxyXG4gICAgXCJvcmNoZXN0cmF0b3JfdjNcIixcclxuICAgIHNldE9yY2hlc3RyYXRvclBheWxvYWQudjMudGV4dCh0ZXh0LCBzdGF0ZSlcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2VuZFRleHQ7XHJcbiIsImltcG9ydCBTdGF0ZSBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9zdGF0ZVwiO1xyXG5pbXBvcnQgSHR0cCBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9odHRwXCI7XHJcblxyXG5pbXBvcnQgc2V0T3JjaGVzdHJhdG9yUGF5bG9hZCBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL3NldC1vcmNoZXN0cmF0b3ItcGF5bG9hZFwiO1xyXG5cclxuY29uc3Qgc2VuZFZvaWNlID0gZnVuY3Rpb24odm9pY2UsIGh0dHAgPSBuZXcgSHR0cCgpLCBzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgcmV0dXJuIGh0dHAucG9zdChcclxuICAgIFwib3JjaGVzdHJhdG9yX3YzXCIsXHJcbiAgICBzZXRPcmNoZXN0cmF0b3JQYXlsb2FkLnYzLnZvaWNlKHZvaWNlLCBzdGF0ZSlcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2VuZFZvaWNlO1xyXG4iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvc3RhdGVcIjtcclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5cclxuaW1wb3J0IHNldE9yY2hlc3RyYXRvclBheWxvYWQgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9zZXQtb3JjaGVzdHJhdG9yLXBheWxvYWRcIjtcclxuXHJcbmNvbnN0IHNlbmRQb3N0QmFjayA9IGZ1bmN0aW9uKFxyXG4gIHBvc3RiYWNrLFxyXG4gIGh0dHAgPSBuZXcgSHR0cCgpLFxyXG4gIHN0YXRlID0gbmV3IFN0YXRlKClcclxuKSB7XHJcbiAgcmV0dXJuIGh0dHAucG9zdChcclxuICAgIFwib3JjaGVzdHJhdG9yX3YzXCIsXHJcbiAgICBzZXRPcmNoZXN0cmF0b3JQYXlsb2FkLnYzLnBvc3RCYWNrKHBvc3RiYWNrLCBzdGF0ZSlcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2VuZFBvc3RCYWNrO1xyXG4iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvc3RhdGVcIjtcclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5cclxuaW1wb3J0IHNldE9yY2hlc3RyYXRvclBheWxvYWQgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9zZXQtb3JjaGVzdHJhdG9yLXBheWxvYWRcIjtcclxuXHJcbmNvbnN0IHNlbmRTdGFydENvbnZlcnNhdGlvbiA9IGZ1bmN0aW9uKGh0dHAgPSBuZXcgSHR0cCgpLCBzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgY29uc3QgcGF5bG9hZCA9IHNldE9yY2hlc3RyYXRvclBheWxvYWQudjMudGV4dChcIm9sw6FcIiwgc3RhdGUpO1xyXG5cclxuICBwYXlsb2FkLmNvbnRleHRfdmFyaWFibGVzID0gcGF5bG9hZC5jb250ZXh0X3ZhcmlhYmxlcyB8fCB7fTtcclxuICBwYXlsb2FkLmNvbnRleHRfdmFyaWFibGVzLmFjdGlvbnMgPSBwYXlsb2FkLmNvbnRleHRfdmFyaWFibGVzLmFjdGlvbnMgfHwge307XHJcbiAgcGF5bG9hZC5jb250ZXh0X3ZhcmlhYmxlcy5hY3Rpb25zLmNsb3NlX3Nlc3Npb24gPVxyXG4gICAgcGF5bG9hZC5jb250ZXh0X3ZhcmlhYmxlcy5hY3Rpb25zLmNsb3NlX3Nlc3Npb24gfHwge307XHJcbiAgcGF5bG9hZC5jb250ZXh0X3ZhcmlhYmxlcy5hY3Rpb25zLmNsb3NlX3Nlc3Npb24uZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gIGRlbGV0ZSBwYXlsb2FkLmlucHV0O1xyXG4gIGRlbGV0ZSBwYXlsb2FkLmF1dGguc3RhZ2U7XHJcbiAgZGVsZXRlIHBheWxvYWQuY29udGV4dF92YXJpYWJsZXMuZXh0cmFjdGVkX2VudGl0aWVzO1xyXG5cclxuICByZXR1cm4gaHR0cC5wb3N0KFwib3JjaGVzdHJhdG9yX3YzXCIsIHBheWxvYWQpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2VuZFN0YXJ0Q29udmVyc2F0aW9uO1xyXG4iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvc3RhdGVcIjtcclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5cclxuaW1wb3J0IHNldE9yY2hlc3RyYXRvclBheWxvYWQgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9zZXQtb3JjaGVzdHJhdG9yLXBheWxvYWRcIjtcclxuXHJcbmNvbnN0IHNlbmRTdGFydENvbnZlcnNhdGlvbiA9IGZ1bmN0aW9uKGh0dHAgPSBuZXcgSHR0cCgpLCBzdGF0ZSA9IG5ldyBTdGF0ZSgpKSB7XHJcbiAgY29uc3QgcGF5bG9hZCA9IHNldE9yY2hlc3RyYXRvclBheWxvYWQudjMudGV4dChcInN0YXJ0XCIsIHN0YXRlKTtcclxuICBwYXlsb2FkLmlucHV0ID0gbnVsbDtcclxuICByZXR1cm4gaHR0cC5wb3N0KFwib3JjaGVzdHJhdG9yX3YzXCIsIHBheWxvYWQpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2VuZFN0YXJ0Q29udmVyc2F0aW9uO1xyXG4iLCJpbXBvcnQgQVBQX0NPTlNUQU5UUyBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XHJcbmltcG9ydCBzZW5kVGV4dCBmcm9tIFwiLi4vaGVscGVycy9yZXN0LWFwaS9zZW5kLXRleHRcIjtcclxuaW1wb3J0IHNlbmRWb2ljZSBmcm9tIFwiLi4vaGVscGVycy9yZXN0LWFwaS9zZW5kLXZvaWNlXCI7XHJcbmltcG9ydCBzZW5kUG9zdEJhY2sgZnJvbSBcIi4uL2hlbHBlcnMvcmVzdC1hcGkvc2VuZC1wb3N0LWJhY2tcIjtcclxuaW1wb3J0IHNlbmRSZXNldCBmcm9tIFwiLi4vaGVscGVycy9yZXN0LWFwaS9zZW5kLXJlc2V0XCI7XHJcbmltcG9ydCBzZW5kU3RhcnRDb252ZXJzYXRpb24gZnJvbSBcIi4uL2hlbHBlcnMvcmVzdC1hcGkvc2VuZC1zdGFydC1jb252ZXJzYXRpb25cIjtcclxuaW1wb3J0IGluamVjdERlcGVuZGVuY2llcyBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2RlcGVuZGVuY2llcy9pbmplY3QtZGVwZW5kZW5jaWVzXCI7XHJcbmltcG9ydCBTdGF0ZSBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9zdGF0ZVwiO1xyXG5pbXBvcnQgUHViU3ViIGZyb20gXCJCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL3B1Yi1zdWJcIjtcclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5cclxuY29uc3QgU3RhdGVLZXkgPSBBUFBfQ09OU1RBTlRTLlNUQVRFUy5DT05WRVJTQVRJT047XHJcblxyXG5sZXQgaW5zdGFuY2U7XHJcblxyXG5jbGFzcyBDb21tdW5pY2F0aW9uIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgaW5qZWN0RGVwZW5kZW5jaWVzKFtTdGF0ZSwgUHViU3ViLCBIdHRwXSwgdGhpcyk7XHJcbiAgICAgIGluc3RhbmNlID0gdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGRhdGEgdGhhdCdzIGltcG9ydGFudCBmb3IgdGhpcyBjb252ZXJzYXRpb25cclxuICAgKiBAcGFyYW0ge09yY2hlc3RyYXRvclJlc3BvbnNlfVxyXG4gICAqIEByZXR1cm4ge0NvbnZlcmF0aW9uT3V0cHV0fVxyXG4gICAqL1xyXG4gICNleHRyYWN0Q29udmVyc2F0aW9uRnJvbVJlc3BvbnNlKF9yZXNwb25zZSkge1xyXG4gICAgbGV0IGRhdGE7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKF9yZXNwb25zZS5zeXN0ZW0pIHtcclxuICAgICAgICBkYXRhID0gX3Jlc3BvbnNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGEgPSBfcmVzcG9uc2UucmVzdWx0LmNvbnRlbnQ7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgdGV4dDogXCJlcnJvclwiLFxyXG4gICAgICAgIHR5cGU6IFwiZGlyZWN0X21lc3NhZ2VcIlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwib3V0cHV0XCIsXHJcbiAgICAgIGRhdGFcclxuICAgIH07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgZXZlbnQgdG8gdGhlIHVzZXIgc2F5aW5nIHRoYXQgdGhlIGNvbnZlcnNhdGlvbiBpcyB1cGRhdGVkXHJcbiAgICogQHBhcmFtICB7W3R5cGVdfSBkYXRhIFtkZXNjcmlwdGlvbl1cclxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAqL1xyXG4gICN1cGRhdGVDb252ZXJzYXRpb25FdmVudChkYXRhKSB7XHJcbiAgICB0aGlzLlB1YlN1Yi5lbWl0KEFQUF9DT05TVEFOVFMuRVZFTlRTLkNPTlZFUlNBVElPTl9VUERBVEUsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2VzIGRhdGEgdG8gY3JlYXRlIGEgaW5wdXQgb2JqZWN0IGFuZCBhZGQgaXQgdG8gdGhlIGNvbnZlcnNhdGlvbiBsaXN0XHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBhY3Rpb24gW2Rlc2NyaXB0aW9uXVxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGF0YSAgIFtkZXNjcmlwdGlvbl1cclxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRvaW9uSW5wdXR9ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICovXHJcbiAgI3BhcnNlRGF0YUZvckNvbnZlcnNhdGlvbihhY3Rpb24sIGRhdGEpIHtcclxuICAgIGRhdGEgPSB7XHJcbiAgICAgIHR5cGU6IFwiaW5wdXRcIixcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHR5cGU6IFwiXCIsXHJcbiAgICAgICAgY29udGVudDogZGF0YVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHN3aXRjaCAoYWN0aW9uKSB7XHJcbiAgICAgIGNhc2UgXCJzZW5kVGV4dFwiOlxyXG4gICAgICAgIGRhdGEuZGF0YS50eXBlID0gXCJ0ZXh0XCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJzZW5kUG9zdEJhY2tcIjpcclxuICAgICAgICBkYXRhLmRhdGEudHlwZSA9IFwicG9zdGJhY2tcIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInNlbmRWb2ljZVwiOlxyXG4gICAgICAgIGRhdGEuZGF0YS50eXBlID0gXCJ2b2ljZVwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmVyaWZpZXMgaXMgQVBJIGlzIHJlYWR5XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxyXG4gICAqL1xyXG4gICNtaWRkbGV3YXJlSXNBcGlJbml0aWF0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5TdGF0ZS5nZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuQVBJX1JFQURZKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFB1c2hlcyBpbnB1dCB0byB0aGUgY29udmVyc2F0aW9uIGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIGNvbnZlcnNhdGlvblxyXG4gICAqIHBsdXMgdGhlIGluZGV4IG9mIHRoaXMgaW5wdXQgZm9yIHRoZSBjYXNlIG9mIGEgYmFkIG5ldHdvcmtcclxuICAgKiBjb25uZWN0aW9uIGFuZCB3YXJuIHVzZXJzIGl0IGZhaWxlZFxyXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZGF0YSBbZGVzY3JpcHRpb25dXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgKi9cclxuICAjbWlkZGxld2FyZUJlZm9yZShkYXRhKSB7XHJcbiAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLlN0YXRlLmdldChTdGF0ZUtleSkgfHwgW107XHJcblxyXG4gICAgLy8gVXNlIHNldCBvcmNoZXN0cmF0b3IgcGF5bG9hZCBzZmZcclxuICAgIC8vQWRkcyBvYmplY3QgdG8gdGhlIGNvbnZlcnNhdGlvbiBzdGF0ZVxyXG4gICAgY29udmVyc2F0aW9uLnB1c2goZGF0YSk7XHJcblxyXG4gICAgdGhpcy5TdGF0ZS5zZXQoU3RhdGVLZXksIGNvbnZlcnNhdGlvbik7XHJcblxyXG4gICAgLy8gU2VuZCBhIGV2ZW50IHRvIHRoZSBwdWJzdWJcclxuICAgIHRoaXMuI3VwZGF0ZUNvbnZlcnNhdGlvbkV2ZW50KGRhdGEpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGluZGV4OiBjb252ZXJzYXRpb24ubGVuZ3RoIC0gMSxcclxuICAgICAgY29udmVyc2F0aW9uXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogW2Rlc2NyaXB0aW9uXVxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYWN0aW9uIFtkZXNjcmlwdGlvbl1cclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgICBbZGVzY3JpcHRpb25dXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgKi9cclxuICBhc3luYyAjbWlkZGxld2FyZShhY3Rpb24sIGRhdGEpIHtcclxuICAgIGxldCBjb252ZXJzYXRpb247XHJcblxyXG4gICAgLy8gTWlkZGxld2FyZSBBUElcclxuICAgIGlmICghdGhpcy4jbWlkZGxld2FyZUlzQXBpSW5pdGlhdGVkKCkpXHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChSZXNwb25zZSgxLCB7IG1lc3NhZ2U6IFwiQVBJX05PVF9SRUFEWVwiIH0pKTtcclxuXHJcbiAgICAvLyBNaWRkbGV3YXJlIGFkZCB0byBjb252ZXJzZGF0aW9uXHJcbiAgICBjb25zdCBjb252ZXJzYXRpb25CZWZvcmUgPSB0aGlzLiNtaWRkbGV3YXJlQmVmb3JlKFxyXG4gICAgICB0aGlzLiNwYXJzZURhdGFGb3JDb252ZXJzYXRpb24oYWN0aW9uLCBkYXRhKVxyXG4gICAgKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBsZXQgX3Jlc3BvbnNlO1xyXG5cclxuICAgICAgaWYgKGFjdGlvbiA9PT0gXCJzZW5kVGV4dFwiKSBfcmVzcG9uc2UgPSBhd2FpdCBzZW5kVGV4dChkYXRhKTtcclxuICAgICAgaWYgKGFjdGlvbiA9PT0gXCJzZW5kVm9pY2VcIikgX3Jlc3BvbnNlID0gYXdhaXQgc2VuZFZvaWNlKGRhdGEpO1xyXG4gICAgICBpZiAoYWN0aW9uID09PSBcInNlbmRQb3N0QmFja1wiKSBfcmVzcG9uc2UgPSBhd2FpdCBzZW5kUG9zdEJhY2soZGF0YSk7XHJcbiAgICAgIGlmIChhY3Rpb24gPT09IFwic2VuZFJlc2V0XCIpIF9yZXNwb25zZSA9IGF3YWl0IHNlbmRSZXNldCgpO1xyXG4gICAgICBpZiAoYWN0aW9uID09PSBcInNlbmRTdGFydENvbnZlcnNhdGlvblwiKVxyXG4gICAgICAgIF9yZXNwb25zZSA9IGF3YWl0IHNlbmRTdGFydENvbnZlcnNhdGlvbihkYXRhKTtcclxuXHJcbiAgICAgIC8vIEdldCB3aGF0IG1hdHRlcnMgZnJvbSB0aGUgcGF5bG9hZFxyXG4gICAgICBfcmVzcG9uc2UgPSB0aGlzLiNleHRyYWN0Q29udmVyc2F0aW9uRnJvbVJlc3BvbnNlKF9yZXNwb25zZSk7XHJcblxyXG4gICAgICAvLyBTdWNjZXNzIDogdXBkYXRlIHRoZSBjb252ZXJzYXRpb24gc3RhdGVcclxuICAgICAgY29udmVyc2F0aW9uID0gdGhpcy5TdGF0ZS5nZXQoU3RhdGVLZXkpO1xyXG4gICAgICBjb252ZXJzYXRpb24ucHVzaChfcmVzcG9uc2UpO1xyXG5cclxuICAgICAgdGhpcy5TdGF0ZS5zZXQoU3RhdGVLZXksIGNvbnZlcnNhdGlvbik7XHJcblxyXG4gICAgICB0aGlzLiN1cGRhdGVDb252ZXJzYXRpb25FdmVudChfcmVzcG9uc2UpO1xyXG4gICAgICAvLyBSZXR1cm4gdGhlIF9yZXNwb25zZSB0byB0aGUgdXNlclxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF9yZXNwb25zZSk7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAvLyBVcGRhdGUgY29udmVyc2F0aW9uIGJ5IGluZGV4IGFuZCBzYXkgaXQgZGlkbnQgZ2V0IHRoZXJlICxcclxuICAgICAgLy8gd2FybiB1c2VycyB0aGF0IHRoaXMgcmVxdWVzdCBpc24ndCBzdWNjZXNzZnVsbFxyXG4gICAgICBsZXQgY29udmVyc2F0aW9uID0gdGhpcy5TdGF0ZS5nZXQoU3RhdGVLZXkpO1xyXG4gICAgICBjb252ZXJzYXRpb25bY29udmVyc2F0aW9uQmVmb3JlLmluZGV4XS5mYWlsZWQgPSB0cnVlO1xyXG4gICAgICAvLyBVcGRhdGUgU3RhdGVcclxuICAgICAgdGhpcy5TdGF0ZS5zZXQoU3RhdGVLZXksIGNvbnZlcnNhdGlvbik7XHJcbiAgICAgIC8vIFNlbmQgaW5mbyB0byBkZXZlbG9wZXIgc28gdGhleSBjYW4gaGFuZGxlIHRoaXMgZmFpbHVyZVxyXG4gICAgICB0aGlzLlB1YlN1Yi5lbWl0KEFQUF9DT05TVEFOVFMuRVZFTlRTLkNPTlZFUlNBVElPTl9SRVBMWV9GQUlMLCB7XHJcbiAgICAgICAgaW5kZXg6IGNvbnZlcnNhdGlvbkJlZm9yZS5pbmRleCxcclxuICAgICAgICByZXBseTogY29udmVyc2F0aW9uW2NvbnZlcnNhdGlvbkJlZm9yZS5pbmRleF1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBTZW5kcyB0ZXh0LCB2b2ljZSBvciBwb3N0YmFjayByZXBseXNcclxuICAgKiBAcGFyYW0gIHtbdHlwZV19ICBkYXRhIFtkZXNjcmlwdGlvbl1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgKi9cclxuICBhc3luYyBzZW5kVGV4dChkYXRhKSB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jbWlkZGxld2FyZShcInNlbmRUZXh0XCIsIGRhdGEpO1xyXG4gIH1cclxuICBhc3luYyBzZW5kVm9pY2UoZGF0YSkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI21pZGRsZXdhcmUoXCJzZW5kVm9pY2VcIiwgZGF0YSk7XHJcbiAgfVxyXG4gIGFzeW5jIHNlbmRQb3N0QmFjayhkYXRhKSB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jbWlkZGxld2FyZShcInNlbmRQb3N0QmFja1wiLCBkYXRhKTtcclxuICB9XHJcbiAgYXN5bmMgc2VuZFN0YXJ0Q29udmVyc2F0aW9uKCkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI21pZGRsZXdhcmUoXCJzZW5kU3RhcnRDb252ZXJzYXRpb25cIik7XHJcbiAgfVxyXG4gIGFzeW5jIHNlbmRSZXNldCgpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLiNtaWRkbGV3YXJlKFwic2VuZFJlc2V0XCIpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29tbXVuaWNhdGlvbjtcclxuIiwiaW1wb3J0IEFQUF9DT05TVEFOVFMgZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgZ2V0T3JDcmVhdGVDaGF0Ym90U2Vzc2lvbiBmcm9tIFwiLi4vaGVscGVycy9yZXN0LWFwaS9nZXQtb3ItY3JlYXRlLWNoYXRib3Qtc2Vzc2lvblwiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvc3RhdGVcIjtcclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5pbXBvcnQgUmVzcG9uc2UgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvcmVzcG9uc2VcIjtcclxuaW1wb3J0IENvbW11bmljYXRpb24gZnJvbSBcIi4uL3V0aWxzL2NvbW11bmljYXRpb25cIjtcclxuaW1wb3J0IGluamVjdERlcGVuZGVuY2llcyBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9oZWxwZXJzL2RlcGVuZGVuY2llcy9pbmplY3QtZGVwZW5kZW5jaWVzXCI7XHJcblxyXG5jbGFzcyBTZXNzaW9uIHtcclxuICAjbWV0YSA9IHtcclxuICAgIHVzZXI6IGZhbHNlLFxyXG4gICAgaWQ6IGZhbHNlLFxyXG4gICAgbW9kdWxlOiBmYWxzZSxcclxuICAgIHByb2plY3RJZDogZmFsc2UsXHJcbiAgICBpc09wZW46IGZhbHNlXHJcbiAgfTtcclxuXHJcbiAgI3Nlc3Npb24gPSB7fTtcclxuICAjY29udmVyc2F0aW9uID0gW107XHJcblxyXG4gIHBhcmFtZXRlcnMgPSB7fTtcclxuXHJcbiAgY29uc3RydWN0b3IoYW1Nb2R1bGUsIHVzZXIpIHtcclxuICAgIGlmICghYW1Nb2R1bGUgfHwgIXVzZXIpIHtcclxuICAgICAgdGhyb3cgXCJFUlJPUi5TRVNTSU9OX0NSRUFURV9XSVRIT1VUX0xPR0lOX09SX0lOSVRcIjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLiNtZXRhLm1vZHVsZSA9IGFtTW9kdWxlO1xyXG4gICAgdGhpcy4jbWV0YS51c2VyID0gdXNlcjtcclxuXHJcbiAgICBpbmplY3REZXBlbmRlbmNpZXMoW1Jlc3BvbnNlLCBTdGF0ZSwgSHR0cCwgQ29tbXVuaWNhdGlvbl0sIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0SWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jbWV0YS5pZDtcclxuICB9XHJcblxyXG4gIGdldFVzZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jbWV0YS51c2VyO1xyXG4gIH1cclxuXHJcbiAgZ2V0TW9kdWxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI21ldGEubW9kdWxlO1xyXG4gIH1cclxuXHJcbiAgaXNPcGVuKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI21ldGEuaXNPcGVuO1xyXG4gIH1cclxuXHJcbiAgc2VuZFRleHQodGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMuQ29tbXVuaWNhdGlvbi5zZW5kVGV4dCh0ZXh0KTtcclxuICB9XHJcblxyXG4gIHNlbmRWb2ljZShhdWRpbykge1xyXG4gICAgcmV0dXJuIHRoaXMuQ29tbXVuaWNhdGlvbi5zZW5kVm9pY2UoYXVkaW8pO1xyXG4gIH1cclxuXHJcbiAgc2VuZFBvc3RCYWNrKHBvc3RiYWNrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5Db21tdW5pY2F0aW9uLnNlbmRQb3N0QmFjayhwb3N0YmFjayk7XHJcbiAgfVxyXG5cclxuICBzZW5kU3RhcnRDb252ZXJzYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5Db21tdW5pY2F0aW9uLnNlbmRTdGFydENvbnZlcnNhdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgc2VuZExvZ291dCgpIHtcclxuICAgIHJldHVybiB0aGlzLkNvbW11bmljYXRpb24uc2VuZExvZ291dCh7fSk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm5zIGNvbnZlcnNhdGlvblxyXG4gIGFzeW5jIGdldFNlc3Npb24oKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0T3JDcmVhdGVDaGF0Ym90U2Vzc2lvbigpO1xyXG5cclxuICAgICAgaWYgKHNlc3Npb24pIHtcclxuICAgICAgICB0aGlzLiNtZXRhLmlzT3BlbiA9IHNlc3Npb24uYXR0cmlidXRlcy5zdGF0dXMgPT09IFwib3BlblwiO1xyXG4gICAgICAgIHRoaXMuI21ldGEucHJvamVjdElkID0gc2Vzc2lvbi5yZWxhdGlvbnNoaXBzLnByb2plY3QuZGF0YS5pZDtcclxuICAgICAgICB0aGlzLiNtZXRhLmlkID0gc2Vzc2lvbi5pZDtcclxuICAgICAgICB0aGlzLiNzZXNzaW9uID0gc2Vzc2lvbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLiNidWlsZENvbnZlcnNhdGlvbkZyb21TZXNzaW9uKHNlc3Npb24pKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuI2NvbnZlcnNhdGlvbik7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoUmVzcG9uc2UuZXJyb3IoeyBtZXNzYWdlOiBleCwgZGF0YTogZXggfSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGEgY29udmVyc2F0aW9uXHJcbiAgYXN5bmMgZ2V0Q29udmVyc2F0aW9uKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IGNvbnZlcnNhdGlvbiA9IHRoaXMuI2NvbnZlcnNhdGlvbjtcclxuXHJcbiAgICAgIGlmIChjb252ZXJzYXRpb24ubGVuZ3RoID4gMCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb252ZXJzYXRpb24pO1xyXG5cclxuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpO1xyXG5cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZXNzaW9uKTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihleCk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy4jY29udmVyc2F0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHVwZGF0ZSBjb252ZXJzYXRpb25cclxuICAjdXBkYXRlQ29udmVyc2F0aW9uKHR5cGUsIGRhdGEpIHtcclxuICAgIGlmICh0eXBlICYmIGRhdGEpIHtcclxuICAgICAgY29uc3QgY29udmVyc2F0aW9uT2JqZWN0ID0ge1xyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgZGF0YVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLiNjb252ZXJzYXRpb24ucHVzaChjb252ZXJzYXRpb25PYmplY3QpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gYnVpbGRzIGNvbnZlcnNhdGlvbiBmcm9tIHNlc3Npb24gb2JqZWN0XHJcbiAgI2J1aWxkQ29udmVyc2F0aW9uRnJvbVNlc3Npb24oc2Vzc2lvbikge1xyXG4gICAgaWYgKCFzZXNzaW9uIHx8ICFzZXNzaW9uLmF0dHJpYnV0ZXMgfHwgIXNlc3Npb24uYXR0cmlidXRlcy5jb250ZXh0KVxyXG4gICAgICByZXR1cm4gdGhpcy4jY29udmVyc2F0aW9uO1xyXG5cclxuICAgIGNvbnN0IGNvbnRleHQgPSBzZXNzaW9uLmF0dHJpYnV0ZXMuY29udGV4dDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBjb250ZXh0Lm5faW50ZXJhY3Rpb25zOyBpKyspIHtcclxuICAgICAgY29uc3Qga2V5ID0gXCJpbnRlcmFjdGlvbl9cIiArIGk7XHJcblxyXG4gICAgICBsZXQgaW5wdXQgPVxyXG4gICAgICAgIGNvbnRleHQuaW5wdXRzW2tleV0gJiYgQXJyYXkuaXNBcnJheShjb250ZXh0LmlucHV0c1trZXldKVxyXG4gICAgICAgICAgPyBjb250ZXh0LmlucHV0c1trZXldWzBdXHJcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgbGV0IG91dHB1dCA9XHJcbiAgICAgICAgY29udGV4dC5vdXRwdXRzW2tleV0gJiYgQXJyYXkuaXNBcnJheShjb250ZXh0Lm91dHB1dHNba2V5XSlcclxuICAgICAgICAgID8gY29udGV4dC5vdXRwdXRzW2tleV1bMF1cclxuICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgdGhpcy4jdXBkYXRlQ29udmVyc2F0aW9uKFwiaW5wdXRcIiwgaW5wdXQpO1xyXG4gICAgICB0aGlzLiN1cGRhdGVDb252ZXJzYXRpb24oXCJvdXRwdXRcIiwgb3V0cHV0KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLlN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5DT05WRVJTQVRJT04sIHRoaXMuI2NvbnZlcnNhdGlvbik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuI2NvbnZlcnNhdGlvbjtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlc2V0KCkge1xyXG4gICAgY29uc3QgcmVzZXQgPSBhd2FpdCB0aGlzLkNvbW11bmljYXRpb24uc2VuZFJlc2V0KCk7XHJcbiAgICB0aGlzLiNjb252ZXJzYXRpb24gPSB7fTtcclxuXHJcbiAgICByZXR1cm4gcmVzZXQ7XHJcbiAgICAvLyB0aGlzLiNtZXRhID0ge1xyXG4gICAgLy8gICB1c2VyOiBmYWxzZSxcclxuICAgIC8vICAgaWQ6IGZhbHNlLFxyXG4gICAgLy8gICBtb2R1bGU6IGZhbHNlLFxyXG4gICAgLy8gICBwcm9qZWN0SWQ6IGZhbHNlLFxyXG4gICAgLy8gICBpc09wZW46IGZhbHNlXHJcbiAgICAvLyB9O1xyXG4gICAgLy8gdGhpcy4jc2Vzc2lvbiA9IHt9O1xyXG4gICAgLy8gdGhpcy4jY29udmVyc2F0aW9uID0ge307XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTZXNzaW9uO1xyXG4iLCJjb25zdCBTZXNzaW9uTW9kZWwgPSBmdW5jdGlvbigpIHtcclxuICAvLyBQYXJhbWV0cm9zIGRlZmF1bHQgZGVzdGUgbW9kZWxvXHJcbiAgY29uc3QgbW9kZWwgPSB7fTtcclxuXHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG1vZGVsKTtcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgIFNlc3Npb25Nb2RlbDtcclxuIiwiLypcclxuY29uc3QgSHR0cCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9odHRwXCIpO1xyXG5jb25zdCBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbHMvc2Vzc2lvblwiKSgpO1xyXG5jb25zdCBzZXRNb2RlbFBhcmFtcyA9IHJlcXVpcmUoXCIuLi9zZXQtbW9kZWwtcGFyYW1zXCIpO1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgbmV3IGNoYXRib3QgdXNlclxyXG4gKiBAcGFyYW0gIHtDaGF0Ym90VXNlcn0gZGF0YSBbZGVzY3JpcHRpb25dXHJcbiAqIEByZXR1cm4ge1Byb21pc2V8Q2hhdGJvdFVzZXJNb2RlbH0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG5pbXBvcnQgSHR0cCBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9odHRwXCI7XHJcbmltcG9ydCBNb2RlbCBmcm9tIFwiLi4vLi4vbW9kZWxzL3Nlc3Npb25cIjtcclxuaW1wb3J0IGV4dGVuZEFuZEtlZXBTdHJ1Y3R1cmUgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9leHRlbmQtYW5kLWtlZXAtc3RydWN0dXJlXCI7XHJcblxyXG5jb25zdCBjcmVhdGVTZXNzaW9uID0gZnVuY3Rpb24oZGF0YSA9IE1vZGVsLCBodHRwID0gbmV3IEh0dHAoKSkge1xyXG4gIHJldHVybiBIdHRwLnBvc3QoXCJ1cmxcIiwgZXh0ZW5kQW5kS2VlcFN0cnVjdHVyZShNb2RlbCwgZGF0YSkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2Vzc2lvbjtcclxuIiwiaW1wb3J0IENiVXNlciBmcm9tICcuL2NiLXVzZXInO1xyXG5pbXBvcnQgU2Vzc2lvbiBmcm9tICcuL3Nlc3Npb24nO1xyXG5pbXBvcnQgZ2V0U2Vzc2lvbiBmcm9tICcuLi9oZWxwZXJzL3Jlc3QtYXBpL2dldC1zZXNzaW9uJztcclxuaW1wb3J0IGNyZWF0ZVNlc3Npb24gZnJvbSAnLi4vaGVscGVycy9yZXN0LWFwaS9jcmVhdGUtc2Vzc2lvbic7XHJcblxyXG5pbXBvcnQgSHR0cCBmcm9tICdCbHVlRGFyd2luSlMvc3JjL3NlcnZpY2VzL2h0dHAnO1xyXG5pbXBvcnQgaW5qZWN0RGVwZW5kZW5jaWVzIGZyb20gJ0JsdWVEYXJ3aW5KUy9zcmMvaGVscGVycy9kZXBlbmRlbmNpZXMvaW5qZWN0LWRlcGVuZGVuY2llcyc7XHJcblxyXG5jbGFzcyBDYk1vZHVsZSB7XHJcbiAgI21ldGEgPSB7XHJcbiAgICBsYWJlbDogZmFsc2UsXHJcbiAgICBpZDogZmFsc2UsXHJcbiAgICBjaGFubmVsczogW10sXHJcbiAgICB1c2VyOiB7fSxcclxuICAgIGJvdDoge31cclxuICB9O1xyXG5cclxuICAjY2hhbm5lbFRva2VucyA9IFtdO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xyXG4gICAgbW9kZWwgPSBtb2RlbC5hdHRyaWJ1dGVzIHx8IG1vZGVsO1xyXG4gICAgdGhpcy4jbWV0YSA9IG1vZGVsO1xyXG4gICAgdGhpcy4jbWV0YS5sYWJlbCA9IG1vZGVsLmxhYmVsO1xyXG4gICAgdGhpcy4jbWV0YS5pZCA9IG1vZGVsLmlkO1xyXG4gICAgdGhpcy4jY2hhbm5lbFRva2VucyA9IG1vZGVsLmFtX2NoYW5uZWxfdG9rZW5zO1xyXG5cclxuICAgIHRoaXMuaW50ZW50cyA9IFtdO1xyXG5cclxuICAgIGluamVjdERlcGVuZGVuY2llcyhbSHR0cF0sIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0dGVyc1xyXG4gIGdldEludGVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogW2dldFNlc3Npb24gZGVzY3JpcHRpb25dXHJcbiAgICogQHJldHVybiB7U2Vzc2lvbn1cclxuICAgKi9cclxuICBnZXRTZXNzaW9uKGlkKSB7XHJcbiAgICByZXR1cm4gZ2V0U2Vzc2lvbihpZCwgdGhpcy5IdHRwKTtcclxuICB9XHJcblxyXG4gIGdldENoYW5uZWxzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI21ldGEuY2hhbm5lbHM7XHJcbiAgfVxyXG5cclxuICBnZXRMYWJlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLiNtZXRhLmxhYmVsO1xyXG4gIH1cclxuXHJcbiAgZ2V0SWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jbWV0YS5pZDtcclxuICB9XHJcblxyXG4gIGdldE1ldGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jbWV0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjYlVzZXIgW2Rlc2NyaXB0aW9uXVxyXG4gICAqIEByZXR1cm4ge0NiVXNlcn0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgKi9cclxuICBjcmVhdGVTZXNzaW9uKGNiVXNlcikge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNlc3Npb24oY2JVc2VyKTtcclxuICB9XHJcblxyXG4gIHNldE1ldGFDaGFubmVscygpIHt9XHJcblxyXG4gIHNldE1ldGFVc2VyKGNiVXNlcikge1xyXG4gICAgdGhpcy4jbWV0YS51c2VyID0gbmV3IENiVXNlcihjYlVzZXIpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2JNb2R1bGU7XHJcbiIsIi8qXHJcbmNvbnN0IEh0dHAgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvaHR0cFwiKTtcclxuXHJcbmNvbnN0IGFjdGlvbiA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgcmV0dXJuIEh0dHAuZ2V0KGBhbV9jaGFubmVscy8ke2lkfWApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgIGFjdGlvbjtcclxuKi9cclxuaW1wb3J0IEh0dHAgZnJvbSBcIkJsdWVEYXJ3aW5KUy9zcmMvc2VydmljZXMvaHR0cFwiO1xyXG5jb25zdCBnZXRDaGFubmVsID0gZnVuY3Rpb24oaWQsIGh0dHAgPSBuZXcgSHR0cCgpKSB7XHJcbiAgcmV0dXJuIGh0dHAuZ2V0KGBhbV9jaGFubmVscy8ke2lkfWApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0Q2hhbm5lbDtcclxuIiwiLypcclxuY29uc3QgSHR0cCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9odHRwXCIpO1xyXG5cclxuY29uc3QgYWN0aW9uID0gZnVuY3Rpb24oaWQpIHtcclxuICByZXR1cm4gSHR0cC5nZXQoYGFtX2NoYW5uZWxzLyR7aWR9YCk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCAgYWN0aW9uO1xyXG4qL1xyXG5pbXBvcnQgSHR0cCBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9odHRwXCI7XHJcbmNvbnN0IGdldENoYW5uZWwgPSBmdW5jdGlvbihpZCwgaHR0cCA9IG5ldyBIdHRwKCkpIHtcclxuICByZXR1cm4gaHR0cC5nZXQoYGFtX2NoYW5uZWxfdG9rZW5zLyR7aWR9YCk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRDaGFubmVsO1xyXG4iLCJpbXBvcnQgSHR0cCBmcm9tIFwiQmx1ZURhcndpbkpTL3NyYy9zZXJ2aWNlcy9odHRwXCI7XHJcblxyXG5jb25zdCBnZXRJbnRlbnQgPSBmdW5jdGlvbihpZCwgaHR0cCA9IG5ldyBIdHRwKCkpIHtcclxuICByZXR1cm4gaHR0cC5nZXQoYGFtX2ludGVudHMvJHtpZH1gKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldEludGVudDtcclxuIiwiLy8gaW1wb3J0IFwiaWRlbXBvdGVudC1iYWJlbC1wb2x5ZmlsbFwiO1xyXG5cclxuaW1wb3J0IEFQUF9DT05TVEFOVFMgZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xyXG5cclxuaW1wb3J0IENiTW9kdWxlIGZyb20gXCIuLi9jb21wb25lbnRzL2NiLW1vZHVsZVwiO1xyXG5cclxuaW1wb3J0IGdldE1vZHVsZSBmcm9tIFwiLi4vaGVscGVycy9yZXN0LWFwaS9nZXQtbW9kdWxlXCI7XHJcbmltcG9ydCBnZXRDaGFubmVsIGZyb20gXCIuLi9oZWxwZXJzL3Jlc3QtYXBpL2dldC1jaGFubmVsXCI7XHJcbmltcG9ydCBnZXRDaGFubmVsVG9rZW4gZnJvbSBcIi4uL2hlbHBlcnMvcmVzdC1hcGkvZ2V0LWNoYW5uZWwtdG9rZW5cIjtcclxuaW1wb3J0IGdldEludGVudCBmcm9tIFwiLi4vaGVscGVycy9yZXN0LWFwaS9nZXQtaW50ZW50XCI7XHJcbmltcG9ydCBnZXRDaGF0Ym90VXNlciBmcm9tIFwiLi4vaGVscGVycy9yZXN0LWFwaS9nZXQtY2hhdGJvdC11c2VyXCI7XHJcblxyXG5pbXBvcnQgQ2hhdGJvdFVzZXJNb2RlbCBmcm9tIFwiLi4vbW9kZWxzL2NoYXRib3QtdXNlclwiO1xyXG5cclxuaW1wb3J0IFNlc3Npb24gZnJvbSBcIi4uL2NvbXBvbmVudHMvc2Vzc2lvblwiO1xyXG5pbXBvcnQgQ2hhdGJvdCBmcm9tIFwiLi4vY2hhdGJvdFwiO1xyXG5cclxuY2xhc3MgQXBpIGV4dGVuZHMgQ2hhdGJvdCB7XHJcbiAgI2NoYW5uZWxzID0gW107XHJcbiAgI2ludGVudDtcclxuICAjc2Vzc2lvbjtcclxuICAjY2hhdGJvdE1vZHVsZTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLlB1YlN1YjtcclxuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzLmVtaXQ7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50cy5vZmY7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50cy5yZXNldDtcclxuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzLmdldEV2ZW50cztcclxuXHJcbiAgICAgIHRoaXMuZXZlbnRzLm9uKFwiTE9HT1VUXCIsICgpID0+IHtcclxuICAgICAgICAvLyB0aGlzLiNzZXNzaW9uLnJlc2V0KCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5TdGF0ZS5saXN0KCkpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGNvbnNvbGUuZGlyKGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jICNpbml0R2V0TW9kdWxlKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYW1Nb2R1bGUgPSBhd2FpdCBnZXRNb2R1bGUodGhpcy5tb2R1bGUsIHRoaXMuSHR0cCwgdGhpcy5TdGF0ZSk7XHJcblxyXG4gICAgICBpZiAoIWFtTW9kdWxlIHx8IGFtTW9kdWxlID09PSBcIml0ZW0gbm90IGZvdW5kXCIpIHtcclxuICAgICAgICB0aHJvdyBcIkVSUk9SLk1PRFVMRV9OT1RfRk9VTkRcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5TdGF0ZS5zZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuTU9ERUxfTU9EVUxFLCBhbU1vZHVsZSk7XHJcbiAgICAgIHRoaXMuU3RhdGUuc2V0KFxyXG4gICAgICAgIEFQUF9DT05TVEFOVFMuU1RBVEVTLkhBU19QUk9KRUNULFxyXG4gICAgICAgIGFtTW9kdWxlLnJlbGF0aW9uc2hpcHMucHJvamVjdCAmJlxyXG4gICAgICAgICAgYW1Nb2R1bGUucmVsYXRpb25zaGlwcy5wcm9qZWN0LmRhdGEgJiZcclxuICAgICAgICAgIGFtTW9kdWxlLnJlbGF0aW9uc2hpcHMucHJvamVjdC5kYXRhLmlkXHJcbiAgICAgICAgICA/IGFtTW9kdWxlLnJlbGF0aW9uc2hpcHMucHJvamVjdC5kYXRhLmlkXHJcbiAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICApO1xyXG5cclxuICAgICAgdGhpcy4jY2hhdGJvdE1vZHVsZSA9IG5ldyBDYk1vZHVsZShhbU1vZHVsZSk7XHJcblxyXG4gICAgICByZXR1cm4gYW1Nb2R1bGU7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICB0aHJvdyBleDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jICNpbml0R2V0Q2hhbm5lbHMoYW1Nb2R1bGUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vR2V0IHRoZSBjaGFubmVsc1xyXG4gICAgICBmb3IgKFxyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBpIDwgYW1Nb2R1bGUucmVsYXRpb25zaGlwcy5hbV9jaGFubmVsX3Rva2Vucy5kYXRhLmxlbmd0aDtcclxuICAgICAgICBpKytcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbm5lbFRva2VuSWQgPVxyXG4gICAgICAgICAgYW1Nb2R1bGUucmVsYXRpb25zaGlwcy5hbV9jaGFubmVsX3Rva2Vucy5kYXRhW2ldLmlkO1xyXG5cclxuICAgICAgICBjb25zdCBjaGFubmVsVG9rZW4gPSBhd2FpdCBnZXRDaGFubmVsVG9rZW4oY2hhbm5lbFRva2VuSWQsIHRoaXMuSHR0cCk7XHJcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IGdldENoYW5uZWwoXHJcbiAgICAgICAgICBjaGFubmVsVG9rZW4ucmVsYXRpb25zaGlwcy5hbV9jaGFubmVsLmRhdGEuaWRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoY2hhbm5lbC5hdHRyaWJ1dGVzLmxhYmVsID09PSBcIkJsdWVEYXJ3aW5cIikge1xyXG4gICAgICAgICAgdGhpcy4jY2hhbm5lbHMucHVzaChjaGFubmVsLmF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgdGhpcy5TdGF0ZS5zZXQoXHJcbiAgICAgICAgICAgIEFQUF9DT05TVEFOVFMuU1RBVEVTLkNIQU5ORUxfVE9LRU4sXHJcbiAgICAgICAgICAgIGNoYW5uZWxUb2tlbi5hdHRyaWJ1dGVzLnRva2VuXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLlN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5NT0RFTF9DSEFOTkVMUywgdGhpcy4jY2hhbm5lbHMpO1xyXG4gICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgdGhyb3cgZXg7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyAjaW5pdEdldEludGVudChhbU1vZHVsZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHRoZSBpbnRlbnRcclxuICAgICAgY29uc3QgaW50ZW50ID0gYXdhaXQgZ2V0SW50ZW50KFxyXG4gICAgICAgIGFtTW9kdWxlLnJlbGF0aW9uc2hpcHMuYW1faW50ZW50cy5kYXRhLmlkLFxyXG4gICAgICAgIHRoaXMuSHR0cFxyXG4gICAgICApO1xyXG4gICAgICB0aGlzLlN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5NT0RFTF9JTlRFTlQsIGludGVudCk7XHJcbiAgICAgIHRoaXMuI2ludGVudCA9IGludGVudDtcclxuICAgICAgcmV0dXJuIGludGVudDtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIHRocm93IGV4O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgI2luaXRHZXRDaGF0Ym90VXNlcigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNoYXRib3RVc2VyID0gYXdhaXQgZ2V0Q2hhdGJvdFVzZXIoKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5TdGF0ZS5zZXQoXHJcbiAgICAgICAgICBBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfQ0hBVEJPVF9VU0VSLFxyXG4gICAgICAgICAgY2hhdGJvdFVzZXJbMF0ucmVsYXRpb25zaGlwcy5hbV91c2Vycy5kYXRhLmlkXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLiNjaGF0Ym90TW9kdWxlLnNldE1ldGFVc2VyKGNoYXRib3RVc2VyWzBdLmF0dHJpYnV0ZXMpO1xyXG4gICAgICB9IGNhdGNoIChfZXgpIHtcclxuICAgICAgICB0aGlzLiNjaGF0Ym90TW9kdWxlLnNldE1ldGFVc2VyKENoYXRib3RVc2VyTW9kZWwoKSk7XHJcbiAgICAgICAgLy8gU2lsZW5jZSBpcyBnb2xkZW4uLi4uXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjaGF0Ym90VXNlcjtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIHRocm93IGV4O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYm9vdChfY2hhdGJvdFVzZXIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNldHVwIHRoZSBhcGxpY2F0aW9uXHJcbiAgICAgIGF3YWl0IHRoaXMuc2V0dXAoKTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgbW9kdWxlXHJcbiAgICAgIHRoaXMuY2hhdGJvdFVzZXIgPSBfY2hhdGJvdFVzZXIgfHwgdGhpcy5jaGF0Ym90VXNlcjtcclxuXHJcbiAgICAgIHRoaXMuU3RhdGUuc2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLklTX0lOSVRJQUxJWkVELCB0cnVlKTtcclxuICAgICAgdGhpcy5TdGF0ZS5zZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuSEFTX01PRFVMRSwgdGhpcy5tb2R1bGUpO1xyXG4gICAgICB0aGlzLlN0YXRlLnNldChBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfQ0xJRU5UX1VTRVJfSUQsIHRoaXMuY2hhdGJvdFVzZXIpO1xyXG5cclxuICAgICAgLy8gSWYgbm90IGxvZ2dlZCB3YWl0cyBmb3IgbG9naW4gdG8gdHJpZ2dlciBiZWZvcmUgcmVuZGVyaW5nIGFuZCBpbnN0YW5jaWF0aW5nIGlmcmFtZVxyXG4gICAgICBpZiAoIXRoaXMuU3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLklTX0xPR0dFRF9JTikpIHtcclxuICAgICAgICBjb25zdCByZWplY3Rpb24gPSB0aGlzLlJlc3BvbnNlLm9rKHtcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiQ2hhdGJvdCBpZnJhbWUgaW5pdDogV2FpdGluZyBmb3IgbG9naW5cIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWplY3Rpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBhbU1vZHVsZSA9IGF3YWl0IHRoaXMuI2luaXRHZXRNb2R1bGUoKTtcclxuICAgICAgYXdhaXQgdGhpcy4jaW5pdEdldENoYW5uZWxzKGFtTW9kdWxlKTtcclxuICAgICAgYXdhaXQgdGhpcy4jaW5pdEdldEludGVudChhbU1vZHVsZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuI2luaXRHZXRDaGF0Ym90VXNlcigpO1xyXG5cclxuICAgICAgdGhpcy4jc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKGFtTW9kdWxlLCBBUFBfQ09OU1RBTlRTLlNUQVRFUy5IQVNfVVNFUik7XHJcblxyXG4gICAgICBjb25zdCBjb252ZXJzYXRpb24gPSBhd2FpdCB0aGlzLiNzZXNzaW9uLmdldENvbnZlcnNhdGlvbigpO1xyXG5cclxuICAgICAgdGhpcy5TdGF0ZS5zZXQoQVBQX0NPTlNUQU5UUy5TVEFURVMuQVBJX1JFQURZLCB0cnVlKTtcclxuXHJcbiAgICAgIHRoaXMuUHViU3ViLmVtaXQoQVBQX0NPTlNUQU5UUy5FVkVOVFMuQVBJX1JFQURZKTtcclxuXHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udmVyc2F0aW9uKTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIHRoaXMuUHViU3ViLmVtaXQoQVBQX0NPTlNUQU5UUy5FVkVOVFMuQVBJX0ZBSUwpO1xyXG4gICAgICAvLyBSZXR1cm4gYXMgcHJvbWlzZVxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5SZXNwb25zZS5lcnJvcih7IG1lc3NhZ2U6IGV4IH0pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldE1ldGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jY2hhdGJvdE1vZHVsZS5nZXRNZXRhKCk7XHJcbiAgfVxyXG5cclxuICBnZXRDb252ZXJzYXRpb24oZGF0YSkge1xyXG4gICAgcmV0dXJuIHRoaXMuU3RhdGUuZ2V0KEFQUF9DT05TVEFOVFMuU1RBVEVTLkNPTlZFUlNBVElPTik7XHJcbiAgfVxyXG5cclxuICBzZW5kVGV4dChkYXRhKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jc2Vzc2lvbi5zZW5kVGV4dChkYXRhKTtcclxuICB9XHJcblxyXG4gIHNlbmRWb2ljZShkYXRhKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jc2Vzc2lvbi5zZW5kVm9pY2UoZGF0YSk7XHJcbiAgfVxyXG5cclxuICBzZW5kUG9zdEJhY2soZGF0YSkge1xyXG4gICAgcmV0dXJuIHRoaXMuI3Nlc3Npb24uc2VuZFBvc3RCYWNrKGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRDb252ZXJzYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jc2Vzc2lvbi5zZW5kU3RhcnRDb252ZXJzYXRpb24oKTtcclxuICB9XHJcblxyXG4gIHJlc2V0Q29udmVyc2F0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI3Nlc3Npb24ucmVzZXQoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFwaTtcclxuIiwiLy8gaWYgKCFnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcclxuLy8gICByZXF1aXJlKFwiYmFiZWwtcG9seWZpbGxcIik7XHJcbi8vIH1cclxuXHJcbi8vIGltcG9ydCBcIndoYXR3Zy1mZXRjaFwiO1xyXG5cclxuaW1wb3J0ICogYXMgaWZyYW1lIGZyb20gJy4vbGlicy9pZnJhbWUnO1xyXG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi9saWJzL2FwaSc7XHJcblxyXG5leHBvcnQgY29uc3QgSWZyYW1lID0gaWZyYW1lLmRlZmF1bHQ7XHJcbmV4cG9ydCBjb25zdCBBcGkgPSBhcGkuZGVmYXVsdDtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==
